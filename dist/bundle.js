var bluegenesExpressionHeatmap=function(t){var n={};function e(i){if(n[i])return n[i].exports;var s=n[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,e),s.l=!0,s.exports}return e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var s in t)e.d(i,s,function(n){return t[n]}.bind(null,s));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s="./src/index.js")}({"./node_modules/chart.js/dist/chart.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/chart.js/dist/chart.esm.js ***!
  \*************************************************/
/*! exports provided: defaults, Animation, Animations, Arc, BarController, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, DatasetController, DomPlatform, DoughnutController, Element, Filler, Interaction, Legend, Line, LineController, LinearScale, LogarithmicScale, PieController, Point, PolarAreaController, RadarController, RadialLinearScale, Rectangle, Scale, ScatterController, Ticks, TimeScale, TimeSeriesScale, Title, Tooltip, _adapters, animator, layouts, plugins, registry */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Animation\", function() { return Animation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Animations\", function() { return Animations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Arc\", function() { return Arc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarController\", function() { return BarController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasePlatform\", function() { return BasePlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicPlatform\", function() { return BasicPlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BubbleController\", function() { return BubbleController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CategoryScale\", function() { return CategoryScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chart\", function() { return Chart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DatasetController\", function() { return DatasetController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomPlatform\", function() { return DomPlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoughnutController\", function() { return DoughnutController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return Element; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Filler\", function() { return plugin_filler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interaction\", function() { return Interaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Legend\", function() { return plugin_legend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineController\", function() { return LineController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearScale\", function() { return LinearScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogarithmicScale\", function() { return LogarithmicScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PieController\", function() { return PieController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolarAreaController\", function() { return PolarAreaController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RadarController\", function() { return RadarController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RadialLinearScale\", function() { return RadialLinearScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rectangle\", function() { return Rectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scale\", function() { return Scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScatterController\", function() { return ScatterController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ticks\", function() { return Ticks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeScale\", function() { return TimeScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeSeriesScale\", function() { return TimeSeriesScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Title\", function() { return plugin_title; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tooltip\", function() { return plugin_tooltip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_adapters\", function() { return adapters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animator\", function() { return animator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"layouts\", function() { return layouts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plugins\", function() { return PluginService; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registry\", function() { return registry; });\n/* harmony import */ var _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.rtl.js */ \"./node_modules/chart.js/dist/chunks/helpers.rtl.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defaults\", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"]; });\n\n/*!\n * Chart.js v3.0.0-beta.3\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\nfunction drawFPS(chart, count, date, lastDate) {\n\tconst fps = (1000 / (date - lastDate)) | 0;\n\tconst ctx = chart.ctx;\n\tctx.save();\n\tctx.clearRect(0, 0, 50, 24);\n\tctx.fillStyle = 'black';\n\tctx.textAlign = 'right';\n\tif (count) {\n\t\tctx.fillText(count, 50, 8);\n\t\tctx.fillText(fps + ' fps', 50, 18);\n\t}\n\tctx.restore();\n}\nclass Animator {\n\tconstructor() {\n\t\tthis._request = null;\n\t\tthis._charts = new Map();\n\t\tthis._running = false;\n\t\tthis._lastDate = undefined;\n\t}\n\t_notify(chart, anims, date, type) {\n\t\tconst callbacks = anims.listeners[type] || [];\n\t\tconst numSteps = anims.duration;\n\t\tcallbacks.forEach(fn => fn({\n\t\t\tchart,\n\t\t\tnumSteps,\n\t\t\tcurrentStep: Math.min(date - anims.start, numSteps)\n\t\t}));\n\t}\n\t_refresh() {\n\t\tconst me = this;\n\t\tif (me._request) {\n\t\t\treturn;\n\t\t}\n\t\tme._running = true;\n\t\tme._request = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"r\"].call(window, () => {\n\t\t\tme._update();\n\t\t\tme._request = null;\n\t\t\tif (me._running) {\n\t\t\t\tme._refresh();\n\t\t\t}\n\t\t});\n\t}\n\t_update() {\n\t\tconst me = this;\n\t\tconst date = Date.now();\n\t\tlet remaining = 0;\n\t\tme._charts.forEach((anims, chart) => {\n\t\t\tif (!anims.running || !anims.items.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst items = anims.items;\n\t\t\tlet i = items.length - 1;\n\t\t\tlet draw = false;\n\t\t\tlet item;\n\t\t\tfor (; i >= 0; --i) {\n\t\t\t\titem = items[i];\n\t\t\t\tif (item._active) {\n\t\t\t\t\titem.tick(date);\n\t\t\t\t\tdraw = true;\n\t\t\t\t} else {\n\t\t\t\t\titems[i] = items[items.length - 1];\n\t\t\t\t\titems.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (draw) {\n\t\t\t\tchart.draw();\n\t\t\t\tme._notify(chart, anims, date, 'progress');\n\t\t\t}\n\t\t\tif (chart.options.animation.debug) {\n\t\t\t\tdrawFPS(chart, items.length, date, me._lastDate);\n\t\t\t}\n\t\t\tif (!items.length) {\n\t\t\t\tanims.running = false;\n\t\t\t\tme._notify(chart, anims, date, 'complete');\n\t\t\t}\n\t\t\tremaining += items.length;\n\t\t});\n\t\tme._lastDate = date;\n\t\tif (remaining === 0) {\n\t\t\tme._running = false;\n\t\t}\n\t}\n\t_getAnims(chart) {\n\t\tconst charts = this._charts;\n\t\tlet anims = charts.get(chart);\n\t\tif (!anims) {\n\t\t\tanims = {\n\t\t\t\trunning: false,\n\t\t\t\titems: [],\n\t\t\t\tlisteners: {\n\t\t\t\t\tcomplete: [],\n\t\t\t\t\tprogress: []\n\t\t\t\t}\n\t\t\t};\n\t\t\tcharts.set(chart, anims);\n\t\t}\n\t\treturn anims;\n\t}\n\tlisten(chart, event, cb) {\n\t\tthis._getAnims(chart).listeners[event].push(cb);\n\t}\n\tadd(chart, items) {\n\t\tif (!items || !items.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._getAnims(chart).items.push(...items);\n\t}\n\thas(chart) {\n\t\treturn this._getAnims(chart).items.length > 0;\n\t}\n\tstart(chart) {\n\t\tconst anims = this._charts.get(chart);\n\t\tif (!anims) {\n\t\t\treturn;\n\t\t}\n\t\tanims.running = true;\n\t\tanims.start = Date.now();\n\t\tanims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n\t\tthis._refresh();\n\t}\n\trunning(chart) {\n\t\tif (!this._running) {\n\t\t\treturn false;\n\t\t}\n\t\tconst anims = this._charts.get(chart);\n\t\tif (!anims || !anims.running || !anims.items.length) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tstop(chart) {\n\t\tconst anims = this._charts.get(chart);\n\t\tif (!anims || !anims.items.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst items = anims.items;\n\t\tlet i = items.length - 1;\n\t\tfor (; i >= 0; --i) {\n\t\t\titems[i].cancel();\n\t\t}\n\t\tanims.items = [];\n\t\tthis._notify(chart, anims, Date.now(), 'complete');\n\t}\n\tremove(chart) {\n\t\treturn this._charts.delete(chart);\n\t}\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n\tboolean(from, to, factor) {\n\t\treturn factor > 0.5 ? to : from;\n\t},\n\tcolor(from, to, factor) {\n\t\tconst c0 = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(from || transparent);\n\t\tconst c1 = c0.valid && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(to || transparent);\n\t\treturn c1 && c1.valid\n\t\t\t? c1.mix(c0, factor).hexString()\n\t\t\t: to;\n\t},\n\tnumber(from, to, factor) {\n\t\treturn from + (to - from) * factor;\n\t}\n};\nclass Animation {\n\tconstructor(cfg, target, prop, to) {\n\t\tconst currentValue = target[prop];\n\t\tto = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.to, to, currentValue, cfg.from]);\n\t\tconst from = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.from, currentValue, to]);\n\t\tthis._active = true;\n\t\tthis._fn = cfg.fn || interpolators[cfg.type || typeof from];\n\t\tthis._easing = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"e\"][cfg.easing || 'linear'];\n\t\tthis._start = Math.floor(Date.now() + (cfg.delay || 0));\n\t\tthis._duration = Math.floor(cfg.duration);\n\t\tthis._loop = !!cfg.loop;\n\t\tthis._target = target;\n\t\tthis._prop = prop;\n\t\tthis._from = from;\n\t\tthis._to = to;\n\t\tthis._promises = undefined;\n\t}\n\tactive() {\n\t\treturn this._active;\n\t}\n\tupdate(cfg, to, date) {\n\t\tconst me = this;\n\t\tif (me._active) {\n\t\t\tconst currentValue = me._target[me._prop];\n\t\t\tconst elapsed = date - me._start;\n\t\t\tconst remain = me._duration - elapsed;\n\t\t\tme._start = date;\n\t\t\tme._duration = Math.floor(Math.max(remain, cfg.duration));\n\t\t\tme._loop = !!cfg.loop;\n\t\t\tme._to = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.to, to, currentValue, cfg.from]);\n\t\t\tme._from = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.from, currentValue, to]);\n\t\t}\n\t}\n\tcancel() {\n\t\tconst me = this;\n\t\tif (me._active) {\n\t\t\tme.tick(Date.now());\n\t\t\tme._active = false;\n\t\t\tme._notify(false);\n\t\t}\n\t}\n\ttick(date) {\n\t\tconst me = this;\n\t\tconst elapsed = date - me._start;\n\t\tconst duration = me._duration;\n\t\tconst prop = me._prop;\n\t\tconst from = me._from;\n\t\tconst loop = me._loop;\n\t\tconst to = me._to;\n\t\tlet factor;\n\t\tme._active = from !== to && (loop || (elapsed < duration));\n\t\tif (!me._active) {\n\t\t\tme._target[prop] = to;\n\t\t\tme._notify(true);\n\t\t\treturn;\n\t\t}\n\t\tif (elapsed < 0) {\n\t\t\tme._target[prop] = from;\n\t\t\treturn;\n\t\t}\n\t\tfactor = (elapsed / duration) % 2;\n\t\tfactor = loop && factor > 1 ? 2 - factor : factor;\n\t\tfactor = me._easing(Math.min(1, Math.max(0, factor)));\n\t\tme._target[prop] = me._fn(from, to, factor);\n\t}\n\twait() {\n\t\tconst promises = this._promises || (this._promises = []);\n\t\treturn new Promise((res, rej) => {\n\t\t\tpromises.push({res, rej});\n\t\t});\n\t}\n\t_notify(resolved) {\n\t\tconst method = resolved ? 'res' : 'rej';\n\t\tconst promises = this._promises || [];\n\t\tfor (let i = 0; i < promises.length; i++) {\n\t\t\tpromises[i][method]();\n\t\t}\n\t}\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['borderColor', 'backgroundColor'];\n_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('animation', {\n\tduration: 1000,\n\teasing: 'easeOutQuart',\n\tonProgress: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\tonComplete: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\tcolors: {\n\t\ttype: 'color',\n\t\tproperties: colors\n\t},\n\tnumbers: {\n\t\ttype: 'number',\n\t\tproperties: numbers\n\t},\n\tactive: {\n\t\tduration: 400\n\t},\n\tresize: {\n\t\tduration: 0\n\t},\n\tshow: {\n\t\tcolors: {\n\t\t\ttype: 'color',\n\t\t\tproperties: colors,\n\t\t\tfrom: 'transparent'\n\t\t},\n\t\tvisible: {\n\t\t\ttype: 'boolean',\n\t\t\tduration: 0\n\t\t},\n\t},\n\thide: {\n\t\tcolors: {\n\t\t\ttype: 'color',\n\t\t\tproperties: colors,\n\t\t\tto: 'transparent'\n\t\t},\n\t\tvisible: {\n\t\t\ttype: 'boolean',\n\t\t\teasing: 'easeInExpo'\n\t\t},\n\t}\n});\nfunction copyOptions(target, values) {\n\tconst oldOpts = target.options;\n\tconst newOpts = values.options;\n\tif (!oldOpts || !newOpts) {\n\t\treturn;\n\t}\n\tif (oldOpts.$shared && !newOpts.$shared) {\n\t\ttarget.options = Object.assign({}, oldOpts, newOpts, {$shared: false});\n\t} else {\n\t\tObject.assign(oldOpts, newOpts);\n\t}\n\tdelete values.options;\n}\nfunction extensibleConfig(animations) {\n\tconst result = {};\n\tObject.keys(animations).forEach(key => {\n\t\tconst value = animations[key];\n\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(value)) {\n\t\t\tresult[key] = value;\n\t\t}\n\t});\n\treturn result;\n}\nclass Animations {\n\tconstructor(chart, animations) {\n\t\tthis._chart = chart;\n\t\tthis._properties = new Map();\n\t\tthis.configure(animations);\n\t}\n\tconfigure(animations) {\n\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(animations)) {\n\t\t\treturn;\n\t\t}\n\t\tconst animatedProps = this._properties;\n\t\tconst animDefaults = extensibleConfig(animations);\n\t\tObject.keys(animations).forEach(key => {\n\t\t\tconst cfg = animations[key];\n\t\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(cfg)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(cfg.properties || [key]).forEach((prop) => {\n\t\t\t\tif (!animatedProps.has(prop)) {\n\t\t\t\t\tanimatedProps.set(prop, Object.assign({}, animDefaults, cfg));\n\t\t\t\t} else if (prop === key) {\n\t\t\t\t\tconst {properties, ...inherited} = animatedProps.get(prop);\n\t\t\t\t\tanimatedProps.set(prop, Object.assign({}, inherited, cfg));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t_animateOptions(target, values) {\n\t\tconst newOptions = values.options;\n\t\tconst options = resolveTargetOptions(target, newOptions);\n\t\tif (!options) {\n\t\t\treturn [];\n\t\t}\n\t\tconst animations = this._createAnimations(options, newOptions);\n\t\tif (newOptions.$shared && !options.$shared) {\n\t\t\tawaitAll(target.options.$animations, newOptions).then(() => {\n\t\t\t\ttarget.options = newOptions;\n\t\t\t});\n\t\t}\n\t\treturn animations;\n\t}\n\t_createAnimations(target, values) {\n\t\tconst animatedProps = this._properties;\n\t\tconst animations = [];\n\t\tconst running = target.$animations || (target.$animations = {});\n\t\tconst props = Object.keys(values);\n\t\tconst date = Date.now();\n\t\tlet i;\n\t\tfor (i = props.length - 1; i >= 0; --i) {\n\t\t\tconst prop = props[i];\n\t\t\tif (prop.charAt(0) === '$') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prop === 'options') {\n\t\t\t\tanimations.push(...this._animateOptions(target, values));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst value = values[prop];\n\t\t\tlet animation = running[prop];\n\t\t\tconst cfg = animatedProps.get(prop);\n\t\t\tif (animation) {\n\t\t\t\tif (cfg && animation.active()) {\n\t\t\t\t\tanimation.update(cfg, value, date);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tanimation.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cfg || !cfg.duration) {\n\t\t\t\ttarget[prop] = value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trunning[prop] = animation = new Animation(cfg, target, prop, value);\n\t\t\tanimations.push(animation);\n\t\t}\n\t\treturn animations;\n\t}\n\tupdate(target, values) {\n\t\tif (this._properties.size === 0) {\n\t\t\tcopyOptions(target, values);\n\t\t\tObject.assign(target, values);\n\t\t\treturn;\n\t\t}\n\t\tconst animations = this._createAnimations(target, values);\n\t\tif (animations.length) {\n\t\t\tanimator.add(this._chart, animations);\n\t\t\treturn true;\n\t\t}\n\t}\n}\nfunction awaitAll(animations, properties) {\n\tconst running = [];\n\tconst keys = Object.keys(properties);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst anim = animations[keys[i]];\n\t\tif (anim && anim.active()) {\n\t\t\trunning.push(anim.wait());\n\t\t}\n\t}\n\treturn Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n\tif (!newOptions) {\n\t\treturn;\n\t}\n\tlet options = target.options;\n\tif (!options) {\n\t\ttarget.options = newOptions;\n\t\treturn;\n\t}\n\tif (options.$shared && !newOptions.$shared) {\n\t\ttarget.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n\t}\n\treturn options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n\tconst opts = scale && scale.options || {};\n\tconst reverse = opts.reverse;\n\tconst min = opts.min === undefined ? allowedOverflow : 0;\n\tconst max = opts.max === undefined ? allowedOverflow : 0;\n\treturn {\n\t\tstart: reverse ? max : min,\n\t\tend: reverse ? min : max\n\t};\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n\tif (allowedOverflow === false) {\n\t\treturn false;\n\t}\n\tconst x = scaleClip(xScale, allowedOverflow);\n\tconst y = scaleClip(yScale, allowedOverflow);\n\treturn {\n\t\ttop: y.end,\n\t\tright: x.end,\n\t\tbottom: y.start,\n\t\tleft: x.start\n\t};\n}\nfunction toClip(value) {\n\tlet t, r, b, l;\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(value)) {\n\t\tt = value.top;\n\t\tr = value.right;\n\t\tb = value.bottom;\n\t\tl = value.left;\n\t} else {\n\t\tt = r = b = l = value;\n\t}\n\treturn {\n\t\ttop: t,\n\t\tright: r,\n\t\tbottom: b,\n\t\tleft: l\n\t};\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n\tconst keys = [];\n\tconst metasets = chart._getSortedDatasetMetas(filterVisible);\n\tlet i, ilen;\n\tfor (i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\tkeys.push(metasets[i].index);\n\t}\n\treturn keys;\n}\nfunction applyStack(stack, value, dsIndex, allOther) {\n\tconst keys = stack.keys;\n\tlet i, ilen, datasetIndex, otherValue;\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tdatasetIndex = +keys[i];\n\t\tif (datasetIndex === dsIndex) {\n\t\t\tif (allOther) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\totherValue = stack.values[datasetIndex];\n\t\tif (!isNaN(otherValue) && (value === 0 || Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(value) === Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(otherValue))) {\n\t\t\tvalue += otherValue;\n\t\t}\n\t}\n\treturn value;\n}\nfunction convertObjectDataToArray(data) {\n\tconst keys = Object.keys(data);\n\tconst adata = new Array(keys.length);\n\tlet i, ilen, key;\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tkey = keys[i];\n\t\tadata[i] = {\n\t\t\tx: key,\n\t\t\ty: data[key]\n\t\t};\n\t}\n\treturn adata;\n}\nfunction isStacked(scale, meta) {\n\tconst stacked = scale && scale.options.stacked;\n\treturn stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n\treturn indexScale.id + '.' + valueScale.id + '.' + meta.stack + '.' + meta.type;\n}\nfunction getUserBounds(scale) {\n\tconst {min, max, minDefined, maxDefined} = scale.getUserBounds();\n\treturn {\n\t\tmin: minDefined ? min : Number.NEGATIVE_INFINITY,\n\t\tmax: maxDefined ? max : Number.POSITIVE_INFINITY\n\t};\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n\tconst subStack = stacks[stackKey] || (stacks[stackKey] = {});\n\treturn subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction updateStacks(controller, parsed) {\n\tconst {chart, _cachedMeta: meta} = controller;\n\tconst stacks = chart._stacks || (chart._stacks = {});\n\tconst {iScale, vScale, index: datasetIndex} = meta;\n\tconst iAxis = iScale.axis;\n\tconst vAxis = vScale.axis;\n\tconst key = getStackKey(iScale, vScale, meta);\n\tconst ilen = parsed.length;\n\tlet stack;\n\tfor (let i = 0; i < ilen; ++i) {\n\t\tconst item = parsed[i];\n\t\tconst {[iAxis]: index, [vAxis]: value} = item;\n\t\tconst itemStacks = item._stacks || (item._stacks = {});\n\t\tstack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n\t\tstack[datasetIndex] = value;\n\t}\n}\nfunction getFirstScaleId(chart, axis) {\n\tconst scales = chart.scales;\n\treturn Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction optionKeys(optionNames) {\n\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(optionNames) ? optionNames : Object.keys(optionNames);\n}\nfunction optionKey(key, active) {\n\treturn active ? 'hover' + Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])(key) : key;\n}\nfunction isDirectUpdateMode(mode) {\n\treturn mode === 'reset' || mode === 'none';\n}\nclass DatasetController {\n\tconstructor(chart, datasetIndex) {\n\t\tthis.chart = chart;\n\t\tthis._ctx = chart.ctx;\n\t\tthis.index = datasetIndex;\n\t\tthis._cachedAnimations = {};\n\t\tthis._cachedDataOpts = {};\n\t\tthis._cachedMeta = this.getMeta();\n\t\tthis._type = this._cachedMeta.type;\n\t\tthis._config = undefined;\n\t\tthis._parsing = false;\n\t\tthis._data = undefined;\n\t\tthis._objectData = undefined;\n\t\tthis._sharedOptions = undefined;\n\t\tthis._drawStart = undefined;\n\t\tthis._drawCount = undefined;\n\t\tthis.enableOptionSharing = false;\n\t\tthis.initialize();\n\t}\n\tinitialize() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tme.configure();\n\t\tme.linkScales();\n\t\tmeta._stacked = isStacked(meta.vScale, meta);\n\t\tme.addElements();\n\t}\n\tupdateIndex(datasetIndex) {\n\t\tthis.index = datasetIndex;\n\t}\n\tlinkScales() {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst meta = me._cachedMeta;\n\t\tconst dataset = me.getDataset();\n\t\tconst chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\t\tconst xid = meta.xAxisID = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n\t\tconst yid = meta.yAxisID = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n\t\tconst rid = meta.rAxisID = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n\t\tconst indexAxis = meta.indexAxis;\n\t\tconst iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n\t\tconst vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n\t\tmeta.xScale = me.getScaleForId(xid);\n\t\tmeta.yScale = me.getScaleForId(yid);\n\t\tmeta.rScale = me.getScaleForId(rid);\n\t\tmeta.iScale = me.getScaleForId(iid);\n\t\tmeta.vScale = me.getScaleForId(vid);\n\t}\n\tgetDataset() {\n\t\treturn this.chart.data.datasets[this.index];\n\t}\n\tgetMeta() {\n\t\treturn this.chart.getDatasetMeta(this.index);\n\t}\n\tgetScaleForId(scaleID) {\n\t\treturn this.chart.scales[scaleID];\n\t}\n\t_getOtherScale(scale) {\n\t\tconst meta = this._cachedMeta;\n\t\treturn scale === meta.iScale\n\t\t\t? meta.vScale\n\t\t\t: meta.iScale;\n\t}\n\treset() {\n\t\tthis._update('reset');\n\t}\n\t_destroy() {\n\t\tif (this._data) {\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"u\"])(this._data, this);\n\t\t}\n\t}\n\t_dataCheck() {\n\t\tconst me = this;\n\t\tconst dataset = me.getDataset();\n\t\tconst data = dataset.data || (dataset.data = []);\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(data)) {\n\t\t\tme._data = convertObjectDataToArray(data);\n\t\t} else if (me._data !== data) {\n\t\t\tif (me._data) {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"u\"])(me._data, me);\n\t\t\t}\n\t\t\tif (data && Object.isExtensible(data)) {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"l\"])(data, me);\n\t\t\t}\n\t\t\tme._data = data;\n\t\t}\n\t}\n\taddElements() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tme._dataCheck();\n\t\tconst data = me._data;\n\t\tconst metaData = meta.data = new Array(data.length);\n\t\tfor (let i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\tmetaData[i] = new me.dataElementType();\n\t\t}\n\t\tif (me.datasetElementType) {\n\t\t\tmeta.dataset = new me.datasetElementType();\n\t\t}\n\t}\n\tbuildOrUpdateElements() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst dataset = me.getDataset();\n\t\tlet stackChanged = false;\n\t\tme._dataCheck();\n\t\tmeta._stacked = isStacked(meta.vScale, meta);\n\t\tif (meta.stack !== dataset.stack) {\n\t\t\tstackChanged = true;\n\t\t\tmeta._parsed.forEach((parsed) => {\n\t\t\t\tdelete parsed._stacks[meta.vScale.id][meta.index];\n\t\t\t});\n\t\t\tmeta.stack = dataset.stack;\n\t\t}\n\t\tme._resyncElements();\n\t\tif (stackChanged) {\n\t\t\tupdateStacks(me, meta._parsed);\n\t\t}\n\t}\n\tconfigure() {\n\t\tconst me = this;\n\t\tme._config = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({}, [\n\t\t\tme.chart.options[me._type].datasets,\n\t\t\tme.getDataset(),\n\t\t], {\n\t\t\tmerger(key, target, source) {\n\t\t\t\tif (key !== 'data') {\n\t\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(key, target, source);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tme._parsing = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([me._config.parsing, me.chart.options.parsing, true]);\n\t}\n\tparse(start, count) {\n\t\tconst me = this;\n\t\tconst {_cachedMeta: meta, _data: data} = me;\n\t\tconst {iScale, vScale, _stacked} = meta;\n\t\tconst iAxis = iScale.axis;\n\t\tlet sorted = true;\n\t\tlet i, parsed, cur, prev;\n\t\tif (start > 0) {\n\t\t\tsorted = meta._sorted;\n\t\t\tprev = meta._parsed[start - 1];\n\t\t}\n\t\tif (me._parsing === false) {\n\t\t\tmeta._parsed = data;\n\t\t\tmeta._sorted = true;\n\t\t} else {\n\t\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(data[start])) {\n\t\t\t\tparsed = me.parseArrayData(meta, data, start, count);\n\t\t\t} else if (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(data[start])) {\n\t\t\t\tparsed = me.parseObjectData(meta, data, start, count);\n\t\t\t} else {\n\t\t\t\tparsed = me.parsePrimitiveData(meta, data, start, count);\n\t\t\t}\n\t\t\tconst isNotInOrderComparedToPrev = () => isNaN(cur[iAxis]) || (prev && cur[iAxis] < prev[iAxis]);\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tmeta._parsed[i + start] = cur = parsed[i];\n\t\t\t\tif (sorted) {\n\t\t\t\t\tif (isNotInOrderComparedToPrev()) {\n\t\t\t\t\t\tsorted = false;\n\t\t\t\t\t}\n\t\t\t\t\tprev = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmeta._sorted = sorted;\n\t\t}\n\t\tif (_stacked) {\n\t\t\tupdateStacks(me, parsed);\n\t\t}\n\t\tiScale.invalidateCaches();\n\t\tvScale.invalidateCaches();\n\t}\n\tparsePrimitiveData(meta, data, start, count) {\n\t\tconst {iScale, vScale} = meta;\n\t\tconst iAxis = iScale.axis;\n\t\tconst vAxis = vScale.axis;\n\t\tconst labels = iScale.getLabels();\n\t\tconst singleScale = iScale === vScale;\n\t\tconst parsed = new Array(count);\n\t\tlet i, ilen, index;\n\t\tfor (i = 0, ilen = count; i < ilen; ++i) {\n\t\t\tindex = i + start;\n\t\t\tparsed[i] = {\n\t\t\t\t[iAxis]: singleScale || iScale.parse(labels[index], index),\n\t\t\t\t[vAxis]: vScale.parse(data[index], index)\n\t\t\t};\n\t\t}\n\t\treturn parsed;\n\t}\n\tparseArrayData(meta, data, start, count) {\n\t\tconst {xScale, yScale} = meta;\n\t\tconst parsed = new Array(count);\n\t\tlet i, ilen, index, item;\n\t\tfor (i = 0, ilen = count; i < ilen; ++i) {\n\t\t\tindex = i + start;\n\t\t\titem = data[index];\n\t\t\tparsed[i] = {\n\t\t\t\tx: xScale.parse(item[0], index),\n\t\t\t\ty: yScale.parse(item[1], index)\n\t\t\t};\n\t\t}\n\t\treturn parsed;\n\t}\n\tparseObjectData(meta, data, start, count) {\n\t\tconst {xScale, yScale} = meta;\n\t\tconst {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n\t\tconst parsed = new Array(count);\n\t\tlet i, ilen, index, item;\n\t\tfor (i = 0, ilen = count; i < ilen; ++i) {\n\t\t\tindex = i + start;\n\t\t\titem = data[index];\n\t\t\tparsed[i] = {\n\t\t\t\tx: xScale.parse(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(item, xAxisKey), index),\n\t\t\t\ty: yScale.parse(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(item, yAxisKey), index)\n\t\t\t};\n\t\t}\n\t\treturn parsed;\n\t}\n\tgetParsed(index) {\n\t\treturn this._cachedMeta._parsed[index];\n\t}\n\tapplyStack(scale, parsed) {\n\t\tconst chart = this.chart;\n\t\tconst meta = this._cachedMeta;\n\t\tconst value = parsed[scale.axis];\n\t\tconst stack = {\n\t\t\tkeys: getSortedDatasetIndices(chart, true),\n\t\t\tvalues: parsed._stacks[scale.axis]\n\t\t};\n\t\treturn applyStack(stack, value, meta.index);\n\t}\n\tupdateRangeFromParsed(range, scale, parsed, stack) {\n\t\tlet value = parsed[scale.axis];\n\t\tconst values = stack && parsed._stacks[scale.axis];\n\t\tif (stack && values) {\n\t\t\tstack.values = values;\n\t\t\trange.min = Math.min(range.min, value);\n\t\t\trange.max = Math.max(range.max, value);\n\t\t\tvalue = applyStack(stack, value, this._cachedMeta.index, true);\n\t\t}\n\t\trange.min = Math.min(range.min, value);\n\t\trange.max = Math.max(range.max, value);\n\t}\n\tgetMinMax(scale, canStack) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst _parsed = meta._parsed;\n\t\tconst sorted = meta._sorted && scale === meta.iScale;\n\t\tconst ilen = _parsed.length;\n\t\tconst otherScale = me._getOtherScale(scale);\n\t\tconst stack = canStack && meta._stacked && {keys: getSortedDatasetIndices(me.chart, true), values: null};\n\t\tconst range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\t\tconst {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n\t\tlet i, value, parsed, otherValue;\n\t\tfunction _skip() {\n\t\t\tparsed = _parsed[i];\n\t\t\tvalue = parsed[scale.axis];\n\t\t\totherValue = parsed[otherScale.axis];\n\t\t\treturn (isNaN(value) || isNaN(otherValue) || otherMin > otherValue || otherMax < otherValue);\n\t\t}\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tif (_skip()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tme.updateRangeFromParsed(range, scale, parsed, stack);\n\t\t\tif (sorted) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sorted) {\n\t\t\tfor (i = ilen - 1; i >= 0; --i) {\n\t\t\t\tif (_skip()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tme.updateRangeFromParsed(range, scale, parsed, stack);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn range;\n\t}\n\tgetAllParsedValues(scale) {\n\t\tconst parsed = this._cachedMeta._parsed;\n\t\tconst values = [];\n\t\tlet i, ilen, value;\n\t\tfor (i = 0, ilen = parsed.length; i < ilen; ++i) {\n\t\t\tvalue = parsed[i][scale.axis];\n\t\t\tif (!isNaN(value)) {\n\t\t\t\tvalues.push(value);\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\tgetMaxOverflow() {\n\t\treturn false;\n\t}\n\tgetLabelAndValue(index) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst iScale = meta.iScale;\n\t\tconst vScale = meta.vScale;\n\t\tconst parsed = me.getParsed(index);\n\t\treturn {\n\t\t\tlabel: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n\t\t\tvalue: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n\t\t};\n\t}\n\t_update(mode) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tme.configure();\n\t\tme._cachedAnimations = {};\n\t\tme._cachedDataOpts = {};\n\t\tme.update(mode || 'default');\n\t\tmeta._clip = toClip(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(me._config.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));\n\t}\n\tupdate(mode) {}\n\tdraw() {\n\t\tconst me = this;\n\t\tconst ctx = me._ctx;\n\t\tconst chart = me.chart;\n\t\tconst meta = me._cachedMeta;\n\t\tconst elements = meta.data || [];\n\t\tconst area = chart.chartArea;\n\t\tconst active = [];\n\t\tconst start = me._drawStart || 0;\n\t\tconst count = me._drawCount || (elements.length - start);\n\t\tlet i;\n\t\tif (meta.dataset) {\n\t\t\tmeta.dataset.draw(ctx, area, start, count);\n\t\t}\n\t\tfor (i = start; i < start + count; ++i) {\n\t\t\tconst element = elements[i];\n\t\t\tif (element.active) {\n\t\t\t\tactive.push(element);\n\t\t\t} else {\n\t\t\t\telement.draw(ctx, area);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < active.length; ++i) {\n\t\t\tactive[i].draw(ctx, area);\n\t\t}\n\t}\n\t_addAutomaticHoverColors(index, options) {\n\t\tconst me = this;\n\t\tconst normalOptions = me.getStyle(index);\n\t\tconst missingColors = Object.keys(normalOptions).filter(key => key.indexOf('Color') !== -1 && !(key in options));\n\t\tlet i = missingColors.length - 1;\n\t\tlet color;\n\t\tfor (; i >= 0; i--) {\n\t\t\tcolor = missingColors[i];\n\t\t\toptions[color] = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(normalOptions[color]);\n\t\t}\n\t}\n\tgetStyle(index, active) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst dataset = meta.dataset;\n\t\tif (!me._config) {\n\t\t\tme.configure();\n\t\t}\n\t\tconst options = dataset && index === undefined\n\t\t\t? me.resolveDatasetElementOptions(active)\n\t\t\t: me.resolveDataElementOptions(index || 0, active && 'active');\n\t\tif (active) {\n\t\t\tme._addAutomaticHoverColors(index, options);\n\t\t}\n\t\treturn options;\n\t}\n\t_getContext(index, active) {\n\t\treturn {\n\t\t\tchart: this.chart,\n\t\t\tdataPoint: this.getParsed(index),\n\t\t\tdataIndex: index,\n\t\t\tdataset: this.getDataset(),\n\t\t\tdatasetIndex: this.index,\n\t\t\tactive\n\t\t};\n\t}\n\tresolveDatasetElementOptions(active) {\n\t\treturn this._resolveOptions(this.datasetElementOptions, {\n\t\t\tactive,\n\t\t\ttype: this.datasetElementType.id\n\t\t});\n\t}\n\tresolveDataElementOptions(index, mode) {\n\t\tmode = mode || 'default';\n\t\tconst me = this;\n\t\tconst active = mode === 'active';\n\t\tconst cached = me._cachedDataOpts;\n\t\tconst sharing = me.enableOptionSharing;\n\t\tif (cached[mode]) {\n\t\t\treturn cached[mode];\n\t\t}\n\t\tconst info = {cacheable: !active};\n\t\tconst values = me._resolveOptions(me.dataElementOptions, {\n\t\t\tindex,\n\t\t\tactive,\n\t\t\tinfo,\n\t\t\ttype: me.dataElementType.id\n\t\t});\n\t\tif (info.cacheable) {\n\t\t\tvalues.$shared = sharing;\n\t\t\tcached[mode] = sharing ? Object.freeze(values) : values;\n\t\t}\n\t\treturn values;\n\t}\n\t_resolveOptions(optionNames, args) {\n\t\tconst me = this;\n\t\tconst {index, active, type, info} = args;\n\t\tconst datasetOpts = me._config;\n\t\tconst options = me.chart.options.elements[type] || {};\n\t\tconst values = {};\n\t\tconst context = me._getContext(index, active);\n\t\tconst keys = optionKeys(optionNames);\n\t\tfor (let i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tconst key = keys[i];\n\t\t\tconst readKey = optionKey(key, active);\n\t\t\tconst value = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([\n\t\t\t\tdatasetOpts[optionNames[readKey]],\n\t\t\t\tdatasetOpts[readKey],\n\t\t\t\toptions[readKey]\n\t\t\t], context, index, info);\n\t\t\tif (value !== undefined) {\n\t\t\t\tvalues[key] = value;\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\t_resolveAnimations(index, mode, active) {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst cached = me._cachedAnimations;\n\t\tmode = mode || 'default';\n\t\tif (cached[mode]) {\n\t\t\treturn cached[mode];\n\t\t}\n\t\tconst info = {cacheable: true};\n\t\tconst context = me._getContext(index, active);\n\t\tconst chartAnim = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([chart.options.animation], context, index, info);\n\t\tconst datasetAnim = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([me._config.animation], context, index, info);\n\t\tlet config = chartAnim && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])({}, [datasetAnim, chartAnim]);\n\t\tif (config[mode]) {\n\t\t\tconfig = Object.assign({}, config, config[mode]);\n\t\t}\n\t\tconst animations = new Animations(chart, config);\n\t\tif (info.cacheable) {\n\t\t\tcached[mode] = animations && Object.freeze(animations);\n\t\t}\n\t\treturn animations;\n\t}\n\tgetSharedOptions(options) {\n\t\tif (!options.$shared) {\n\t\t\treturn;\n\t\t}\n\t\treturn this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n\t}\n\tincludeOptions(mode, sharedOptions) {\n\t\treturn !sharedOptions || isDirectUpdateMode(mode);\n\t}\n\tupdateElement(element, index, properties, mode) {\n\t\tif (isDirectUpdateMode(mode)) {\n\t\t\tObject.assign(element, properties);\n\t\t} else {\n\t\t\tthis._resolveAnimations(index, mode).update(element, properties);\n\t\t}\n\t}\n\tupdateSharedOptions(sharedOptions, mode, newOptions) {\n\t\tif (sharedOptions) {\n\t\t\tthis._resolveAnimations(undefined, mode).update({options: sharedOptions}, {options: newOptions});\n\t\t}\n\t}\n\t_setStyle(element, index, mode, active) {\n\t\telement.active = active;\n\t\tconst options = this.getStyle(index, active);\n\t\tthis._resolveAnimations(index, mode, active).update(element, {options: this.getSharedOptions(options) || options});\n\t}\n\tremoveHoverStyle(element, datasetIndex, index) {\n\t\tthis._setStyle(element, index, 'active', false);\n\t}\n\tsetHoverStyle(element, datasetIndex, index) {\n\t\tthis._setStyle(element, index, 'active', true);\n\t}\n\t_removeDatasetHoverStyle() {\n\t\tconst element = this._cachedMeta.dataset;\n\t\tif (element) {\n\t\t\tthis._setStyle(element, undefined, 'active', false);\n\t\t}\n\t}\n\t_setDatasetHoverStyle() {\n\t\tconst element = this._cachedMeta.dataset;\n\t\tif (element) {\n\t\t\tthis._setStyle(element, undefined, 'active', true);\n\t\t}\n\t}\n\t_resyncElements() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst numMeta = meta.data.length;\n\t\tconst numData = me._data.length;\n\t\tif (numData > numMeta) {\n\t\t\tme._insertElements(numMeta, numData - numMeta);\n\t\t} else if (numData < numMeta) {\n\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\tmeta._parsed.splice(numData, numMeta - numData);\n\t\t}\n\t\tme.parse(0, Math.min(numData, numMeta));\n\t}\n\t_insertElements(start, count) {\n\t\tconst me = this;\n\t\tconst elements = new Array(count);\n\t\tconst meta = me._cachedMeta;\n\t\tconst data = meta.data;\n\t\tlet i;\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\telements[i] = new me.dataElementType();\n\t\t}\n\t\tdata.splice(start, 0, ...elements);\n\t\tif (me._parsing) {\n\t\t\tmeta._parsed.splice(start, 0, ...new Array(count));\n\t\t}\n\t\tme.parse(start, count);\n\t\tme.updateElements(data, start, count, 'reset');\n\t}\n\tupdateElements(element, start, count, mode) {}\n\t_removeElements(start, count) {\n\t\tconst me = this;\n\t\tif (me._parsing) {\n\t\t\tme._cachedMeta._parsed.splice(start, count);\n\t\t}\n\t\tme._cachedMeta.data.splice(start, count);\n\t}\n\t_onDataPush() {\n\t\tconst count = arguments.length;\n\t\tthis._insertElements(this.getDataset().data.length - count, count);\n\t}\n\t_onDataPop() {\n\t\tthis._removeElements(this._cachedMeta.data.length - 1, 1);\n\t}\n\t_onDataShift() {\n\t\tthis._removeElements(0, 1);\n\t}\n\t_onDataSplice(start, count) {\n\t\tthis._removeElements(start, count);\n\t\tthis._insertElements(start, arguments.length - 2);\n\t}\n\t_onDataUnshift() {\n\t\tthis._insertElements(0, arguments.length);\n\t}\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\nDatasetController.prototype.datasetElementOptions = [\n\t'backgroundColor',\n\t'borderCapStyle',\n\t'borderColor',\n\t'borderDash',\n\t'borderDashOffset',\n\t'borderJoinStyle',\n\t'borderWidth'\n];\nDatasetController.prototype.dataElementOptions = [\n\t'backgroundColor',\n\t'borderColor',\n\t'borderWidth',\n\t'pointStyle'\n];\n\nfunction computeMinSampleSize(scale, pixels) {\n\tlet min = scale._length;\n\tlet prev, curr, i, ilen;\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n\t}\n\tfor (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;\n\t\tprev = curr;\n\t}\n\treturn min;\n}\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tconst thickness = options.barThickness;\n\tconst count = ruler.stackCount;\n\tlet size, ratio;\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\treturn {\n\t\tchunk: size / count,\n\t\tratio,\n\t\tstart: ruler.pixels[index] - (size / 2)\n\t};\n}\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tconst pixels = ruler.pixels;\n\tconst curr = pixels[index];\n\tlet prev = index > 0 ? pixels[index - 1] : null;\n\tlet next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tconst percent = options.categoryPercentage;\n\tif (prev === null) {\n\t\tprev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n\t}\n\tif (next === null) {\n\t\tnext = curr + curr - prev;\n\t}\n\tconst start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n\tconst size = Math.abs(next - prev) / 2 * percent;\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart\n\t};\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n\tconst startValue = vScale.parse(entry[0], i);\n\tconst endValue = vScale.parse(entry[1], i);\n\tconst min = Math.min(startValue, endValue);\n\tconst max = Math.max(startValue, endValue);\n\tlet barStart = min;\n\tlet barEnd = max;\n\tif (Math.abs(min) > Math.abs(max)) {\n\t\tbarStart = max;\n\t\tbarEnd = min;\n\t}\n\titem[vScale.axis] = barEnd;\n\titem._custom = {\n\t\tbarStart,\n\t\tbarEnd,\n\t\tstart: startValue,\n\t\tend: endValue,\n\t\tmin,\n\t\tmax\n\t};\n}\nfunction parseValue(entry, item, vScale, i) {\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(entry)) {\n\t\tparseFloatBar(entry, item, vScale, i);\n\t} else {\n\t\titem[vScale.axis] = vScale.parse(entry, i);\n\t}\n\treturn item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n\tconst iScale = meta.iScale;\n\tconst vScale = meta.vScale;\n\tconst labels = iScale.getLabels();\n\tconst singleScale = iScale === vScale;\n\tconst parsed = [];\n\tlet i, ilen, item, entry;\n\tfor (i = start, ilen = start + count; i < ilen; ++i) {\n\t\tentry = data[i];\n\t\titem = {};\n\t\titem[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n\t\tparsed.push(parseValue(entry, item, vScale, i));\n\t}\n\treturn parsed;\n}\nfunction isFloatBar(custom) {\n\treturn custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nclass BarController extends DatasetController {\n\tparsePrimitiveData(meta, data, start, count) {\n\t\treturn parseArrayOrPrimitive(meta, data, start, count);\n\t}\n\tparseArrayData(meta, data, start, count) {\n\t\treturn parseArrayOrPrimitive(meta, data, start, count);\n\t}\n\tparseObjectData(meta, data, start, count) {\n\t\tconst {iScale, vScale} = meta;\n\t\tconst {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n\t\tconst iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n\t\tconst vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n\t\tconst parsed = [];\n\t\tlet i, ilen, item, obj;\n\t\tfor (i = start, ilen = start + count; i < ilen; ++i) {\n\t\t\tobj = data[i];\n\t\t\titem = {};\n\t\t\titem[iScale.axis] = iScale.parse(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(obj, iAxisKey), i);\n\t\t\tparsed.push(parseValue(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(obj, vAxisKey), item, vScale, i));\n\t\t}\n\t\treturn parsed;\n\t}\n\tupdateRangeFromParsed(range, scale, parsed, stack) {\n\t\tsuper.updateRangeFromParsed(range, scale, parsed, stack);\n\t\tconst custom = parsed._custom;\n\t\tif (custom && scale === this._cachedMeta.vScale) {\n\t\t\trange.min = Math.min(range.min, custom.min);\n\t\t\trange.max = Math.max(range.max, custom.max);\n\t\t}\n\t}\n\tgetLabelAndValue(index) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst {iScale, vScale} = meta;\n\t\tconst parsed = me.getParsed(index);\n\t\tconst custom = parsed._custom;\n\t\tconst value = isFloatBar(custom)\n\t\t\t? '[' + custom.start + ', ' + custom.end + ']'\n\t\t\t: '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\t\treturn {\n\t\t\tlabel: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n\t\t\tvalue\n\t\t};\n\t}\n\tinitialize() {\n\t\tconst me = this;\n\t\tme.enableOptionSharing = true;\n\t\tsuper.initialize();\n\t\tconst meta = me._cachedMeta;\n\t\tmeta.stack = me.getDataset().stack;\n\t}\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tme.updateElements(meta.data, 0, meta.data.length, mode);\n\t}\n\tupdateElements(rectangles, start, count, mode) {\n\t\tconst me = this;\n\t\tconst reset = mode === 'reset';\n\t\tconst vscale = me._cachedMeta.vScale;\n\t\tconst base = vscale.getBasePixel();\n\t\tconst horizontal = vscale.isHorizontal();\n\t\tconst ruler = me._getRuler();\n\t\tconst firstOpts = me.resolveDataElementOptions(start, mode);\n\t\tconst sharedOptions = me.getSharedOptions(firstOpts);\n\t\tconst includeOptions = me.includeOptions(mode, sharedOptions);\n\t\tme.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t\tfor (let i = start; i < start + count; i++) {\n\t\t\tconst options = sharedOptions || me.resolveDataElementOptions(i, mode);\n\t\t\tconst vpixels = me._calculateBarValuePixels(i, options);\n\t\t\tconst ipixels = me._calculateBarIndexPixels(i, ruler, options);\n\t\t\tconst properties = {\n\t\t\t\thorizontal,\n\t\t\t\tbase: reset ? base : vpixels.base,\n\t\t\t\tx: horizontal ? reset ? base : vpixels.head : ipixels.center,\n\t\t\t\ty: horizontal ? ipixels.center : reset ? base : vpixels.head,\n\t\t\t\theight: horizontal ? ipixels.size : undefined,\n\t\t\t\twidth: horizontal ? undefined : ipixels.size\n\t\t\t};\n\t\t\tif (includeOptions) {\n\t\t\t\tproperties.options = options;\n\t\t\t}\n\t\t\tme.updateElement(rectangles[i], i, properties, mode);\n\t\t}\n\t}\n\t_getStacks(last) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst iScale = meta.iScale;\n\t\tconst metasets = iScale.getMatchingVisibleMetas(me._type);\n\t\tconst stacked = iScale.options.stacked;\n\t\tconst ilen = metasets.length;\n\t\tconst stacks = [];\n\t\tlet i, item;\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\titem = metasets[i];\n\t\t\tif (stacked === false || stacks.indexOf(item.stack) === -1 ||\n\t\t\t\t(stacked === undefined && item.stack === undefined)) {\n\t\t\t\tstacks.push(item.stack);\n\t\t\t}\n\t\t\tif (item.index === last) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!stacks.length) {\n\t\t\tstacks.push(undefined);\n\t\t}\n\t\treturn stacks;\n\t}\n\t_getStackCount() {\n\t\treturn this._getStacks().length;\n\t}\n\t_getStackIndex(datasetIndex, name) {\n\t\tconst stacks = this._getStacks(datasetIndex);\n\t\tconst index = (name !== undefined)\n\t\t\t? stacks.indexOf(name)\n\t\t\t: -1;\n\t\treturn (index === -1)\n\t\t\t? stacks.length - 1\n\t\t\t: index;\n\t}\n\t_getRuler() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst iScale = meta.iScale;\n\t\tconst pixels = [];\n\t\tlet i, ilen;\n\t\tfor (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n\t\t\tpixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));\n\t\t}\n\t\tconst min = computeMinSampleSize(iScale, pixels);\n\t\treturn {\n\t\t\tmin,\n\t\t\tpixels,\n\t\t\tstart: iScale._startPixel,\n\t\t\tend: iScale._endPixel,\n\t\t\tstackCount: me._getStackCount(),\n\t\t\tscale: iScale\n\t\t};\n\t}\n\t_calculateBarValuePixels(index, options) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst vScale = meta.vScale;\n\t\tconst minBarLength = options.minBarLength;\n\t\tconst parsed = me.getParsed(index);\n\t\tconst custom = parsed._custom;\n\t\tlet value = parsed[vScale.axis];\n\t\tlet start = 0;\n\t\tlet length = meta._stacked ? me.applyStack(vScale, parsed) : value;\n\t\tlet head, size;\n\t\tif (length !== value) {\n\t\t\tstart = length - value;\n\t\t\tlength = value;\n\t\t}\n\t\tif (isFloatBar(custom)) {\n\t\t\tvalue = custom.barStart;\n\t\t\tlength = custom.barEnd - custom.barStart;\n\t\t\tif (value !== 0 && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(value) !== Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(custom.barEnd)) {\n\t\t\t\tstart = 0;\n\t\t\t}\n\t\t\tstart += value;\n\t\t}\n\t\tlet base = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(vScale.getPixelForValue(start),\n\t\t\tvScale._startPixel - 10,\n\t\t\tvScale._endPixel + 10);\n\t\thead = vScale.getPixelForValue(start + length);\n\t\tsize = head - base;\n\t\tif (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n\t\t\tsize = size < 0 ? -minBarLength : minBarLength;\n\t\t\tif (value === 0) {\n\t\t\t\tbase -= size / 2;\n\t\t\t}\n\t\t\thead = base + size;\n\t\t}\n\t\treturn {\n\t\t\tsize,\n\t\t\tbase,\n\t\t\thead,\n\t\t\tcenter: head + size / 2\n\t\t};\n\t}\n\t_calculateBarIndexPixels(index, ruler, options) {\n\t\tconst me = this;\n\t\tconst range = options.barThickness === 'flex'\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\t\tconst stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack);\n\t\tconst center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\tconst size = Math.min(\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.maxBarThickness, Infinity),\n\t\t\trange.chunk * range.ratio);\n\t\treturn {\n\t\t\tbase: center - size / 2,\n\t\t\thead: center + size / 2,\n\t\t\tcenter,\n\t\t\tsize\n\t\t};\n\t}\n\tdraw() {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst meta = me._cachedMeta;\n\t\tconst vScale = meta.vScale;\n\t\tconst rects = meta.data;\n\t\tconst ilen = rects.length;\n\t\tlet i = 0;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(chart.ctx, chart.chartArea);\n\t\tfor (; i < ilen; ++i) {\n\t\t\tif (!isNaN(me.getParsed(i)[vScale.axis])) {\n\t\t\t\trects[i].draw(me._ctx);\n\t\t\t}\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(chart.ctx);\n\t}\n}\nBarController.id = 'bar';\nBarController.defaults = {\n\tdatasetElementType: false,\n\tdataElementType: 'rectangle',\n\tdataElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderColor',\n\t\t'borderSkipped',\n\t\t'borderWidth',\n\t\t'barPercentage',\n\t\t'barThickness',\n\t\t'categoryPercentage',\n\t\t'maxBarThickness',\n\t\t'minBarLength'\n\t],\n\thover: {\n\t\tmode: 'index'\n\t},\n\tdatasets: {\n\t\tcategoryPercentage: 0.8,\n\t\tbarPercentage: 0.9,\n\t\tanimation: {\n\t\t\tnumbers: {\n\t\t\t\ttype: 'number',\n\t\t\t\tproperties: ['x', 'y', 'base', 'width', 'height']\n\t\t\t}\n\t\t}\n\t},\n\tscales: {\n\t\t_index_: {\n\t\t\ttype: 'category',\n\t\t\toffset: true,\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t},\n\t\t_value_: {\n\t\t\ttype: 'linear',\n\t\t\tbeginAtZero: true,\n\t\t}\n\t}\n};\n\nclass BubbleController extends DatasetController {\n\tinitialize() {\n\t\tthis.enableOptionSharing = true;\n\t\tsuper.initialize();\n\t}\n\tparseObjectData(meta, data, start, count) {\n\t\tconst {xScale, yScale} = meta;\n\t\tconst {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n\t\tconst parsed = [];\n\t\tlet i, ilen, item;\n\t\tfor (i = start, ilen = start + count; i < ilen; ++i) {\n\t\t\titem = data[i];\n\t\t\tparsed.push({\n\t\t\t\tx: xScale.parse(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(item, xAxisKey), i),\n\t\t\t\ty: yScale.parse(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(item, yAxisKey), i),\n\t\t\t\t_custom: item && item.r && +item.r\n\t\t\t});\n\t\t}\n\t\treturn parsed;\n\t}\n\tgetMaxOverflow() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tlet i = (meta.data || []).length - 1;\n\t\tlet max = 0;\n\t\tfor (; i >= 0; --i) {\n\t\t\tmax = Math.max(max, me.getStyle(i, true).radius);\n\t\t}\n\t\treturn max > 0 && max;\n\t}\n\tgetLabelAndValue(index) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst {xScale, yScale} = meta;\n\t\tconst parsed = me.getParsed(index);\n\t\tconst x = xScale.getLabelForValue(parsed.x);\n\t\tconst y = yScale.getLabelForValue(parsed.y);\n\t\tconst r = parsed._custom;\n\t\treturn {\n\t\t\tlabel: meta.label,\n\t\t\tvalue: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n\t\t};\n\t}\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tconst points = me._cachedMeta.data;\n\t\tme.updateElements(points, 0, points.length, mode);\n\t}\n\tupdateElements(points, start, count, mode) {\n\t\tconst me = this;\n\t\tconst reset = mode === 'reset';\n\t\tconst {xScale, yScale} = me._cachedMeta;\n\t\tconst firstOpts = me.resolveDataElementOptions(start, mode);\n\t\tconst sharedOptions = me.getSharedOptions(firstOpts);\n\t\tconst includeOptions = me.includeOptions(mode, sharedOptions);\n\t\tfor (let i = start; i < start + count; i++) {\n\t\t\tconst point = points[i];\n\t\t\tconst parsed = !reset && me.getParsed(i);\n\t\t\tconst x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(parsed.x);\n\t\t\tconst y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(parsed.y);\n\t\t\tconst properties = {\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tskip: isNaN(x) || isNaN(y)\n\t\t\t};\n\t\t\tif (includeOptions) {\n\t\t\t\tproperties.options = me.resolveDataElementOptions(i, mode);\n\t\t\t\tif (reset) {\n\t\t\t\t\tproperties.options.radius = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tme.updateElement(point, i, properties, mode);\n\t\t}\n\t\tme.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t}\n\tresolveDataElementOptions(index, mode) {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst dataset = me.getDataset();\n\t\tconst parsed = me.getParsed(index);\n\t\tlet values = super.resolveDataElementOptions(index, mode);\n\t\tconst context = {\n\t\t\tchart,\n\t\t\tdataPoint: parsed,\n\t\t\tdataIndex: index,\n\t\t\tdataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\t\tif (values.$shared) {\n\t\t\tvalues = Object.assign({}, values, {$shared: false});\n\t\t}\n\t\tif (mode !== 'active') {\n\t\t\tvalues.radius = 0;\n\t\t}\n\t\tvalues.radius += Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([\n\t\t\tparsed && parsed._custom,\n\t\t\tme._config.radius,\n\t\t\tchart.options.elements.point.radius\n\t\t], context, index);\n\t\treturn values;\n\t}\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n\tdatasetElementType: false,\n\tdataElementType: 'point',\n\tdataElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderColor',\n\t\t'borderWidth',\n\t\t'hitRadius',\n\t\t'radius',\n\t\t'pointStyle',\n\t\t'rotation'\n\t],\n\tanimation: {\n\t\tnumbers: {\n\t\t\tproperties: ['x', 'y', 'borderWidth', 'radius']\n\t\t}\n\t},\n\tscales: {\n\t\tx: {\n\t\t\ttype: 'linear'\n\t\t},\n\t\ty: {\n\t\t\ttype: 'linear'\n\t\t}\n\t},\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle() {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst PI = Math.PI;\nconst DOUBLE_PI = PI * 2;\nconst HALF_PI = PI / 2;\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n\tlet ratioX = 1;\n\tlet ratioY = 1;\n\tlet offsetX = 0;\n\tlet offsetY = 0;\n\tif (circumference < DOUBLE_PI) {\n\t\tlet startAngle = rotation % DOUBLE_PI;\n\t\tstartAngle += startAngle >= PI ? -DOUBLE_PI : startAngle < -PI ? DOUBLE_PI : 0;\n\t\tconst endAngle = startAngle + circumference;\n\t\tconst startX = Math.cos(startAngle);\n\t\tconst startY = Math.sin(startAngle);\n\t\tconst endX = Math.cos(endAngle);\n\t\tconst endY = Math.sin(endAngle);\n\t\tconst contains0 = (startAngle <= 0 && endAngle >= 0) || endAngle >= DOUBLE_PI;\n\t\tconst contains90 = (startAngle <= HALF_PI && endAngle >= HALF_PI) || endAngle >= DOUBLE_PI + HALF_PI;\n\t\tconst contains180 = startAngle === -PI || endAngle >= PI;\n\t\tconst contains270 = (startAngle <= -HALF_PI && endAngle >= -HALF_PI) || endAngle >= PI + HALF_PI;\n\t\tconst minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);\n\t\tconst minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);\n\t\tconst maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);\n\t\tconst maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);\n\t\tratioX = (maxX - minX) / 2;\n\t\tratioY = (maxY - minY) / 2;\n\t\toffsetX = -(maxX + minX) / 2;\n\t\toffsetY = -(maxY + minY) / 2;\n\t}\n\treturn {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n\tconstructor(chart, datasetIndex) {\n\t\tsuper(chart, datasetIndex);\n\t\tthis.enableOptionSharing = true;\n\t\tthis.innerRadius = undefined;\n\t\tthis.outerRadius = undefined;\n\t\tthis.offsetX = undefined;\n\t\tthis.offsetY = undefined;\n\t}\n\tlinkScales() {}\n\tparse(start, count) {\n\t\tconst data = this.getDataset().data;\n\t\tconst meta = this._cachedMeta;\n\t\tlet i, ilen;\n\t\tfor (i = start, ilen = start + count; i < ilen; ++i) {\n\t\t\tmeta._parsed[i] = +data[i];\n\t\t}\n\t}\n\tgetRingIndex(datasetIndex) {\n\t\tlet ringIndex = 0;\n\t\tfor (let j = 0; j < datasetIndex; ++j) {\n\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t++ringIndex;\n\t\t\t}\n\t\t}\n\t\treturn ringIndex;\n\t}\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst {chartArea, options} = chart;\n\t\tconst meta = me._cachedMeta;\n\t\tconst arcs = meta.data;\n\t\tconst cutout = options.cutoutPercentage / 100 || 0;\n\t\tconst chartWeight = me._getRingWeight(me.index);\n\t\tconst {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(options.rotation, options.circumference, cutout);\n\t\tconst spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs);\n\t\tconst maxWidth = (chartArea.right - chartArea.left - spacing) / ratioX;\n\t\tconst maxHeight = (chartArea.bottom - chartArea.top - spacing) / ratioY;\n\t\tconst outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n\t\tconst innerRadius = Math.max(outerRadius * cutout, 0);\n\t\tconst radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();\n\t\tme.offsetX = offsetX * outerRadius;\n\t\tme.offsetY = offsetY * outerRadius;\n\t\tmeta.total = me.calculateTotal();\n\t\tme.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);\n\t\tme.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);\n\t\tme.updateElements(arcs, 0, arcs.length, mode);\n\t}\n\t_circumference(i, reset) {\n\t\tconst me = this;\n\t\tconst opts = me.chart.options;\n\t\tconst meta = me._cachedMeta;\n\t\treturn reset && opts.animation.animateRotate ? 0 : this.chart.getDataVisibility(i) ? me.calculateCircumference(meta._parsed[i] * opts.circumference / DOUBLE_PI) : 0;\n\t}\n\tupdateElements(arcs, start, count, mode) {\n\t\tconst me = this;\n\t\tconst reset = mode === 'reset';\n\t\tconst chart = me.chart;\n\t\tconst chartArea = chart.chartArea;\n\t\tconst opts = chart.options;\n\t\tconst animationOpts = opts.animation;\n\t\tconst centerX = (chartArea.left + chartArea.right) / 2;\n\t\tconst centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\tconst animateScale = reset && animationOpts.animateScale;\n\t\tconst innerRadius = animateScale ? 0 : me.innerRadius;\n\t\tconst outerRadius = animateScale ? 0 : me.outerRadius;\n\t\tconst firstOpts = me.resolveDataElementOptions(start, mode);\n\t\tconst sharedOptions = me.getSharedOptions(firstOpts);\n\t\tconst includeOptions = me.includeOptions(mode, sharedOptions);\n\t\tlet startAngle = opts.rotation;\n\t\tlet i;\n\t\tfor (i = 0; i < start; ++i) {\n\t\t\tstartAngle += me._circumference(i, reset);\n\t\t}\n\t\tfor (i = start; i < start + count; ++i) {\n\t\t\tconst circumference = me._circumference(i, reset);\n\t\t\tconst arc = arcs[i];\n\t\t\tconst properties = {\n\t\t\t\tx: centerX + me.offsetX,\n\t\t\t\ty: centerY + me.offsetY,\n\t\t\t\tstartAngle,\n\t\t\t\tendAngle: startAngle + circumference,\n\t\t\t\tcircumference,\n\t\t\t\touterRadius,\n\t\t\t\tinnerRadius\n\t\t\t};\n\t\t\tif (includeOptions) {\n\t\t\t\tproperties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\n\t\t\t}\n\t\t\tstartAngle += circumference;\n\t\t\tme.updateElement(arc, i, properties, mode);\n\t\t}\n\t\tme.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t}\n\tcalculateTotal() {\n\t\tconst meta = this._cachedMeta;\n\t\tconst metaData = meta.data;\n\t\tlet total = 0;\n\t\tlet i;\n\t\tfor (i = 0; i < metaData.length; i++) {\n\t\t\tconst value = meta._parsed[i];\n\t\t\tif (!isNaN(value) && this.chart.getDataVisibility(i)) {\n\t\t\t\ttotal += Math.abs(value);\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n\tcalculateCircumference(value) {\n\t\tconst total = this._cachedMeta.total;\n\t\tif (total > 0 && !isNaN(value)) {\n\t\t\treturn DOUBLE_PI * (Math.abs(value) / total);\n\t\t}\n\t\treturn 0;\n\t}\n\tgetLabelAndValue(index) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst chart = me.chart;\n\t\tconst labels = chart.data.labels || [];\n\t\treturn {\n\t\t\tlabel: labels[index] || '',\n\t\t\tvalue: meta._parsed[index],\n\t\t};\n\t}\n\tgetMaxBorderWidth(arcs) {\n\t\tconst me = this;\n\t\tlet max = 0;\n\t\tconst chart = me.chart;\n\t\tlet i, ilen, meta, controller, options;\n\t\tif (!arcs) {\n\t\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tarcs = meta.data;\n\t\t\t\t\tcontroller = meta.controller;\n\t\t\t\t\tif (controller !== me) {\n\t\t\t\t\t\tcontroller.configure();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!arcs) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\toptions = controller.resolveDataElementOptions(i);\n\t\t\tif (options.borderAlign !== 'inner') {\n\t\t\t\tmax = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tgetMaxOffset(arcs) {\n\t\tlet max = 0;\n\t\tfor (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\tconst options = this.resolveDataElementOptions(i);\n\t\t\tmax = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n\t\t}\n\t\treturn max;\n\t}\n\t_getRingWeightOffset(datasetIndex) {\n\t\tlet ringWeightOffset = 0;\n\t\tfor (let i = 0; i < datasetIndex; ++i) {\n\t\t\tif (this.chart.isDatasetVisible(i)) {\n\t\t\t\tringWeightOffset += this._getRingWeight(i);\n\t\t\t}\n\t\t}\n\t\treturn ringWeightOffset;\n\t}\n\t_getRingWeight(datasetIndex) {\n\t\treturn Math.max(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n\t}\n\t_getVisibleDatasetWeightTotal() {\n\t\treturn this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n\t}\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n\tdatasetElementType: false,\n\tdataElementType: 'arc',\n\tdataElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderColor',\n\t\t'borderWidth',\n\t\t'borderAlign',\n\t\t'offset'\n\t],\n\tanimation: {\n\t\tnumbers: {\n\t\t\ttype: 'number',\n\t\t\tproperties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth']\n\t\t},\n\t\tanimateRotate: true,\n\t\tanimateScale: false\n\t},\n\taspectRatio: 1,\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels(chart) {\n\t\t\t\tconst data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map((label, i) => {\n\t\t\t\t\t\tconst meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tconst style = meta.controller.getStyle(i);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\n\t\t\t\t\t\t\tstrokeStyle: style.borderColor,\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\n\t\t\t\t\t\t\thidden: !chart.getDataVisibility(i),\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\t\tonClick(e, legendItem, legend) {\n\t\t\tlegend.chart.toggleDataVisibility(legendItem.index);\n\t\t\tlegend.chart.update();\n\t\t}\n\t},\n\tcutoutPercentage: 50,\n\trotation: -HALF_PI,\n\tcircumference: DOUBLE_PI,\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel(tooltipItem) {\n\t\t\t\tlet dataLabel = tooltipItem.label;\n\t\t\t\tconst value = ': ' + tooltipItem.formattedValue;\n\t\t\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(dataLabel)) {\n\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabel += value;\n\t\t\t\t}\n\t\t\t\treturn dataLabel;\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass LineController extends DatasetController {\n\tinitialize() {\n\t\tthis.enableOptionSharing = true;\n\t\tsuper.initialize();\n\t}\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst {dataset: line, data: points = []} = meta;\n\t\tconst animationsDisabled = me.chart._animationsDisabled;\n\t\tlet {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\t\tme._drawStart = start;\n\t\tme._drawCount = count;\n\t\tif (scaleRangesChanged(meta) && !animationsDisabled) {\n\t\t\tstart = 0;\n\t\t\tcount = points.length;\n\t\t}\n\t\tif (mode !== 'resize') {\n\t\t\tconst properties = {\n\t\t\t\tpoints,\n\t\t\t\toptions: me.resolveDatasetElementOptions()\n\t\t\t};\n\t\t\tme.updateElement(line, undefined, properties, mode);\n\t\t}\n\t\tme.updateElements(points, start, count, mode);\n\t}\n\tupdateElements(points, start, count, mode) {\n\t\tconst me = this;\n\t\tconst reset = mode === 'reset';\n\t\tconst {xScale, yScale, _stacked} = me._cachedMeta;\n\t\tconst firstOpts = me.resolveDataElementOptions(start, mode);\n\t\tconst sharedOptions = me.getSharedOptions(firstOpts);\n\t\tconst includeOptions = me.includeOptions(mode, sharedOptions);\n\t\tconst spanGaps = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(me._config.spanGaps, me.chart.options.spanGaps);\n\t\tconst maxGapLength = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n\t\tlet prevParsed = start > 0 && me.getParsed(start - 1);\n\t\tfor (let i = start; i < start + count; ++i) {\n\t\t\tconst point = points[i];\n\t\t\tconst parsed = me.getParsed(i);\n\t\t\tconst x = xScale.getPixelForValue(parsed.x, i);\n\t\t\tconst y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(_stacked ? me.applyStack(yScale, parsed) : parsed.y, i);\n\t\t\tconst properties = {\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tskip: isNaN(x) || isNaN(y),\n\t\t\t\tstop: i > 0 && (parsed.x - prevParsed.x) > maxGapLength\n\t\t\t};\n\t\t\tif (includeOptions) {\n\t\t\t\tproperties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\n\t\t\t}\n\t\t\tme.updateElement(point, i, properties, mode);\n\t\t\tprevParsed = parsed;\n\t\t}\n\t\tme.updateSharedOptions(sharedOptions, mode, firstOpts);\n\t}\n\tresolveDatasetElementOptions(active) {\n\t\tconst me = this;\n\t\tconst config = me._config;\n\t\tconst options = me.chart.options;\n\t\tconst lineOptions = options.elements.line;\n\t\tconst values = super.resolveDatasetElementOptions(active);\n\t\tconst showLine = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.showLine, options.showLines);\n\t\tvalues.spanGaps = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.spanGaps, options.spanGaps);\n\t\tvalues.tension = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.lineTension, lineOptions.tension);\n\t\tvalues.stepped = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([config.stepped, lineOptions.stepped]);\n\t\tif (!showLine) {\n\t\t\tvalues.borderWidth = 0;\n\t\t}\n\t\treturn values;\n\t}\n\tgetMaxOverflow() {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst border = meta.dataset.options.borderWidth || 0;\n\t\tconst data = meta.data || [];\n\t\tif (!data.length) {\n\t\t\treturn border;\n\t\t}\n\t\tconst firstPoint = data[0].size();\n\t\tconst lastPoint = data[data.length - 1].size();\n\t\treturn Math.max(border, firstPoint, lastPoint) / 2;\n\t}\n\tdraw() {\n\t\tthis._cachedMeta.dataset.updateControlPoints(this.chart.chartArea);\n\t\tsuper.draw();\n\t}\n}\nLineController.id = 'line';\nLineController.defaults = {\n\tdatasetElementType: 'line',\n\tdatasetElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderCapStyle',\n\t\t'borderColor',\n\t\t'borderDash',\n\t\t'borderDashOffset',\n\t\t'borderJoinStyle',\n\t\t'borderWidth',\n\t\t'capBezierPoints',\n\t\t'cubicInterpolationMode',\n\t\t'fill'\n\t],\n\tdataElementType: 'point',\n\tdataElementOptions: {\n\t\tbackgroundColor: 'pointBackgroundColor',\n\t\tborderColor: 'pointBorderColor',\n\t\tborderWidth: 'pointBorderWidth',\n\t\thitRadius: 'pointHitRadius',\n\t\thoverHitRadius: 'pointHitRadius',\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\n\t\thoverBorderColor: 'pointHoverBorderColor',\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\n\t\thoverRadius: 'pointHoverRadius',\n\t\tpointStyle: 'pointStyle',\n\t\tradius: 'pointRadius',\n\t\trotation: 'pointRotation'\n\t},\n\tshowLines: true,\n\tspanGaps: false,\n\thover: {\n\t\tmode: 'index'\n\t},\n\tscales: {\n\t\t_index_: {\n\t\t\ttype: 'category',\n\t\t},\n\t\t_value_: {\n\t\t\ttype: 'linear',\n\t\t},\n\t}\n};\nfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n\tconst pointCount = points.length;\n\tlet start = 0;\n\tlet count = pointCount;\n\tif (meta._sorted) {\n\t\tconst {iScale, _parsed} = meta;\n\t\tconst axis = iScale.axis;\n\t\tconst {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\t\tif (minDefined) {\n\t\t\tstart = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(Math.min(\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"w\"])(_parsed, iScale.axis, min).lo,\n\t\t\t\tanimationsDisabled ? pointCount : Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"w\"])(points, axis, iScale.getPixelForValue(min)).lo),\n\t\t\t0, pointCount - 1);\n\t\t}\n\t\tif (maxDefined) {\n\t\t\tcount = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(Math.max(\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"w\"])(_parsed, iScale.axis, max).hi + 1,\n\t\t\t\tanimationsDisabled ? 0 : Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"w\"])(points, axis, iScale.getPixelForValue(max)).hi + 1),\n\t\t\tstart, pointCount) - start;\n\t\t} else {\n\t\t\tcount = pointCount - start;\n\t\t}\n\t}\n\treturn {start, count};\n}\nfunction scaleRangesChanged(meta) {\n\tconst {xScale, yScale, _scaleRanges} = meta;\n\tconst newRanges = {\n\t\txmin: xScale.min,\n\t\txmax: xScale.max,\n\t\tymin: yScale.min,\n\t\tymax: yScale.max\n\t};\n\tif (!_scaleRanges) {\n\t\tmeta._scaleRanges = newRanges;\n\t\treturn true;\n\t}\n\tconst changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\tObject.assign(_scaleRanges, newRanges);\n\treturn changed;\n}\n\nfunction getStartAngleRadians(deg) {\n\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(deg) - 0.5 * Math.PI;\n}\nclass PolarAreaController extends DatasetController {\n\tconstructor(chart, datasetIndex) {\n\t\tsuper(chart, datasetIndex);\n\t\tthis.innerRadius = undefined;\n\t\tthis.outerRadius = undefined;\n\t}\n\tupdate(mode) {\n\t\tconst arcs = this._cachedMeta.data;\n\t\tthis._updateRadius();\n\t\tthis.updateElements(arcs, 0, arcs.length, mode);\n\t}\n\t_updateRadius() {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst chartArea = chart.chartArea;\n\t\tconst opts = chart.options;\n\t\tconst minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\tconst outerRadius = Math.max(minSize / 2, 0);\n\t\tconst innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\tconst radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\t\tme.outerRadius = outerRadius - (radiusLength * me.index);\n\t\tme.innerRadius = me.outerRadius - radiusLength;\n\t}\n\tupdateElements(arcs, start, count, mode) {\n\t\tconst me = this;\n\t\tconst reset = mode === 'reset';\n\t\tconst chart = me.chart;\n\t\tconst dataset = me.getDataset();\n\t\tconst opts = chart.options;\n\t\tconst animationOpts = opts.animation;\n\t\tconst scale = me._cachedMeta.rScale;\n\t\tconst centerX = scale.xCenter;\n\t\tconst centerY = scale.yCenter;\n\t\tconst datasetStartAngle = getStartAngleRadians(opts.startAngle);\n\t\tlet angle = datasetStartAngle;\n\t\tlet i;\n\t\tme._cachedMeta.count = me.countVisibleElements();\n\t\tfor (i = 0; i < start; ++i) {\n\t\t\tangle += me._computeAngle(i);\n\t\t}\n\t\tfor (i = start; i < start + count; i++) {\n\t\t\tconst arc = arcs[i];\n\t\t\tlet startAngle = angle;\n\t\t\tlet endAngle = angle + me._computeAngle(i);\n\t\t\tlet outerRadius = this.chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\n\t\t\tangle = endAngle;\n\t\t\tif (reset) {\n\t\t\t\tif (animationOpts.animateScale) {\n\t\t\t\t\touterRadius = 0;\n\t\t\t\t}\n\t\t\t\tif (animationOpts.animateRotate) {\n\t\t\t\t\tstartAngle = datasetStartAngle;\n\t\t\t\t\tendAngle = datasetStartAngle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst properties = {\n\t\t\t\tx: centerX,\n\t\t\t\ty: centerY,\n\t\t\t\tinnerRadius: 0,\n\t\t\t\touterRadius,\n\t\t\t\tstartAngle,\n\t\t\t\tendAngle,\n\t\t\t\toptions: me.resolveDataElementOptions(i, mode)\n\t\t\t};\n\t\t\tme.updateElement(arc, i, properties, mode);\n\t\t}\n\t}\n\tcountVisibleElements() {\n\t\tconst dataset = this.getDataset();\n\t\tconst meta = this._cachedMeta;\n\t\tlet count = 0;\n\t\tmeta.data.forEach((element, index) => {\n\t\t\tif (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t});\n\t\treturn count;\n\t}\n\t_computeAngle(index) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst count = meta.count;\n\t\tconst dataset = me.getDataset();\n\t\tif (isNaN(dataset.data[index]) || !this.chart.getDataVisibility(index)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst context = {\n\t\t\tchart: me.chart,\n\t\t\tdataPoint: this.getParsed(index),\n\t\t\tdataIndex: index,\n\t\t\tdataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([\n\t\t\tme.chart.options.elements.arc.angle,\n\t\t\t(2 * Math.PI) / count\n\t\t], context, index);\n\t}\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n\tdataElementType: 'arc',\n\tdataElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderColor',\n\t\t'borderWidth',\n\t\t'borderAlign',\n\t\t'offset'\n\t],\n\tanimation: {\n\t\tnumbers: {\n\t\t\ttype: 'number',\n\t\t\tproperties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n\t\t},\n\t\tanimateRotate: true,\n\t\tanimateScale: true\n\t},\n\taspectRatio: 1,\n\tdatasets: {\n\t\tindexAxis: 'r'\n\t},\n\tscales: {\n\t\tr: {\n\t\t\ttype: 'radialLinear',\n\t\t\tangleLines: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tbeginAtZero: true,\n\t\t\tgridLines: {\n\t\t\t\tcircular: true\n\t\t\t},\n\t\t\tpointLabels: {\n\t\t\t\tdisplay: false\n\t\t\t}\n\t\t}\n\t},\n\tstartAngle: 0,\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels(chart) {\n\t\t\t\tconst data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map((label, i) => {\n\t\t\t\t\t\tconst meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tconst style = meta.controller.getStyle(i);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\n\t\t\t\t\t\t\tstrokeStyle: style.borderColor,\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\n\t\t\t\t\t\t\thidden: !chart.getDataVisibility(i),\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\t\tonClick(e, legendItem, legend) {\n\t\t\tlegend.chart.toggleDataVisibility(legendItem.index);\n\t\t\tlegend.chart.update();\n\t\t}\n\t},\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel(context) {\n\t\t\t\treturn context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n\tcutoutPercentage: 0\n};\n\nclass RadarController extends DatasetController {\n\tgetLabelAndValue(index) {\n\t\tconst me = this;\n\t\tconst vScale = me._cachedMeta.vScale;\n\t\tconst parsed = me.getParsed(index);\n\t\treturn {\n\t\t\tlabel: vScale.getLabels()[index],\n\t\t\tvalue: '' + vScale.getLabelForValue(parsed[vScale.axis])\n\t\t};\n\t}\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\t\tconst line = meta.dataset;\n\t\tconst points = meta.data || [];\n\t\tconst labels = meta.iScale.getLabels();\n\t\tif (mode !== 'resize') {\n\t\t\tconst properties = {\n\t\t\t\tpoints,\n\t\t\t\t_loop: true,\n\t\t\t\t_fullLoop: labels.length === points.length,\n\t\t\t\toptions: me.resolveDatasetElementOptions()\n\t\t\t};\n\t\t\tme.updateElement(line, undefined, properties, mode);\n\t\t}\n\t\tme.updateElements(points, 0, points.length, mode);\n\t}\n\tupdateElements(points, start, count, mode) {\n\t\tconst me = this;\n\t\tconst dataset = me.getDataset();\n\t\tconst scale = me._cachedMeta.rScale;\n\t\tconst reset = mode === 'reset';\n\t\tfor (let i = start; i < start + count; i++) {\n\t\t\tconst point = points[i];\n\t\t\tconst options = me.resolveDataElementOptions(i, mode);\n\t\t\tconst pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\n\t\t\tconst x = reset ? scale.xCenter : pointPosition.x;\n\t\t\tconst y = reset ? scale.yCenter : pointPosition.y;\n\t\t\tconst properties = {\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tangle: pointPosition.angle,\n\t\t\t\tskip: isNaN(x) || isNaN(y),\n\t\t\t\toptions\n\t\t\t};\n\t\t\tme.updateElement(point, i, properties, mode);\n\t\t}\n\t}\n\tresolveDatasetElementOptions(active) {\n\t\tconst me = this;\n\t\tconst config = me._config;\n\t\tconst options = me.chart.options;\n\t\tconst values = super.resolveDatasetElementOptions(active);\n\t\tconst showLine = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.showLine, options.showLines);\n\t\tvalues.spanGaps = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.spanGaps, options.spanGaps);\n\t\tvalues.tension = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.lineTension, options.elements.line.tension);\n\t\tif (!showLine) {\n\t\t\tvalues.borderWidth = 0;\n\t\t}\n\t\treturn values;\n\t}\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n\tdatasetElementType: 'line',\n\tdatasetElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderColor',\n\t\t'borderCapStyle',\n\t\t'borderDash',\n\t\t'borderDashOffset',\n\t\t'borderJoinStyle',\n\t\t'borderWidth',\n\t\t'fill'\n\t],\n\tdataElementType: 'point',\n\tdataElementOptions: {\n\t\tbackgroundColor: 'pointBackgroundColor',\n\t\tborderColor: 'pointBorderColor',\n\t\tborderWidth: 'pointBorderWidth',\n\t\thitRadius: 'pointHitRadius',\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\n\t\thoverBorderColor: 'pointHoverBorderColor',\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\n\t\thoverRadius: 'pointHoverRadius',\n\t\tpointStyle: 'pointStyle',\n\t\tradius: 'pointRadius',\n\t\trotation: 'pointRotation'\n\t},\n\taspectRatio: 1,\n\tspanGaps: false,\n\tscales: {\n\t\tr: {\n\t\t\ttype: 'radialLinear',\n\t\t}\n\t},\n\tdatasets: {\n\t\tindexAxis: 'r'\n\t},\n\telements: {\n\t\tline: {\n\t\t\tfill: 'start',\n\t\t\ttension: 0\n\t\t}\n\t}\n};\n\nclass ScatterController extends LineController {\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n\tscales: {\n\t\tx: {\n\t\t\ttype: 'linear'\n\t\t},\n\t\ty: {\n\t\t\ttype: 'linear'\n\t\t}\n\t},\n\tdatasets: {\n\t\tshowLine: false,\n\t\tfill: false\n\t},\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel(item) {\n\t\t\t\treturn '(' + item.label + ', ' + item.formattedValue + ')';\n\t\t\t}\n\t\t}\n\t}\n};\n\nfunction abstract() {\n\tthrow new Error('This method is not implemented: either no adapter can be found or an incomplete integration was provided.');\n}\nclass DateAdapter {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\tformats() {\n\t\treturn abstract();\n\t}\n\tparse(value, format) {\n\t\treturn abstract();\n\t}\n\tformat(timestamp, format) {\n\t\treturn abstract();\n\t}\n\tadd(timestamp, amount, unit) {\n\t\treturn abstract();\n\t}\n\tdiff(a, b, unit) {\n\t\treturn abstract();\n\t}\n\tstartOf(timestamp, unit, weekday) {\n\t\treturn abstract();\n\t}\n\tendOf(timestamp, unit) {\n\t\treturn abstract();\n\t}\n}\nDateAdapter.override = function(members) {\n\tObject.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n\t_date: DateAdapter\n};\n\nfunction getRelativePosition(e, chart) {\n\tif ('native' in e) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"y\"])(e, chart);\n}\nfunction evaluateAllVisibleItems(chart, handler) {\n\tconst metasets = chart.getSortedVisibleDatasetMetas();\n\tlet index, data, element;\n\tfor (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\t({index, data} = metasets[i]);\n\t\tfor (let j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\telement = data[j];\n\t\t\tif (!element.skip) {\n\t\t\t\thandler(element, index, j);\n\t\t\t}\n\t\t}\n\t}\n}\nfunction binarySearch(metaset, axis, value, intersect) {\n\tconst {controller, data, _sorted} = metaset;\n\tconst iScale = controller._cachedMeta.iScale;\n\tif (iScale && axis === iScale.axis && _sorted && data.length) {\n\t\tconst lookupMethod = iScale._reversePixels ? _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"A\"] : _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"w\"];\n\t\tif (!intersect) {\n\t\t\treturn lookupMethod(data, axis, value);\n\t\t} else if (controller._sharedOptions) {\n\t\t\tconst el = data[0];\n\t\t\tconst range = typeof el.getRange === 'function' && el.getRange(axis);\n\t\t\tif (range) {\n\t\t\t\tconst start = lookupMethod(data, axis, value - range);\n\t\t\t\tconst end = lookupMethod(data, axis, value + range);\n\t\t\t\treturn {lo: start.lo, hi: end.hi};\n\t\t\t}\n\t\t}\n\t}\n\treturn {lo: 0, hi: data.length - 1};\n}\nfunction optimizedEvaluateItems(chart, axis, position, handler, intersect) {\n\tconst metasets = chart.getSortedVisibleDatasetMetas();\n\tconst value = position[axis];\n\tfor (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\tconst {index, data} = metasets[i];\n\t\tconst {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n\t\tfor (let j = lo; j <= hi; ++j) {\n\t\t\tconst element = data[j];\n\t\t\tif (!element.skip) {\n\t\t\t\thandler(element, index, j);\n\t\t\t}\n\t\t}\n\t}\n}\nfunction getDistanceMetricForAxis(axis) {\n\tconst useX = axis.indexOf('x') !== -1;\n\tconst useY = axis.indexOf('y') !== -1;\n\treturn function(pt1, pt2) {\n\t\tconst deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tconst deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition) {\n\tconst items = [];\n\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(position, chart.chartArea)) {\n\t\treturn items;\n\t}\n\tconst evaluationFunc = function(element, datasetIndex, index) {\n\t\tif (element.inRange(position.x, position.y, useFinalPosition)) {\n\t\t\titems.push({element, datasetIndex, index});\n\t\t}\n\t};\n\toptimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\n\treturn items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition) {\n\tconst distanceMetric = getDistanceMetricForAxis(axis);\n\tlet minDistance = Number.POSITIVE_INFINITY;\n\tlet items = [];\n\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(position, chart.chartArea)) {\n\t\treturn items;\n\t}\n\tconst evaluationFunc = function(element, datasetIndex, index) {\n\t\tif (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {\n\t\t\treturn;\n\t\t}\n\t\tconst center = element.getCenterPoint(useFinalPosition);\n\t\tconst distance = distanceMetric(position, center);\n\t\tif (distance < minDistance) {\n\t\t\titems = [{element, datasetIndex, index}];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\titems.push({element, datasetIndex, index});\n\t\t}\n\t};\n\toptimizedEvaluateItems(chart, axis, position, evaluationFunc);\n\treturn items;\n}\nfunction getAxisItems(chart, e, options, useFinalPosition) {\n\tconst position = getRelativePosition(e, chart);\n\tconst items = [];\n\tconst axis = options.axis;\n\tconst rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n\tlet intersectsItem = false;\n\tevaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\n\t\tif (element[rangeMethod](position[axis], useFinalPosition)) {\n\t\t\titems.push({element, datasetIndex, index});\n\t\t}\n\t\tif (element.inRange(position.x, position.y, useFinalPosition)) {\n\t\t\tintersectsItem = true;\n\t\t}\n\t});\n\tif (options.intersect && !intersectsItem) {\n\t\treturn [];\n\t}\n\treturn items;\n}\nvar Interaction = {\n\tmodes: {\n\t\tindex(chart, e, options, useFinalPosition) {\n\t\t\tconst position = getRelativePosition(e, chart);\n\t\t\tconst axis = options.axis || 'x';\n\t\t\tconst items = options.intersect\n\t\t\t\t? getIntersectItems(chart, position, axis, useFinalPosition)\n\t\t\t\t: getNearestItems(chart, position, axis, false, useFinalPosition);\n\t\t\tconst elements = [];\n\t\t\tif (!items.length) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tchart.getSortedVisibleDatasetMetas().forEach((meta) => {\n\t\t\t\tconst index = items[0].index;\n\t\t\t\tconst element = meta.data[index];\n\t\t\t\tif (element && !element.skip) {\n\t\t\t\t\telements.push({element, datasetIndex: meta.index, index});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn elements;\n\t\t},\n\t\tdataset(chart, e, options, useFinalPosition) {\n\t\t\tconst position = getRelativePosition(e, chart);\n\t\t\tconst axis = options.axis || 'xy';\n\t\t\tlet items = options.intersect\n\t\t\t\t? getIntersectItems(chart, position, axis, useFinalPosition) :\n\t\t\t\tgetNearestItems(chart, position, axis, false, useFinalPosition);\n\t\t\tif (items.length > 0) {\n\t\t\t\tconst datasetIndex = items[0].datasetIndex;\n\t\t\t\tconst data = chart.getDatasetMeta(datasetIndex).data;\n\t\t\t\titems = [];\n\t\t\t\tfor (let i = 0; i < data.length; ++i) {\n\t\t\t\t\titems.push({element: data[i], datasetIndex, index: i});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\t\tpoint(chart, e, options, useFinalPosition) {\n\t\t\tconst position = getRelativePosition(e, chart);\n\t\t\tconst axis = options.axis || 'xy';\n\t\t\treturn getIntersectItems(chart, position, axis, useFinalPosition);\n\t\t},\n\t\tnearest(chart, e, options, useFinalPosition) {\n\t\t\tconst position = getRelativePosition(e, chart);\n\t\t\tconst axis = options.axis || 'xy';\n\t\t\treturn getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\n\t\t},\n\t\tx(chart, e, options, useFinalPosition) {\n\t\t\toptions.axis = 'x';\n\t\t\treturn getAxisItems(chart, e, options, useFinalPosition);\n\t\t},\n\t\ty(chart, e, options, useFinalPosition) {\n\t\t\toptions.axis = 'y';\n\t\t\treturn getAxisItems(chart, e, options, useFinalPosition);\n\t\t}\n\t}\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n\treturn array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n\treturn array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n\treturn array.sort((a, b) => {\n\t\tconst v0 = reverse ? b : a;\n\t\tconst v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0.index - v1.index :\n\t\t\tv0.weight - v1.weight;\n\t});\n}\nfunction wrapBoxes(boxes) {\n\tconst layoutBoxes = [];\n\tlet i, ilen, box;\n\tfor (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n\t\tbox = boxes[i];\n\t\tlayoutBoxes.push({\n\t\t\tindex: i,\n\t\t\tbox,\n\t\t\tpos: box.position,\n\t\t\thorizontal: box.isHorizontal(),\n\t\t\tweight: box.weight\n\t\t});\n\t}\n\treturn layoutBoxes;\n}\nfunction setLayoutDims(layouts, params) {\n\tlet i, ilen, layout;\n\tfor (i = 0, ilen = layouts.length; i < ilen; ++i) {\n\t\tlayout = layouts[i];\n\t\tlayout.width = layout.horizontal\n\t\t\t? layout.box.fullWidth && params.availableWidth\n\t\t\t: params.vBoxMaxWidth;\n\t\tlayout.height = layout.horizontal && params.hBoxMaxHeight;\n\t}\n}\nfunction buildLayoutBoxes(boxes) {\n\tconst layoutBoxes = wrapBoxes(boxes);\n\tconst left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n\tconst right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n\tconst top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n\tconst bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n\tconst centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n\tconst centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\treturn {\n\t\tleftAndTop: left.concat(top),\n\t\trightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n\t\tchartArea: filterByPosition(layoutBoxes, 'chartArea'),\n\t\tvertical: left.concat(right).concat(centerVertical),\n\t\thorizontal: top.concat(bottom).concat(centerHorizontal)\n\t};\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n\treturn Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateDims(chartArea, params, layout) {\n\tconst box = layout.box;\n\tconst maxPadding = chartArea.maxPadding;\n\tif (layout.size) {\n\t\tchartArea[layout.pos] -= layout.size;\n\t}\n\tlayout.size = layout.horizontal ? box.height : box.width;\n\tchartArea[layout.pos] += layout.size;\n\tif (box.getPadding) {\n\t\tconst boxPadding = box.getPadding();\n\t\tmaxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n\t\tmaxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n\t\tmaxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n\t\tmaxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n\t}\n\tconst newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right');\n\tconst newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');\n\tif (newWidth !== chartArea.w || newHeight !== chartArea.h) {\n\t\tchartArea.w = newWidth;\n\t\tchartArea.h = newHeight;\n\t\treturn layout.horizontal ? newWidth !== chartArea.w : newHeight !== chartArea.h;\n\t}\n}\nfunction handleMaxPadding(chartArea) {\n\tconst maxPadding = chartArea.maxPadding;\n\tfunction updatePos(pos) {\n\t\tconst change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n\t\tchartArea[pos] += change;\n\t\treturn change;\n\t}\n\tchartArea.y += updatePos('top');\n\tchartArea.x += updatePos('left');\n\tupdatePos('right');\n\tupdatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n\tconst maxPadding = chartArea.maxPadding;\n\tfunction marginForPositions(positions) {\n\t\tconst margin = {left: 0, top: 0, right: 0, bottom: 0};\n\t\tpositions.forEach((pos) => {\n\t\t\tmargin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n\t\t});\n\t\treturn margin;\n\t}\n\treturn horizontal\n\t\t? marginForPositions(['left', 'right'])\n\t\t: marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params) {\n\tconst refitBoxes = [];\n\tlet i, ilen, layout, box, refit, changed;\n\tfor (i = 0, ilen = boxes.length; i < ilen; ++i) {\n\t\tlayout = boxes[i];\n\t\tbox = layout.box;\n\t\tbox.update(\n\t\t\tlayout.width || chartArea.w,\n\t\t\tlayout.height || chartArea.h,\n\t\t\tgetMargins(layout.horizontal, chartArea)\n\t\t);\n\t\tif (updateDims(chartArea, params, layout)) {\n\t\t\tchanged = true;\n\t\t\tif (refitBoxes.length) {\n\t\t\t\trefit = true;\n\t\t\t}\n\t\t}\n\t\tif (!box.fullWidth) {\n\t\t\trefitBoxes.push(layout);\n\t\t}\n\t}\n\treturn refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;\n}\nfunction placeBoxes(boxes, chartArea, params) {\n\tconst userPadding = params.padding;\n\tlet x = chartArea.x;\n\tlet y = chartArea.y;\n\tlet i, ilen, layout, box;\n\tfor (i = 0, ilen = boxes.length; i < ilen; ++i) {\n\t\tlayout = boxes[i];\n\t\tbox = layout.box;\n\t\tif (layout.horizontal) {\n\t\t\tbox.left = box.fullWidth ? userPadding.left : chartArea.left;\n\t\t\tbox.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;\n\t\t\tbox.top = y;\n\t\t\tbox.bottom = y + box.height;\n\t\t\tbox.width = box.right - box.left;\n\t\t\ty = box.bottom;\n\t\t} else {\n\t\t\tbox.left = x;\n\t\t\tbox.right = x + box.width;\n\t\t\tbox.top = chartArea.top;\n\t\t\tbox.bottom = chartArea.top + chartArea.h;\n\t\t\tbox.height = box.bottom - box.top;\n\t\t\tx = box.right;\n\t\t}\n\t}\n\tchartArea.x = x;\n\tchartArea.y = y;\n}\n_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('layout', {\n\tpadding: {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: 0,\n\t\tleft: 0\n\t}\n});\nvar layouts = {\n\taddBox(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\t\titem._layers = item._layers || function() {\n\t\t\treturn [{\n\t\t\t\tz: 0,\n\t\t\t\tdraw(chartArea) {\n\t\t\t\t\titem.draw(chartArea);\n\t\t\t\t}\n\t\t\t}];\n\t\t};\n\t\tchart.boxes.push(item);\n\t},\n\tremoveBox(chart, layoutItem) {\n\t\tconst index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\tconfigure(chart, item, options) {\n\t\tconst props = ['fullWidth', 'position', 'weight'];\n\t\tconst ilen = props.length;\n\t\tlet i = 0;\n\t\tlet prop;\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (Object.prototype.hasOwnProperty.call(options, prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\tupdate(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\t\tconst layoutOptions = chart.options.layout || {};\n\t\tconst padding = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(layoutOptions.padding);\n\t\tconst availableWidth = width - padding.width;\n\t\tconst availableHeight = height - padding.height;\n\t\tconst boxes = buildLayoutBoxes(chart.boxes);\n\t\tconst verticalBoxes = boxes.vertical;\n\t\tconst horizontalBoxes = boxes.horizontal;\n\t\tconst params = Object.freeze({\n\t\t\touterWidth: width,\n\t\t\touterHeight: height,\n\t\t\tpadding,\n\t\t\tavailableWidth,\n\t\t\tvBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,\n\t\t\thBoxMaxHeight: availableHeight / 2\n\t\t});\n\t\tconst chartArea = Object.assign({\n\t\t\tmaxPadding: Object.assign({}, padding),\n\t\t\tw: availableWidth,\n\t\t\th: availableHeight,\n\t\t\tx: padding.left,\n\t\t\ty: padding.top\n\t\t}, padding);\n\t\tsetLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\t\tfitBoxes(verticalBoxes, chartArea, params);\n\t\tif (fitBoxes(horizontalBoxes, chartArea, params)) {\n\t\t\tfitBoxes(verticalBoxes, chartArea, params);\n\t\t}\n\t\thandleMaxPadding(chartArea);\n\t\tplaceBoxes(boxes.leftAndTop, chartArea, params);\n\t\tchartArea.x += chartArea.w;\n\t\tchartArea.y += chartArea.h;\n\t\tplaceBoxes(boxes.rightAndBottom, chartArea, params);\n\t\tchart.chartArea = {\n\t\t\tleft: chartArea.left,\n\t\t\ttop: chartArea.top,\n\t\t\tright: chartArea.left + chartArea.w,\n\t\t\tbottom: chartArea.top + chartArea.h,\n\t\t\theight: chartArea.h,\n\t\t\twidth: chartArea.w,\n\t\t};\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(boxes.chartArea, (layout) => {\n\t\t\tconst box = layout.box;\n\t\t\tObject.assign(box, chart.chartArea);\n\t\t\tbox.update(chartArea.w, chartArea.h);\n\t\t});\n\t}\n};\n\nclass BasePlatform {\n\tacquireContext(canvas, options) {}\n\treleaseContext(context) {\n\t\treturn false;\n\t}\n\taddEventListener(chart, type, listener) {}\n\tremoveEventListener(chart, type, listener) {}\n\tgetDevicePixelRatio() {\n\t\treturn 1;\n\t}\n\tgetMaximumSize(element, width, height, aspectRatio) {\n\t\twidth = Math.max(0, width || element.width);\n\t\theight = height || element.height;\n\t\treturn {\n\t\t\twidth,\n\t\t\theight: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n\t\t};\n\t}\n\tisAttached(canvas) {\n\t\treturn true;\n\t}\n}\n\nclass BasicPlatform extends BasePlatform {\n\tacquireContext(item) {\n\t\treturn item && item.getContext && item.getContext('2d') || null;\n\t}\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n\ttouchstart: 'mousedown',\n\ttouchmove: 'mousemove',\n\ttouchend: 'mouseup',\n\tpointerenter: 'mouseenter',\n\tpointerdown: 'mousedown',\n\tpointermove: 'mousemove',\n\tpointerup: 'mouseup',\n\tpointerleave: 'mouseout',\n\tpointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, config) {\n\tconst style = canvas.style;\n\tconst renderHeight = canvas.getAttribute('height');\n\tconst renderWidth = canvas.getAttribute('width');\n\tcanvas[EXPANDO_KEY] = {\n\t\tinitial: {\n\t\t\theight: renderHeight,\n\t\t\twidth: renderWidth,\n\t\t\tstyle: {\n\t\t\t\tdisplay: style.display,\n\t\t\t\theight: style.height,\n\t\t\t\twidth: style.width\n\t\t\t}\n\t\t}\n\t};\n\tstyle.display = style.display || 'block';\n\tstyle.boxSizing = style.boxSizing || 'border-box';\n\tif (isNullOrEmpty(renderWidth)) {\n\t\tconst displayWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"F\"])(canvas, 'width');\n\t\tif (displayWidth !== undefined) {\n\t\t\tcanvas.width = displayWidth;\n\t\t}\n\t}\n\tif (isNullOrEmpty(renderHeight)) {\n\t\tif (canvas.style.height === '') {\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t} else {\n\t\t\tconst displayHeight = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"F\"])(canvas, 'height');\n\t\t\tif (displayHeight !== undefined) {\n\t\t\t\tcanvas.height = displayHeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn canvas;\n}\nconst eventListenerOptions = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"H\"] ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n\tnode.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n\tchart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n\tconst type = EVENT_TYPES[event.type] || event.type;\n\tconst {x, y} = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"y\"])(event, chart);\n\treturn {\n\t\ttype,\n\t\tchart,\n\t\tnative: event,\n\t\tx: x !== undefined ? x : null,\n\t\ty: y !== undefined ? y : null,\n\t};\n}\nfunction createAttachObserver(chart, type, listener) {\n\tconst canvas = chart.canvas;\n\tconst container = canvas && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(canvas);\n\tconst element = container || canvas;\n\tconst observer = new MutationObserver(entries => {\n\t\tconst parent = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(element);\n\t\tentries.forEach(entry => {\n\t\t\tfor (let i = 0; i < entry.addedNodes.length; i++) {\n\t\t\t\tconst added = entry.addedNodes[i];\n\t\t\t\tif (added === element || added === parent) {\n\t\t\t\t\tlistener(entry.target);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\tobserver.observe(document, {childList: true, subtree: true});\n\treturn observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n\tconst canvas = chart.canvas;\n\tconst container = canvas && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(canvas);\n\tif (!container) {\n\t\treturn;\n\t}\n\tconst observer = new MutationObserver(entries => {\n\t\tentries.forEach(entry => {\n\t\t\tfor (let i = 0; i < entry.removedNodes.length; i++) {\n\t\t\t\tif (entry.removedNodes[i] === canvas) {\n\t\t\t\t\tlistener();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\tobserver.observe(container, {childList: true});\n\treturn observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n\tconst dpr = window.devicePixelRatio;\n\tif (dpr === oldDevicePixelRatio) {\n\t\treturn;\n\t}\n\toldDevicePixelRatio = dpr;\n\tdrpListeningCharts.forEach((resize, chart) => {\n\t\tif (chart.currentDevicePixelRatio !== dpr) {\n\t\t\tresize();\n\t\t}\n\t});\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n\tif (!drpListeningCharts.size) {\n\t\twindow.addEventListener('resize', onWindowResize);\n\t}\n\tdrpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n\tdrpListeningCharts.delete(chart);\n\tif (!drpListeningCharts.size) {\n\t\twindow.removeEventListener('resize', onWindowResize);\n\t}\n}\nfunction createResizeObserver(chart, type, listener) {\n\tconst canvas = chart.canvas;\n\tconst container = canvas && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(canvas);\n\tif (!container) {\n\t\treturn;\n\t}\n\tconst resize = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"G\"])((width, height) => {\n\t\tconst w = container.clientWidth;\n\t\tlistener(width, height);\n\t\tif (w < container.clientWidth) {\n\t\t\tlistener();\n\t\t}\n\t}, window);\n\tconst observer = new ResizeObserver(entries => {\n\t\tconst entry = entries[0];\n\t\tconst width = entry.contentRect.width;\n\t\tconst height = entry.contentRect.height;\n\t\tif (width === 0 && height === 0) {\n\t\t\treturn;\n\t\t}\n\t\tresize(width, height);\n\t});\n\tobserver.observe(container);\n\tlistenDevicePixelRatioChanges(chart, resize);\n\treturn observer;\n}\nfunction releaseObserver(chart, type, observer) {\n\tif (observer) {\n\t\tobserver.disconnect();\n\t}\n\tif (type === 'resize') {\n\t\tunlistenDevicePixelRatioChanges(chart);\n\t}\n}\nfunction createProxyAndListen(chart, type, listener) {\n\tconst canvas = chart.canvas;\n\tconst proxy = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"G\"])((event) => {\n\t\tif (chart.ctx !== null) {\n\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t}\n\t}, chart, (args) => {\n\t\tconst event = args[0];\n\t\treturn [event, event.offsetX, event.offsetY];\n\t});\n\taddListener(canvas, type, proxy);\n\treturn proxy;\n}\nclass DomPlatform extends BasePlatform {\n\tacquireContext(canvas, config) {\n\t\tconst context = canvas && canvas.getContext && canvas.getContext('2d');\n\t\tif (context && context.canvas === canvas) {\n\t\t\tinitCanvas(canvas, config);\n\t\t\treturn context;\n\t\t}\n\t\treturn null;\n\t}\n\treleaseContext(context) {\n\t\tconst canvas = context.canvas;\n\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\treturn false;\n\t\t}\n\t\tconst initial = canvas[EXPANDO_KEY].initial;\n\t\t['height', 'width'].forEach((prop) => {\n\t\t\tconst value = initial[prop];\n\t\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(value)) {\n\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t}\n\t\t});\n\t\tconst style = initial.style || {};\n\t\tObject.keys(style).forEach((key) => {\n\t\t\tcanvas.style[key] = style[key];\n\t\t});\n\t\tcanvas.width = canvas.width;\n\t\tdelete canvas[EXPANDO_KEY];\n\t\treturn true;\n\t}\n\taddEventListener(chart, type, listener) {\n\t\tthis.removeEventListener(chart, type);\n\t\tconst proxies = chart.$proxies || (chart.$proxies = {});\n\t\tconst handlers = {\n\t\t\tattach: createAttachObserver,\n\t\t\tdetach: createDetachObserver,\n\t\t\tresize: createResizeObserver\n\t\t};\n\t\tconst handler = handlers[type] || createProxyAndListen;\n\t\tproxies[type] = handler(chart, type, listener);\n\t}\n\tremoveEventListener(chart, type) {\n\t\tconst proxies = chart.$proxies || (chart.$proxies = {});\n\t\tconst proxy = proxies[type];\n\t\tif (!proxy) {\n\t\t\treturn;\n\t\t}\n\t\tconst handlers = {\n\t\t\tattach: releaseObserver,\n\t\t\tdetach: releaseObserver,\n\t\t\tresize: releaseObserver\n\t\t};\n\t\tconst handler = handlers[type] || removeListener;\n\t\thandler(chart, type, proxy);\n\t\tproxies[type] = undefined;\n\t}\n\tgetDevicePixelRatio() {\n\t\treturn window.devicePixelRatio;\n\t}\n\tgetMaximumSize(canvas, width, height, aspectRatio) {\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"D\"])(canvas, width, height, aspectRatio);\n\t}\n\tisAttached(canvas) {\n\t\tconst container = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(canvas);\n\t\treturn !!(container && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(container));\n\t}\n}\n\nclass Element {\n\tconstructor() {\n\t\tthis.x = undefined;\n\t\tthis.y = undefined;\n\t\tthis.active = false;\n\t\tthis.options = undefined;\n\t\tthis.$animations = undefined;\n\t}\n\ttooltipPosition(useFinalPosition) {\n\t\tconst {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n\t\treturn {x, y};\n\t}\n\thasValue() {\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.x) && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.y);\n\t}\n\tgetProps(props, final) {\n\t\tconst me = this;\n\t\tconst anims = this.$animations;\n\t\tif (!final || !anims) {\n\t\t\treturn me;\n\t\t}\n\t\tconst ret = {};\n\t\tprops.forEach(prop => {\n\t\t\tret[prop] = anims[prop] && anims[prop].active ? anims[prop]._to : me[prop];\n\t\t});\n\t\treturn ret;\n\t}\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst intlCache = new Map();\nconst formatters = {\n\tvalues(value) {\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(value) ? value : '' + value;\n\t},\n\tnumeric(tickValue, index, ticks) {\n\t\tif (tickValue === 0) {\n\t\t\treturn '0';\n\t\t}\n\t\tconst locale = this.chart.options.locale;\n\t\tconst maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n\t\tlet notation;\n\t\tif (maxTick < 1e-4 || maxTick > 1e+15) {\n\t\t\tnotation = 'scientific';\n\t\t}\n\t\tlet delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\t\tif (Math.abs(delta) > 1 && tickValue !== Math.floor(tickValue)) {\n\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t}\n\t\tconst logDelta = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(Math.abs(delta));\n\t\tconst numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\t\tconst options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n\t\tObject.assign(options, this.options.ticks.format);\n\t\tconst cacheKey = locale + JSON.stringify(options);\n\t\tlet formatter = intlCache.get(cacheKey);\n\t\tif (!formatter) {\n\t\t\tformatter = new Intl.NumberFormat(locale, options);\n\t\t\tintlCache.set(cacheKey, formatter);\n\t\t}\n\t\treturn formatter.format(tickValue);\n\t}\n};\nformatters.logarithmic = function(tickValue, index, ticks) {\n\tif (tickValue === 0) {\n\t\treturn '0';\n\t}\n\tconst remain = tickValue / (Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(tickValue))));\n\tif (remain === 1 || remain === 2 || remain === 5) {\n\t\treturn formatters.numeric.call(this, tickValue, index, ticks);\n\t}\n\treturn '';\n};\nvar Ticks = {formatters};\n\n_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('scale', {\n\tdisplay: true,\n\toffset: false,\n\treverse: false,\n\tbeginAtZero: false,\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0,0,0,0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\tscaleLabel: {\n\t\tdisplay: false,\n\t\tlabelString: '',\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\tticks: {\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tlineWidth: 0,\n\t\tstrokeStyle: '',\n\t\tpadding: 0,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\nfunction sample(arr, numItems) {\n\tconst result = [];\n\tconst increment = arr.length / numItems;\n\tconst len = arr.length;\n\tlet i = 0;\n\tfor (; i < len; i += increment) {\n\t\tresult.push(arr[Math.floor(i)]);\n\t}\n\treturn result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n\tconst length = scale.ticks.length;\n\tconst validIndex = Math.min(index, length - 1);\n\tconst start = scale._startPixel;\n\tconst end = scale._endPixel;\n\tconst epsilon = 1e-6;\n\tlet lineValue = scale.getPixelForTick(validIndex);\n\tlet offset;\n\tif (offsetGridLines) {\n\t\tif (length === 1) {\n\t\t\toffset = Math.max(lineValue - start, end - lineValue);\n\t\t} else if (index === 0) {\n\t\t\toffset = (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\toffset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n\t\t}\n\t\tlineValue += validIndex < index ? offset : -offset;\n\t\tif (lineValue < start - epsilon || lineValue > end + epsilon) {\n\t\t\treturn;\n\t\t}\n\t}\n\treturn lineValue;\n}\nfunction garbageCollect(caches, length) {\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(caches, (cache) => {\n\t\tconst gc = cache.gc;\n\t\tconst gcLen = gc.length / 2;\n\t\tlet i;\n\t\tif (gcLen > length) {\n\t\t\tfor (i = 0; i < gcLen; ++i) {\n\t\t\t\tdelete cache.data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t});\n}\nfunction getTickMarkLength(options) {\n\treturn options.drawTicks ? options.tickMarkLength : 0;\n}\nfunction getScaleLabelHeight(options, fallback) {\n\tif (!options.display) {\n\t\treturn 0;\n\t}\n\tconst font = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(options.font, fallback);\n\tconst padding = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(options.padding);\n\treturn font.lineHeight + padding.height;\n}\nfunction getEvenSpacing(arr) {\n\tconst len = arr.length;\n\tlet i, diff;\n\tif (len < 2) {\n\t\treturn false;\n\t}\n\tfor (diff = arr[0], i = 1; i < len; ++i) {\n\t\tif (arr[i] - arr[i - 1] !== diff) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn diff;\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n\tconst evenMajorSpacing = getEvenSpacing(majorIndices);\n\tconst spacing = ticks.length / ticksLimit;\n\tif (!evenMajorSpacing) {\n\t\treturn Math.max(spacing, 1);\n\t}\n\tconst factors = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(evenMajorSpacing);\n\tfor (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n\t\tconst factor = factors[i];\n\t\tif (factor > spacing) {\n\t\t\treturn factor;\n\t\t}\n\t}\n\treturn Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n\tconst result = [];\n\tlet i, ilen;\n\tfor (i = 0, ilen = ticks.length; i < ilen; i++) {\n\t\tif (ticks[i].major) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\treturn result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n\tlet count = 0;\n\tlet next = majorIndices[0];\n\tlet i;\n\tspacing = Math.ceil(spacing);\n\tfor (i = 0; i < ticks.length; i++) {\n\t\tif (i === next) {\n\t\t\tnewTicks.push(ticks[i]);\n\t\t\tcount++;\n\t\t\tnext = majorIndices[count * spacing];\n\t\t}\n\t}\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n\tconst start = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(majorStart, 0);\n\tconst end = Math.min(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(majorEnd, ticks.length), ticks.length);\n\tlet count = 0;\n\tlet length, i, next;\n\tspacing = Math.ceil(spacing);\n\tif (majorEnd) {\n\t\tlength = majorEnd - majorStart;\n\t\tspacing = length / Math.floor(length / spacing);\n\t}\n\tnext = start;\n\twhile (next < 0) {\n\t\tcount++;\n\t\tnext = Math.round(start + count * spacing);\n\t}\n\tfor (i = Math.max(start, 0); i < end; i++) {\n\t\tif (i === next) {\n\t\t\tnewTicks.push(ticks[i]);\n\t\t\tcount++;\n\t\t\tnext = Math.round(start + count * spacing);\n\t\t}\n\t}\n}\nclass Scale extends Element {\n\tconstructor(cfg) {\n\t\tsuper();\n\t\tthis.id = cfg.id;\n\t\tthis.type = cfg.type;\n\t\tthis.options = undefined;\n\t\tthis.ctx = cfg.ctx;\n\t\tthis.chart = cfg.chart;\n\t\tthis.top = undefined;\n\t\tthis.bottom = undefined;\n\t\tthis.left = undefined;\n\t\tthis.right = undefined;\n\t\tthis.width = undefined;\n\t\tthis.height = undefined;\n\t\tthis._margins = {\n\t\t\tleft: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t\tbottom: 0\n\t\t};\n\t\tthis.maxWidth = undefined;\n\t\tthis.maxHeight = undefined;\n\t\tthis.paddingTop = undefined;\n\t\tthis.paddingBottom = undefined;\n\t\tthis.paddingLeft = undefined;\n\t\tthis.paddingRight = undefined;\n\t\tthis.axis = undefined;\n\t\tthis.labelRotation = undefined;\n\t\tthis.min = undefined;\n\t\tthis.max = undefined;\n\t\tthis.ticks = [];\n\t\tthis._gridLineItems = null;\n\t\tthis._labelItems = null;\n\t\tthis._labelSizes = null;\n\t\tthis._length = 0;\n\t\tthis._longestTextCache = {};\n\t\tthis._startPixel = undefined;\n\t\tthis._endPixel = undefined;\n\t\tthis._reversePixels = false;\n\t\tthis._userMax = undefined;\n\t\tthis._userMin = undefined;\n\t\tthis._ticksLength = 0;\n\t\tthis._borderValue = 0;\n\t}\n\tinit(options) {\n\t\tconst me = this;\n\t\tme.options = options;\n\t\tme.axis = me.isHorizontal() ? 'x' : 'y';\n\t\tme._userMin = me.parse(options.min);\n\t\tme._userMax = me.parse(options.max);\n\t}\n\tparse(raw, index) {\n\t\treturn raw;\n\t}\n\tgetUserBounds() {\n\t\tlet min = this._userMin;\n\t\tlet max = this._userMax;\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(min) || isNaN(min)) {\n\t\t\tmin = Number.POSITIVE_INFINITY;\n\t\t}\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(max) || isNaN(max)) {\n\t\t\tmax = Number.NEGATIVE_INFINITY;\n\t\t}\n\t\treturn {min, max, minDefined: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(min), maxDefined: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(max)};\n\t}\n\tgetMinMax(canStack) {\n\t\tconst me = this;\n\t\tlet {min, max, minDefined, maxDefined} = me.getUserBounds();\n\t\tlet range;\n\t\tif (minDefined && maxDefined) {\n\t\t\treturn {min, max};\n\t\t}\n\t\tconst metas = me.getMatchingVisibleMetas();\n\t\tfor (let i = 0, ilen = metas.length; i < ilen; ++i) {\n\t\t\trange = metas[i].controller.getMinMax(me, canStack);\n\t\t\tif (!minDefined) {\n\t\t\t\tmin = Math.min(min, range.min);\n\t\t\t}\n\t\t\tif (!maxDefined) {\n\t\t\t\tmax = Math.max(max, range.max);\n\t\t\t}\n\t\t}\n\t\treturn {min, max};\n\t}\n\tinvalidateCaches() {}\n\tgetPadding() {\n\t\tconst me = this;\n\t\treturn {\n\t\t\tleft: me.paddingLeft || 0,\n\t\t\ttop: me.paddingTop || 0,\n\t\t\tright: me.paddingRight || 0,\n\t\t\tbottom: me.paddingBottom || 0\n\t\t};\n\t}\n\tgetTicks() {\n\t\treturn this.ticks;\n\t}\n\tgetLabels() {\n\t\tconst data = this.chart.data;\n\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n\t}\n\tbeforeUpdate() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeUpdate, [this]);\n\t}\n\tupdate(maxWidth, maxHeight, margins) {\n\t\tconst me = this;\n\t\tconst tickOpts = me.options.ticks;\n\t\tconst sampleSize = tickOpts.sampleSize;\n\t\tme.beforeUpdate();\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme._margins = Object.assign({\n\t\t\tleft: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t\tbottom: 0\n\t\t}, margins);\n\t\tme.ticks = null;\n\t\tme._labelSizes = null;\n\t\tme._gridLineItems = null;\n\t\tme._labelItems = null;\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\tme.beforeDataLimits();\n\t\tme.determineDataLimits();\n\t\tme.afterDataLimits();\n\t\tme.beforeBuildTicks();\n\t\tme.ticks = me.buildTicks() || [];\n\t\tme.afterBuildTicks();\n\t\tconst samplingEnabled = sampleSize < me.ticks.length;\n\t\tme._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);\n\t\tme.configure();\n\t\tme.beforeCalculateLabelRotation();\n\t\tme.calculateLabelRotation();\n\t\tme.afterCalculateLabelRotation();\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\tme.ticks = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto') ? me._autoSkip(me.ticks) : me.ticks;\n\t\tif (samplingEnabled) {\n\t\t\tme._convertTicksToLabels(me.ticks);\n\t\t}\n\t\tme.afterUpdate();\n\t}\n\tconfigure() {\n\t\tconst me = this;\n\t\tlet reversePixels = me.options.reverse;\n\t\tlet startPixel, endPixel;\n\t\tif (me.isHorizontal()) {\n\t\t\tstartPixel = me.left;\n\t\t\tendPixel = me.right;\n\t\t} else {\n\t\t\tstartPixel = me.top;\n\t\t\tendPixel = me.bottom;\n\t\t\treversePixels = !reversePixels;\n\t\t}\n\t\tme._startPixel = startPixel;\n\t\tme._endPixel = endPixel;\n\t\tme._reversePixels = reversePixels;\n\t\tme._length = endPixel - startPixel;\n\t}\n\tafterUpdate() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterUpdate, [this]);\n\t}\n\tbeforeSetDimensions() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeSetDimensions, [this]);\n\t}\n\tsetDimensions() {\n\t\tconst me = this;\n\t\tif (me.isHorizontal()) {\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\t}\n\tafterSetDimensions() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterSetDimensions, [this]);\n\t}\n\tbeforeDataLimits() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeDataLimits, [this]);\n\t}\n\tdetermineDataLimits() {}\n\tafterDataLimits() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterDataLimits, [this]);\n\t}\n\tbeforeBuildTicks() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeBuildTicks, [this]);\n\t}\n\tbuildTicks() {\n\t\treturn [];\n\t}\n\tafterBuildTicks() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterBuildTicks, [this]);\n\t}\n\tbeforeTickToLabelConversion() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeTickToLabelConversion, [this]);\n\t}\n\tgenerateTickLabels(ticks) {\n\t\tconst me = this;\n\t\tconst tickOpts = me.options.ticks;\n\t\tlet i, ilen, tick;\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; i++) {\n\t\t\ttick = ticks[i];\n\t\t\ttick.label = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(tickOpts.callback, [tick.value, i, ticks], me);\n\t\t}\n\t}\n\tafterTickToLabelConversion() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterTickToLabelConversion, [this]);\n\t}\n\tbeforeCalculateLabelRotation() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeCalculateLabelRotation, [this]);\n\t}\n\tcalculateLabelRotation() {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst tickOpts = options.ticks;\n\t\tconst numTicks = me.ticks.length;\n\t\tconst minRotation = tickOpts.minRotation || 0;\n\t\tconst maxRotation = tickOpts.maxRotation;\n\t\tlet labelRotation = minRotation;\n\t\tlet tickWidth, maxHeight, maxLabelDiagonal;\n\t\tif (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\n\t\t\tme.labelRotation = minRotation;\n\t\t\treturn;\n\t\t}\n\t\tconst labelSizes = me._getLabelSizes();\n\t\tconst maxLabelWidth = labelSizes.widest.width;\n\t\tconst maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;\n\t\tconst maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);\n\t\ttickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\t\tif (maxLabelWidth + 6 > tickWidth) {\n\t\t\ttickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n\t\t\tmaxHeight = me.maxHeight - getTickMarkLength(options.gridLines)\n\t\t\t\t- tickOpts.padding - getScaleLabelHeight(options.scaleLabel, me.chart.options.font);\n\t\t\tmaxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n\t\t\tlabelRotation = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(Math.min(\n\t\t\t\tMath.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),\n\t\t\t\tMath.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)\n\t\t\t));\n\t\t\tlabelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n\t\t}\n\t\tme.labelRotation = labelRotation;\n\t}\n\tafterCalculateLabelRotation() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterCalculateLabelRotation, [this]);\n\t}\n\tbeforeFit() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.beforeFit, [this]);\n\t}\n\tfit() {\n\t\tconst me = this;\n\t\tconst minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t\tconst chart = me.chart;\n\t\tconst opts = me.options;\n\t\tconst tickOpts = opts.ticks;\n\t\tconst scaleLabelOpts = opts.scaleLabel;\n\t\tconst gridLineOpts = opts.gridLines;\n\t\tconst display = me._isVisible();\n\t\tconst labelsBelowTicks = opts.position !== 'top' && me.axis === 'x';\n\t\tconst isHorizontal = me.isHorizontal();\n\t\tconst scaleLabelHeight = display && getScaleLabelHeight(scaleLabelOpts, chart.options.font);\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth;\n\t\t} else if (display) {\n\t\t\tminSize.width = getTickMarkLength(gridLineOpts) + scaleLabelHeight;\n\t\t}\n\t\tif (!isHorizontal) {\n\t\t\tminSize.height = me.maxHeight;\n\t\t} else if (display) {\n\t\t\tminSize.height = getTickMarkLength(gridLineOpts) + scaleLabelHeight;\n\t\t}\n\t\tif (tickOpts.display && display && me.ticks.length) {\n\t\t\tconst labelSizes = me._getLabelSizes();\n\t\t\tconst firstLabelSize = labelSizes.first;\n\t\t\tconst lastLabelSize = labelSizes.last;\n\t\t\tconst widestLabelSize = labelSizes.widest;\n\t\t\tconst highestLabelSize = labelSizes.highest;\n\t\t\tconst lineSpace = highestLabelSize.offset * 0.8;\n\t\t\tconst tickPadding = tickOpts.padding;\n\t\t\tif (isHorizontal) {\n\t\t\t\tconst isRotated = me.labelRotation !== 0;\n\t\t\t\tconst angleRadians = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(me.labelRotation);\n\t\t\t\tconst cosRotation = Math.cos(angleRadians);\n\t\t\t\tconst sinRotation = Math.sin(angleRadians);\n\t\t\t\tconst labelHeight = sinRotation * widestLabelSize.width\n\t\t\t\t\t+ cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0))\n\t\t\t\t\t+ (isRotated ? 0 : lineSpace);\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\t\t\t\tconst offsetLeft = me.getPixelForTick(0) - me.left;\n\t\t\t\tconst offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);\n\t\t\t\tlet paddingLeft, paddingRight;\n\t\t\t\tif (isRotated) {\n\t\t\t\t\tpaddingLeft = labelsBelowTicks ?\n\t\t\t\t\t\tcosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset :\n\t\t\t\t\t\tsinRotation * (firstLabelSize.height - firstLabelSize.offset);\n\t\t\t\t\tpaddingRight = labelsBelowTicks ?\n\t\t\t\t\t\tsinRotation * (lastLabelSize.height - lastLabelSize.offset) :\n\t\t\t\t\t\tcosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;\n\t\t\t\t} else {\n\t\t\t\t\tpaddingLeft = firstLabelSize.width / 2;\n\t\t\t\t\tpaddingRight = lastLabelSize.width / 2;\n\t\t\t\t}\n\t\t\t\tme.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;\n\t\t\t\tme.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;\n\t\t\t} else {\n\t\t\t\tconst labelWidth = tickOpts.mirror ? 0 :\n\t\t\t\t\twidestLabelSize.width + tickPadding + lineSpace;\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);\n\t\t\t\tme.paddingTop = lastLabelSize.height / 2;\n\t\t\t\tme.paddingBottom = firstLabelSize.height / 2;\n\t\t\t}\n\t\t}\n\t\tme._handleMargins();\n\t\tif (isHorizontal) {\n\t\t\tme.width = me._length = chart.width - me._margins.left - me._margins.right;\n\t\t\tme.height = minSize.height;\n\t\t} else {\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = me._length = chart.height - me._margins.top - me._margins.bottom;\n\t\t}\n\t}\n\t_handleMargins() {\n\t\tconst me = this;\n\t\tif (me._margins) {\n\t\t\tme._margins.left = Math.max(me.paddingLeft, me._margins.left);\n\t\t\tme._margins.top = Math.max(me.paddingTop, me._margins.top);\n\t\t\tme._margins.right = Math.max(me.paddingRight, me._margins.right);\n\t\t\tme._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);\n\t\t}\n\t}\n\tafterFit() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(this.options.afterFit, [this]);\n\t}\n\tisHorizontal() {\n\t\tconst {axis, position} = this.options;\n\t\treturn position === 'top' || position === 'bottom' || axis === 'x';\n\t}\n\tisFullWidth() {\n\t\treturn this.options.fullWidth;\n\t}\n\t_convertTicksToLabels(ticks) {\n\t\tconst me = this;\n\t\tme.beforeTickToLabelConversion();\n\t\tme.generateTickLabels(ticks);\n\t\tme.afterTickToLabelConversion();\n\t}\n\t_getLabelSizes() {\n\t\tconst me = this;\n\t\tlet labelSizes = me._labelSizes;\n\t\tif (!labelSizes) {\n\t\t\tme._labelSizes = labelSizes = me._computeLabelSizes();\n\t\t}\n\t\treturn labelSizes;\n\t}\n\t_computeLabelSizes() {\n\t\tconst me = this;\n\t\tconst ctx = me.ctx;\n\t\tconst caches = me._longestTextCache;\n\t\tconst sampleSize = me.options.ticks.sampleSize;\n\t\tconst widths = [];\n\t\tconst heights = [];\n\t\tconst offsets = [];\n\t\tlet ticks = me.ticks;\n\t\tif (sampleSize < ticks.length) {\n\t\t\tticks = sample(ticks, sampleSize);\n\t\t}\n\t\tconst length = ticks.length;\n\t\tlet i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tlabel = ticks[i].label;\n\t\t\ttickFont = me._resolveTickFontOptions(i);\n\t\t\tctx.font = fontString = tickFont.string;\n\t\t\tcache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n\t\t\tlineHeight = tickFont.lineHeight;\n\t\t\twidth = height = 0;\n\t\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(label) && !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label)) {\n\t\t\t\twidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, cache.data, cache.gc, width, label);\n\t\t\t\theight = lineHeight;\n\t\t\t} else if (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label)) {\n\t\t\t\tfor (j = 0, jlen = label.length; j < jlen; ++j) {\n\t\t\t\t\tnestedLabel = label[j];\n\t\t\t\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(nestedLabel) && !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(nestedLabel)) {\n\t\t\t\t\t\twidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, cache.data, cache.gc, width, nestedLabel);\n\t\t\t\t\t\theight += lineHeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twidths.push(width);\n\t\t\theights.push(height);\n\t\t\toffsets.push(lineHeight / 2);\n\t\t}\n\t\tgarbageCollect(caches, length);\n\t\tconst widest = widths.indexOf(Math.max.apply(null, widths));\n\t\tconst highest = heights.indexOf(Math.max.apply(null, heights));\n\t\tfunction valueAt(idx) {\n\t\t\treturn {\n\t\t\t\twidth: widths[idx] || 0,\n\t\t\t\theight: heights[idx] || 0,\n\t\t\t\toffset: offsets[idx] || 0\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tfirst: valueAt(0),\n\t\t\tlast: valueAt(length - 1),\n\t\t\twidest: valueAt(widest),\n\t\t\thighest: valueAt(highest)\n\t\t};\n\t}\n\tgetLabelForValue(value) {\n\t\treturn value;\n\t}\n\tgetPixelForValue(value, index) {\n\t\treturn NaN;\n\t}\n\tgetValueForPixel(pixel) {}\n\tgetPixelForTick(index) {\n\t\tconst ticks = this.ticks;\n\t\tif (index < 0 || index > ticks.length - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPixelForValue(ticks[index].value);\n\t}\n\tgetPixelForDecimal(decimal) {\n\t\tconst me = this;\n\t\tif (me._reversePixels) {\n\t\t\tdecimal = 1 - decimal;\n\t\t}\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"N\"])(me._startPixel + decimal * me._length);\n\t}\n\tgetDecimalForPixel(pixel) {\n\t\tconst decimal = (pixel - this._startPixel) / this._length;\n\t\treturn this._reversePixels ? 1 - decimal : decimal;\n\t}\n\tgetBasePixel() {\n\t\treturn this.getPixelForValue(this.getBaseValue());\n\t}\n\tgetBaseValue() {\n\t\tconst {min, max} = this;\n\t\treturn min < 0 && max < 0 ? max :\n\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t0;\n\t}\n\t_autoSkip(ticks) {\n\t\tconst me = this;\n\t\tconst tickOpts = me.options.ticks;\n\t\tconst ticksLimit = tickOpts.maxTicksLimit || me._length / me._tickSize();\n\t\tconst majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n\t\tconst numMajorIndices = majorIndices.length;\n\t\tconst first = majorIndices[0];\n\t\tconst last = majorIndices[numMajorIndices - 1];\n\t\tconst newTicks = [];\n\t\tif (numMajorIndices > ticksLimit) {\n\t\t\tskipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n\t\t\treturn newTicks;\n\t\t}\n\t\tconst spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\t\tif (numMajorIndices > 0) {\n\t\t\tlet i, ilen;\n\t\t\tconst avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n\t\t\tskip(ticks, newTicks, spacing, Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n\t\t\tfor (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n\t\t\t\tskip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n\t\t\t}\n\t\t\tskip(ticks, newTicks, spacing, last, Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n\t\t\treturn newTicks;\n\t\t}\n\t\tskip(ticks, newTicks, spacing);\n\t\treturn newTicks;\n\t}\n\t_tickSize() {\n\t\tconst me = this;\n\t\tconst optionTicks = me.options.ticks;\n\t\tconst rot = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(me.labelRotation);\n\t\tconst cos = Math.abs(Math.cos(rot));\n\t\tconst sin = Math.abs(Math.sin(rot));\n\t\tconst labelSizes = me._getLabelSizes();\n\t\tconst padding = optionTicks.autoSkipPadding || 0;\n\t\tconst w = labelSizes ? labelSizes.widest.width + padding : 0;\n\t\tconst h = labelSizes ? labelSizes.highest.height + padding : 0;\n\t\treturn me.isHorizontal()\n\t\t\t? h * cos > w * sin ? w / cos : h / sin\n\t\t\t: h * sin < w * cos ? h / cos : w / sin;\n\t}\n\t_isVisible() {\n\t\tconst display = this.options.display;\n\t\tif (display !== 'auto') {\n\t\t\treturn !!display;\n\t\t}\n\t\treturn this.getMatchingVisibleMetas().length > 0;\n\t}\n\t_computeGridLineItems(chartArea) {\n\t\tconst me = this;\n\t\tconst axis = me.axis;\n\t\tconst chart = me.chart;\n\t\tconst options = me.options;\n\t\tconst {gridLines, position} = options;\n\t\tconst offsetGridLines = gridLines.offsetGridLines;\n\t\tconst isHorizontal = me.isHorizontal();\n\t\tconst ticks = me.ticks;\n\t\tconst ticksLength = ticks.length + (offsetGridLines ? 1 : 0);\n\t\tconst tl = getTickMarkLength(gridLines);\n\t\tconst items = [];\n\t\tlet context = {\n\t\t\tchart,\n\t\t\tscale: me,\n\t\t\ttick: ticks[0],\n\t\t\tindex: 0,\n\t\t};\n\t\tconst axisWidth = gridLines.drawBorder ? Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.borderWidth, gridLines.lineWidth, 0], context, 0) : 0;\n\t\tconst axisHalfWidth = axisWidth / 2;\n\t\tconst alignBorderValue = function(pixel) {\n\t\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(chart, pixel, axisWidth);\n\t\t};\n\t\tlet borderValue, i, lineValue, alignedLineValue;\n\t\tlet tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\t\tif (position === 'top') {\n\t\t\tborderValue = alignBorderValue(me.bottom);\n\t\t\tty1 = me.bottom - tl;\n\t\t\tty2 = borderValue - axisHalfWidth;\n\t\t\ty1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n\t\t\ty2 = chartArea.bottom;\n\t\t} else if (position === 'bottom') {\n\t\t\tborderValue = alignBorderValue(me.top);\n\t\t\ty1 = chartArea.top;\n\t\t\ty2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n\t\t\tty1 = borderValue + axisHalfWidth;\n\t\t\tty2 = me.top + tl;\n\t\t} else if (position === 'left') {\n\t\t\tborderValue = alignBorderValue(me.right);\n\t\t\ttx1 = me.right - tl;\n\t\t\ttx2 = borderValue - axisHalfWidth;\n\t\t\tx1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n\t\t\tx2 = chartArea.right;\n\t\t} else if (position === 'right') {\n\t\t\tborderValue = alignBorderValue(me.left);\n\t\t\tx1 = chartArea.left;\n\t\t\tx2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n\t\t\ttx1 = borderValue + axisHalfWidth;\n\t\t\ttx2 = me.left + tl;\n\t\t} else if (axis === 'x') {\n\t\t\tif (position === 'center') {\n\t\t\t\tborderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2);\n\t\t\t} else if (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n\t\t\t\tconst positionAxisID = Object.keys(position)[0];\n\t\t\t\tconst value = position[positionAxisID];\n\t\t\t\tborderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\n\t\t\t}\n\t\t\ty1 = chartArea.top;\n\t\t\ty2 = chartArea.bottom;\n\t\t\tty1 = borderValue + axisHalfWidth;\n\t\t\tty2 = ty1 + tl;\n\t\t} else if (axis === 'y') {\n\t\t\tif (position === 'center') {\n\t\t\t\tborderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n\t\t\t} else if (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n\t\t\t\tconst positionAxisID = Object.keys(position)[0];\n\t\t\t\tconst value = position[positionAxisID];\n\t\t\t\tborderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\n\t\t\t}\n\t\t\ttx1 = borderValue - axisHalfWidth;\n\t\t\ttx2 = tx1 - tl;\n\t\t\tx1 = chartArea.left;\n\t\t\tx2 = chartArea.right;\n\t\t}\n\t\tfor (i = 0; i < ticksLength; ++i) {\n\t\t\tconst tick = ticks[i] || {};\n\t\t\tcontext = {\n\t\t\t\tchart,\n\t\t\t\tscale: me,\n\t\t\t\ttick,\n\t\t\t\tindex: i,\n\t\t\t};\n\t\t\tconst lineWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.lineWidth], context, i);\n\t\t\tconst lineColor = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.color], context, i);\n\t\t\tconst borderDash = gridLines.borderDash || [];\n\t\t\tconst borderDashOffset = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.borderDashOffset], context, i);\n\t\t\tlineValue = getPixelForGridLine(me, i, offsetGridLines);\n\t\t\tif (lineValue === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\talignedLineValue = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(chart, lineValue, lineWidth);\n\t\t\tif (isHorizontal) {\n\t\t\t\ttx1 = tx2 = x1 = x2 = alignedLineValue;\n\t\t\t} else {\n\t\t\t\tty1 = ty2 = y1 = y2 = alignedLineValue;\n\t\t\t}\n\t\t\titems.push({\n\t\t\t\ttx1,\n\t\t\t\tty1,\n\t\t\t\ttx2,\n\t\t\t\tty2,\n\t\t\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2,\n\t\t\t\twidth: lineWidth,\n\t\t\t\tcolor: lineColor,\n\t\t\t\tborderDash,\n\t\t\t\tborderDashOffset,\n\t\t\t});\n\t\t}\n\t\tme._ticksLength = ticksLength;\n\t\tme._borderValue = borderValue;\n\t\treturn items;\n\t}\n\t_computeLabelItems(chartArea) {\n\t\tconst me = this;\n\t\tconst axis = me.axis;\n\t\tconst options = me.options;\n\t\tconst {position, ticks: optionTicks} = options;\n\t\tconst isMirrored = optionTicks.mirror;\n\t\tconst isHorizontal = me.isHorizontal();\n\t\tconst ticks = me.ticks;\n\t\tconst tickPadding = optionTicks.padding;\n\t\tconst tl = getTickMarkLength(options.gridLines);\n\t\tconst rotation = -Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(me.labelRotation);\n\t\tconst items = [];\n\t\tlet i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n\t\tif (position === 'top') {\n\t\t\ty = me.bottom - tl - tickPadding;\n\t\t\ttextAlign = !rotation ? 'center' : 'left';\n\t\t} else if (position === 'bottom') {\n\t\t\ty = me.top + tl + tickPadding;\n\t\t\ttextAlign = !rotation ? 'center' : 'right';\n\t\t} else if (position === 'left') {\n\t\t\tx = me.right - (isMirrored ? 0 : tl) - tickPadding;\n\t\t\ttextAlign = isMirrored ? 'left' : 'right';\n\t\t} else if (position === 'right') {\n\t\t\tx = me.left + (isMirrored ? 0 : tl) + tickPadding;\n\t\t\ttextAlign = isMirrored ? 'right' : 'left';\n\t\t} else if (axis === 'x') {\n\t\t\tif (position === 'center') {\n\t\t\t\ty = ((chartArea.top + chartArea.bottom) / 2) + tl + tickPadding;\n\t\t\t} else if (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n\t\t\t\tconst positionAxisID = Object.keys(position)[0];\n\t\t\t\tconst value = position[positionAxisID];\n\t\t\t\ty = me.chart.scales[positionAxisID].getPixelForValue(value) + tl + tickPadding;\n\t\t\t}\n\t\t\ttextAlign = !rotation ? 'center' : 'right';\n\t\t} else if (axis === 'y') {\n\t\t\tif (position === 'center') {\n\t\t\t\tx = ((chartArea.left + chartArea.right) / 2) - tl - tickPadding;\n\t\t\t} else if (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n\t\t\t\tconst positionAxisID = Object.keys(position)[0];\n\t\t\t\tconst value = position[positionAxisID];\n\t\t\t\tx = me.chart.scales[positionAxisID].getPixelForValue(value);\n\t\t\t}\n\t\t\ttextAlign = 'right';\n\t\t}\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\ttick = ticks[i];\n\t\t\tlabel = tick.label;\n\t\t\tpixel = me.getPixelForTick(i) + optionTicks.labelOffset;\n\t\t\tfont = me._resolveTickFontOptions(i);\n\t\t\tlineHeight = font.lineHeight;\n\t\t\tlineCount = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label) ? label.length : 1;\n\t\t\tif (isHorizontal) {\n\t\t\t\tx = pixel;\n\t\t\t\tif (position === 'top') {\n\t\t\t\t\ttextOffset = (Math.sin(rotation) * (lineCount / 2) + 0.5) * lineHeight;\n\t\t\t\t\ttextOffset -= (rotation === 0 ? (lineCount - 0.5) : Math.cos(rotation) * (lineCount / 2)) * lineHeight;\n\t\t\t\t} else {\n\t\t\t\t\ttextOffset = Math.sin(rotation) * (lineCount / 2) * lineHeight;\n\t\t\t\t\ttextOffset += (rotation === 0 ? 0.5 : Math.cos(rotation) * (lineCount / 2)) * lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ty = pixel;\n\t\t\t\ttextOffset = (1 - lineCount) * lineHeight / 2;\n\t\t\t}\n\t\t\titems.push({\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\trotation,\n\t\t\t\tlabel,\n\t\t\t\tfont,\n\t\t\t\ttextOffset,\n\t\t\t\ttextAlign\n\t\t\t});\n\t\t}\n\t\treturn items;\n\t}\n\tdrawGrid(chartArea) {\n\t\tconst me = this;\n\t\tconst gridLines = me.options.gridLines;\n\t\tconst ctx = me.ctx;\n\t\tconst chart = me.chart;\n\t\tlet context = {\n\t\t\tchart,\n\t\t\tscale: me,\n\t\t\ttick: me.ticks[0],\n\t\t\tindex: 0,\n\t\t};\n\t\tconst axisWidth = gridLines.drawBorder ? Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.borderWidth, gridLines.lineWidth, 0], context, 0) : 0;\n\t\tconst items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\n\t\tlet i, ilen;\n\t\tif (gridLines.display) {\n\t\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t\t\tconst item = items[i];\n\t\t\t\tconst width = item.width;\n\t\t\t\tconst color = item.color;\n\t\t\t\tif (width && color) {\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.lineWidth = width;\n\t\t\t\t\tctx.strokeStyle = color;\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\tctx.setLineDash(item.borderDash);\n\t\t\t\t\t\tctx.lineDashOffset = item.borderDashOffset;\n\t\t\t\t\t}\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tctx.moveTo(item.tx1, item.ty1);\n\t\t\t\t\t\tctx.lineTo(item.tx2, item.ty2);\n\t\t\t\t\t}\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tctx.moveTo(item.x1, item.y1);\n\t\t\t\t\t\tctx.lineTo(item.x2, item.y2);\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (axisWidth) {\n\t\t\tconst firstLineWidth = axisWidth;\n\t\t\tcontext = {\n\t\t\t\tchart,\n\t\t\t\tscale: me,\n\t\t\t\ttick: me.ticks[me._ticksLength - 1],\n\t\t\t\tindex: me._ticksLength - 1,\n\t\t\t};\n\t\t\tconst lastLineWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.lineWidth, 1], context, me._ticksLength - 1);\n\t\t\tconst borderValue = me._borderValue;\n\t\t\tlet x1, x2, y1, y2;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tx1 = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n\t\t\t\tx2 = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n\t\t\t\ty1 = y2 = borderValue;\n\t\t\t} else {\n\t\t\t\ty1 = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n\t\t\t\ty2 = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n\t\t\t\tx1 = x2 = borderValue;\n\t\t\t}\n\t\t\tctx.lineWidth = axisWidth;\n\t\t\tctx.strokeStyle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLines.borderColor, gridLines.color], context, 0);\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x1, y1);\n\t\t\tctx.lineTo(x2, y2);\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\tdrawLabels(chartArea) {\n\t\tconst me = this;\n\t\tconst optionTicks = me.options.ticks;\n\t\tif (!optionTicks.display) {\n\t\t\treturn;\n\t\t}\n\t\tconst ctx = me.ctx;\n\t\tconst items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));\n\t\tlet i, j, ilen, jlen;\n\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t\tconst item = items[i];\n\t\t\tconst tickFont = item.font;\n\t\t\tconst useStroke = tickFont.lineWidth > 0 && tickFont.strokeStyle !== '';\n\t\t\tctx.save();\n\t\t\tctx.translate(item.x, item.y);\n\t\t\tctx.rotate(item.rotation);\n\t\t\tctx.font = tickFont.string;\n\t\t\tctx.fillStyle = tickFont.color;\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.textAlign = item.textAlign;\n\t\t\tif (useStroke) {\n\t\t\t\tctx.strokeStyle = tickFont.strokeStyle;\n\t\t\t\tctx.lineWidth = tickFont.lineWidth;\n\t\t\t}\n\t\t\tconst label = item.label;\n\t\t\tlet y = item.textOffset;\n\t\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label)) {\n\t\t\t\tfor (j = 0, jlen = label.length; j < jlen; ++j) {\n\t\t\t\t\tif (useStroke) {\n\t\t\t\t\t\tctx.strokeText('' + label[j], 0, y);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillText('' + label[j], 0, y);\n\t\t\t\t\ty += tickFont.lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (useStroke) {\n\t\t\t\t\tctx.strokeText(label, 0, y);\n\t\t\t\t}\n\t\t\t\tctx.fillText(label, 0, y);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n\tdrawTitle(chartArea) {\n\t\tconst me = this;\n\t\tconst ctx = me.ctx;\n\t\tconst options = me.options;\n\t\tconst scaleLabel = options.scaleLabel;\n\t\tif (!scaleLabel.display) {\n\t\t\treturn;\n\t\t}\n\t\tconst scaleLabelFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(scaleLabel.font, me.chart.options.font);\n\t\tconst scaleLabelPadding = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(scaleLabel.padding);\n\t\tconst halfLineHeight = scaleLabelFont.lineHeight / 2;\n\t\tconst scaleLabelAlign = scaleLabel.align;\n\t\tconst position = options.position;\n\t\tconst isReverse = me.options.reverse;\n\t\tlet rotation = 0;\n\t\tlet textAlign;\n\t\tlet scaleLabelX, scaleLabelY;\n\t\tif (me.isHorizontal()) {\n\t\t\tswitch (scaleLabelAlign) {\n\t\t\tcase 'start':\n\t\t\t\tscaleLabelX = me.left + (isReverse ? me.width : 0);\n\t\t\t\ttextAlign = isReverse ? 'right' : 'left';\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\tscaleLabelX = me.left + (isReverse ? 0 : me.width);\n\t\t\t\ttextAlign = isReverse ? 'left' : 'right';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tscaleLabelX = me.left + me.width / 2;\n\t\t\t\ttextAlign = 'center';\n\t\t\t}\n\t\t\tscaleLabelY = position === 'top'\n\t\t\t\t? me.top + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t: me.bottom - halfLineHeight - scaleLabelPadding.bottom;\n\t\t} else {\n\t\t\tconst isLeft = position === 'left';\n\t\t\tscaleLabelX = isLeft\n\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\tswitch (scaleLabelAlign) {\n\t\t\tcase 'start':\n\t\t\t\tscaleLabelY = me.top + (isReverse ? 0 : me.height);\n\t\t\t\ttextAlign = isReverse === isLeft ? 'right' : 'left';\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\tscaleLabelY = me.top + (isReverse ? me.height : 0);\n\t\t\t\ttextAlign = isReverse === isLeft ? 'left' : 'right';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tscaleLabelY = me.top + me.height / 2;\n\t\t\t\ttextAlign = 'center';\n\t\t\t}\n\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t}\n\t\tctx.save();\n\t\tctx.translate(scaleLabelX, scaleLabelY);\n\t\tctx.rotate(rotation);\n\t\tctx.textAlign = textAlign;\n\t\tctx.textBaseline = 'middle';\n\t\tctx.fillStyle = scaleLabelFont.color;\n\t\tctx.font = scaleLabelFont.string;\n\t\tctx.fillText(scaleLabel.labelString, 0, 0);\n\t\tctx.restore();\n\t}\n\tdraw(chartArea) {\n\t\tconst me = this;\n\t\tif (!me._isVisible()) {\n\t\t\treturn;\n\t\t}\n\t\tme.drawGrid(chartArea);\n\t\tme.drawTitle();\n\t\tme.drawLabels(chartArea);\n\t}\n\t_layers() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst tz = opts.ticks && opts.ticks.z || 0;\n\t\tconst gz = opts.gridLines && opts.gridLines.z || 0;\n\t\tif (!me._isVisible() || tz === gz || me.draw !== me._draw) {\n\t\t\treturn [{\n\t\t\t\tz: tz,\n\t\t\t\tdraw(chartArea) {\n\t\t\t\t\tme.draw(chartArea);\n\t\t\t\t}\n\t\t\t}];\n\t\t}\n\t\treturn [{\n\t\t\tz: gz,\n\t\t\tdraw(chartArea) {\n\t\t\t\tme.drawGrid(chartArea);\n\t\t\t\tme.drawTitle();\n\t\t\t}\n\t\t}, {\n\t\t\tz: tz,\n\t\t\tdraw(chartArea) {\n\t\t\t\tme.drawLabels(chartArea);\n\t\t\t}\n\t\t}];\n\t}\n\tgetMatchingVisibleMetas(type) {\n\t\tconst me = this;\n\t\tconst metas = me.chart.getSortedVisibleDatasetMetas();\n\t\tconst axisID = me.axis + 'AxisID';\n\t\tconst result = [];\n\t\tlet i, ilen;\n\t\tfor (i = 0, ilen = metas.length; i < ilen; ++i) {\n\t\t\tconst meta = metas[i];\n\t\t\tif (meta[axisID] === me.id && (!type || meta.type === type)) {\n\t\t\t\tresult.push(meta);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t_resolveTickFontOptions(index) {\n\t\tconst me = this;\n\t\tconst chart = me.chart;\n\t\tconst options = me.options.ticks;\n\t\tconst ticks = me.ticks || [];\n\t\tconst context = {\n\t\t\tchart,\n\t\t\tscale: me,\n\t\t\ttick: ticks[index],\n\t\t\tindex\n\t\t};\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([options.font], context), chart.options.font);\n\t}\n}\nScale.prototype._draw = Scale.prototype.draw;\n\nclass TypedRegistry {\n\tconstructor(type, scope) {\n\t\tthis.type = type;\n\t\tthis.scope = scope;\n\t\tthis.items = Object.create(null);\n\t}\n\tisForType(type) {\n\t\treturn Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n\t}\n\tregister(item) {\n\t\tconst proto = Object.getPrototypeOf(item);\n\t\tlet parentScope;\n\t\tif (isIChartComponent(proto)) {\n\t\t\tparentScope = this.register(proto);\n\t\t}\n\t\tconst items = this.items;\n\t\tconst id = item.id;\n\t\tconst baseScope = this.scope;\n\t\tconst scope = baseScope ? baseScope + '.' + id : id;\n\t\tif (!id) {\n\t\t\tthrow new Error('class does not have id: ' + item);\n\t\t}\n\t\tif (id in items) {\n\t\t\treturn scope;\n\t\t}\n\t\tif (Object.keys(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].get(scope)).length) {\n\t\t\tthrow new Error('Can not register \"' + id + '\", because \"defaults.' + scope + '\" would collide with existing defaults');\n\t\t}\n\t\titems[id] = item;\n\t\tregisterDefaults(item, scope, parentScope);\n\t\treturn scope;\n\t}\n\tget(id) {\n\t\treturn this.items[id];\n\t}\n\tunregister(item) {\n\t\tconst items = this.items;\n\t\tconst id = item.id;\n\t\tconst scope = this.scope;\n\t\tif (id in items) {\n\t\t\tdelete items[id];\n\t\t}\n\t\tif (scope && id in _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][scope]) {\n\t\t\tdelete _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][scope][id];\n\t\t} else if (id in _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"]) {\n\t\t\tdelete _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][id];\n\t\t}\n\t}\n}\nfunction registerDefaults(item, scope, parentScope) {\n\tconst itemDefaults = parentScope\n\t\t? Object.assign({}, _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].get(parentScope), item.defaults)\n\t\t: item.defaults;\n\t_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set(scope, itemDefaults);\n\tif (item.defaultRoutes) {\n\t\trouteDefaults(scope, item.defaultRoutes);\n\t}\n}\nfunction routeDefaults(scope, routes) {\n\tObject.keys(routes).forEach(property => {\n\t\tconst parts = routes[property].split('.');\n\t\tconst targetName = parts.pop();\n\t\tconst targetScope = parts.join('.');\n\t\t_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].route(scope, property, targetScope, targetName);\n\t});\n}\nfunction isIChartComponent(proto) {\n\treturn 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n\tconstructor() {\n\t\tthis.controllers = new TypedRegistry(DatasetController, '');\n\t\tthis.elements = new TypedRegistry(Element, 'elements');\n\t\tthis.plugins = new TypedRegistry(Object, 'plugins');\n\t\tthis.scales = new TypedRegistry(Scale, 'scales');\n\t\tthis._typedRegistries = [this.controllers, this.scales, this.elements];\n\t}\n\tadd(...args) {\n\t\tthis._each('register', args);\n\t}\n\tremove(...args) {\n\t\tthis._each('unregister', args);\n\t}\n\taddControllers(...args) {\n\t\tthis._each('register', args, this.controllers);\n\t}\n\taddElements(...args) {\n\t\tthis._each('register', args, this.elements);\n\t}\n\taddPlugins(...args) {\n\t\tthis._each('register', args, this.plugins);\n\t}\n\taddScales(...args) {\n\t\tthis._each('register', args, this.scales);\n\t}\n\tgetController(id) {\n\t\treturn this._get(id, this.controllers, 'controller');\n\t}\n\tgetElement(id) {\n\t\treturn this._get(id, this.elements, 'element');\n\t}\n\tgetPlugin(id) {\n\t\treturn this._get(id, this.plugins, 'plugin');\n\t}\n\tgetScale(id) {\n\t\treturn this._get(id, this.scales, 'scale');\n\t}\n\tremoveControllers(...args) {\n\t\tthis._each('unregister', args, this.controllers);\n\t}\n\tremoveElements(...args) {\n\t\tthis._each('unregister', args, this.elements);\n\t}\n\tremovePlugins(...args) {\n\t\tthis._each('unregister', args, this.plugins);\n\t}\n\tremoveScales(...args) {\n\t\tthis._each('unregister', args, this.scales);\n\t}\n\t_each(method, args, typedRegistry) {\n\t\tconst me = this;\n\t\t[...args].forEach(arg => {\n\t\t\tconst reg = typedRegistry || me._getRegistryForType(arg);\n\t\t\tif (typedRegistry || reg.isForType(arg) || (reg === me.plugins && arg.id)) {\n\t\t\t\tme._exec(method, reg, arg);\n\t\t\t} else {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(arg, item => {\n\t\t\t\t\tconst itemReg = typedRegistry || me._getRegistryForType(item);\n\t\t\t\t\tme._exec(method, itemReg, item);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\t_exec(method, registry, component) {\n\t\tconst camelMethod = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])(method);\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(component['before' + camelMethod], [], component);\n\t\tregistry[method](component);\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(component['after' + camelMethod], [], component);\n\t}\n\t_getRegistryForType(type) {\n\t\tfor (let i = 0; i < this._typedRegistries.length; i++) {\n\t\t\tconst reg = this._typedRegistries[i];\n\t\t\tif (reg.isForType(type)) {\n\t\t\t\treturn reg;\n\t\t\t}\n\t\t}\n\t\treturn this.plugins;\n\t}\n\t_get(id, typedRegistry, type) {\n\t\tconst item = typedRegistry.get(id);\n\t\tif (item === undefined) {\n\t\t\tthrow new Error('\"' + id + '\" is not a registered ' + type + '.');\n\t\t}\n\t\treturn item;\n\t}\n}\nvar registry = new Registry();\n\nclass PluginService {\n\tnotify(chart, hook, args) {\n\t\tconst descriptors = this._descriptors(chart);\n\t\tfor (let i = 0; i < descriptors.length; ++i) {\n\t\t\tconst descriptor = descriptors[i];\n\t\t\tconst plugin = descriptor.plugin;\n\t\t\tconst method = plugin[hook];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tconst params = [chart].concat(args || []);\n\t\t\t\tparams.push(descriptor.options);\n\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tinvalidate() {\n\t\tthis._cache = undefined;\n\t}\n\t_descriptors(chart) {\n\t\tif (this._cache) {\n\t\t\treturn this._cache;\n\t\t}\n\t\tconst config = (chart && chart.config) || {};\n\t\tconst options = (config.options && config.options.plugins) || {};\n\t\tconst plugins = allPlugins(config);\n\t\tconst descriptors = createDescriptors(plugins, options);\n\t\tthis._cache = descriptors;\n\t\treturn descriptors;\n\t}\n}\nfunction allPlugins(config) {\n\tconst plugins = [];\n\tconst keys = Object.keys(registry.plugins.items);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tplugins.push(registry.getPlugin(keys[i]));\n\t}\n\tconst local = config.plugins || [];\n\tfor (let i = 0; i < local.length; i++) {\n\t\tconst plugin = local[i];\n\t\tif (plugins.indexOf(plugin) === -1) {\n\t\t\tplugins.push(plugin);\n\t\t}\n\t}\n\treturn plugins;\n}\nfunction createDescriptors(plugins, options) {\n\tconst result = [];\n\tfor (let i = 0; i < plugins.length; i++) {\n\t\tconst plugin = plugins[i];\n\t\tconst id = plugin.id;\n\t\tlet opts = options[id];\n\t\tif (opts === false) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (opts === true) {\n\t\t\topts = {};\n\t\t}\n\t\tresult.push({\n\t\t\tplugin,\n\t\t\toptions: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])({}, [opts, _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].plugins[id]])\n\t\t});\n\t}\n\treturn result;\n}\n\nvar version = \"3.0.0-beta.3\";\n\nfunction getIndexAxis(type, options) {\n\tconst typeDefaults = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][type] || {};\n\tconst datasetDefaults = typeDefaults.datasets || {};\n\tconst typeOptions = options[type] || {};\n\tconst datasetOptions = typeOptions.datasets || {};\n\treturn datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n\tlet axis = id;\n\tif (id === '_index_') {\n\t\taxis = indexAxis;\n\t} else if (id === '_value_') {\n\t\taxis = indexAxis === 'x' ? 'y' : 'x';\n\t}\n\treturn axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n\treturn axis === indexAxis ? '_index_' : '_value_';\n}\nfunction mergeScaleConfig(config, options) {\n\toptions = options || {};\n\tconst chartDefaults = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][config.type] || {scales: {}};\n\tconst configScales = options.scales || {};\n\tconst chartIndexAxis = getIndexAxis(config.type, options);\n\tconst firstIDs = {};\n\tconst scales = {};\n\tObject.keys(configScales).forEach(id => {\n\t\tconst scaleConf = configScales[id];\n\t\tconst axis = determineAxis(id, scaleConf);\n\t\tconst defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n\t\tfirstIDs[axis] = firstIDs[axis] || id;\n\t\tscales[id] = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])({axis}, [scaleConf, chartDefaults.scales[axis], chartDefaults.scales[defaultId]]);\n\t});\n\tif (options.scale) {\n\t\tscales[options.scale.id || 'r'] = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])({axis: 'r'}, [options.scale, chartDefaults.scales.r]);\n\t\tfirstIDs.r = firstIDs.r || options.scale.id || 'r';\n\t}\n\tconfig.data.datasets.forEach(dataset => {\n\t\tconst type = dataset.type || config.type;\n\t\tconst indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n\t\tconst datasetDefaults = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][type] || {};\n\t\tconst defaultScaleOptions = datasetDefaults.scales || {};\n\t\tObject.keys(defaultScaleOptions).forEach(defaultID => {\n\t\t\tconst axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n\t\t\tconst id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n\t\t\tscales[id] = scales[id] || {};\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n\t\t});\n\t});\n\tObject.keys(scales).forEach(key => {\n\t\tconst scale = scales[key];\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(scale, [_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].scales[scale.type], _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].scale]);\n\t});\n\treturn scales;\n}\nfunction mergeConfig(...args) {\n\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({}, args, {\n\t\tmerger(key, target, source, options) {\n\t\t\tif (key !== 'scales' && key !== 'scale') {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(key, target, source, options);\n\t\t\t}\n\t\t}\n\t});\n}\nfunction initConfig(config) {\n\tconfig = config || {};\n\tconst data = config.data = config.data || {datasets: [], labels: []};\n\tdata.datasets = data.datasets || [];\n\tdata.labels = data.labels || [];\n\tconst scaleConfig = mergeScaleConfig(config, config.options);\n\tconst options = config.options = mergeConfig(\n\t\t_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"],\n\t\t_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][config.type],\n\t\tconfig.options || {});\n\toptions.scales = scaleConfig;\n\toptions.title = (options.title !== false) && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({}, [_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].plugins.title, options.title]);\n\toptions.tooltips = (options.tooltips !== false) && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({}, [_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].plugins.tooltip, options.tooltips]);\n\treturn config;\n}\nfunction isAnimationDisabled(config) {\n\treturn !config.animation;\n}\nfunction updateConfig(chart) {\n\tlet newOptions = chart.options;\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(chart.scales, (scale) => {\n\t\tlayouts.removeBox(chart, scale);\n\t});\n\tconst scaleConfig = mergeScaleConfig(chart.config, newOptions);\n\tnewOptions = mergeConfig(\n\t\t_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"],\n\t\t_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][chart.config.type],\n\t\tnewOptions);\n\tchart.options = chart.config.options = newOptions;\n\tchart.options.scales = scaleConfig;\n\tchart._animationsDisabled = isAnimationDisabled(newOptions);\n}\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n\treturn position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction axisFromPosition(position) {\n\tif (position === 'top' || position === 'bottom') {\n\t\treturn 'x';\n\t}\n\tif (position === 'left' || position === 'right') {\n\t\treturn 'y';\n\t}\n}\nfunction determineAxis(id, scaleOptions) {\n\tif (id === 'x' || id === 'y' || id === 'r') {\n\t\treturn id;\n\t}\n\treturn scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction compare2Level(l1, l2) {\n\treturn function(a, b) {\n\t\treturn a[l1] === b[l1]\n\t\t\t? a[l2] - b[l2]\n\t\t\t: a[l1] - b[l1];\n\t};\n}\nfunction onAnimationsComplete(context) {\n\tconst chart = context.chart;\n\tconst animationOptions = chart.options.animation;\n\tchart._plugins.notify(chart, 'afterRender');\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n\tconst chart = context.chart;\n\tconst animationOptions = chart.options.animation;\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction isDomSupported() {\n\treturn typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction getCanvas(item) {\n\tif (isDomSupported() && typeof item === 'string') {\n\t\titem = document.getElementById(item);\n\t} else if (item && item.length) {\n\t\titem = item[0];\n\t}\n\tif (item && item.canvas) {\n\t\titem = item.canvas;\n\t}\n\treturn item;\n}\nclass Chart {\n\tconstructor(item, config) {\n\t\tconst me = this;\n\t\tconfig = initConfig(config);\n\t\tconst initialCanvas = getCanvas(item);\n\t\tthis.platform = me._initializePlatform(initialCanvas, config);\n\t\tconst context = me.platform.acquireContext(initialCanvas, config);\n\t\tconst canvas = context && context.canvas;\n\t\tconst height = canvas && canvas.height;\n\t\tconst width = canvas && canvas.width;\n\t\tthis.id = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"R\"])();\n\t\tthis.ctx = context;\n\t\tthis.canvas = canvas;\n\t\tthis.config = config;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.aspectRatio = height ? width / height : null;\n\t\tthis.options = config.options;\n\t\tthis._bufferedRender = false;\n\t\tthis._layers = [];\n\t\tthis._metasets = [];\n\t\tthis.boxes = [];\n\t\tthis.currentDevicePixelRatio = undefined;\n\t\tthis.chartArea = undefined;\n\t\tthis.data = undefined;\n\t\tthis._active = [];\n\t\tthis._lastEvent = undefined;\n\t\tthis._listeners = {};\n\t\tthis._sortedMetasets = [];\n\t\tthis._updating = false;\n\t\tthis.scales = {};\n\t\tthis.scale = undefined;\n\t\tthis._plugins = new PluginService();\n\t\tthis.$proxies = {};\n\t\tthis._hiddenIndices = {};\n\t\tthis.attached = false;\n\t\tChart.instances[me.id] = me;\n\t\tObject.defineProperty(me, 'data', {\n\t\t\tget() {\n\t\t\t\treturn me.config.data;\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tme.config.data = value;\n\t\t\t}\n\t\t});\n\t\tif (!context || !canvas) {\n\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\treturn;\n\t\t}\n\t\tanimator.listen(me, 'complete', onAnimationsComplete);\n\t\tanimator.listen(me, 'progress', onAnimationProgress);\n\t\tme._initialize();\n\t\tif (me.attached) {\n\t\t\tme.update();\n\t\t}\n\t}\n\t_initialize() {\n\t\tconst me = this;\n\t\tme._plugins.notify(me, 'beforeInit');\n\t\tif (me.options.responsive) {\n\t\t\tme.resize(true);\n\t\t} else {\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(me, me.options.devicePixelRatio);\n\t\t}\n\t\tme.bindEvents();\n\t\tme._plugins.notify(me, 'afterInit');\n\t\treturn me;\n\t}\n\t_initializePlatform(canvas, config) {\n\t\tif (config.platform) {\n\t\t\treturn new config.platform();\n\t\t} else if (!isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n\t\t\treturn new BasicPlatform();\n\t\t}\n\t\treturn new DomPlatform();\n\t}\n\tclear() {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"T\"])(this);\n\t\treturn this;\n\t}\n\tstop() {\n\t\tanimator.stop(this);\n\t\treturn this;\n\t}\n\tresize(silent, width, height) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst canvas = me.canvas;\n\t\tconst aspectRatio = options.maintainAspectRatio && me.aspectRatio;\n\t\tconst newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);\n\t\tconst oldRatio = me.currentDevicePixelRatio;\n\t\tconst newRatio = options.devicePixelRatio || me.platform.getDevicePixelRatio();\n\t\tif (me.width === newSize.width && me.height === newSize.height && oldRatio === newRatio) {\n\t\t\treturn;\n\t\t}\n\t\tcanvas.width = me.width = newSize.width;\n\t\tcanvas.height = me.height = newSize.height;\n\t\tif (canvas.style) {\n\t\t\tcanvas.style.width = newSize.width + 'px';\n\t\t\tcanvas.style.height = newSize.height + 'px';\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(me, newRatio);\n\t\tif (!silent) {\n\t\t\tme._plugins.notify(me, 'resize', [newSize]);\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.onResize, [newSize], me);\n\t\t\tif (me.attached) {\n\t\t\t\tme.update('resize');\n\t\t\t}\n\t\t}\n\t}\n\tensureScalesHaveIDs() {\n\t\tconst options = this.options;\n\t\tconst scalesOptions = options.scales || {};\n\t\tconst scaleOptions = options.scale;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(scalesOptions, (axisOptions, axisID) => {\n\t\t\taxisOptions.id = axisID;\n\t\t});\n\t\tif (scaleOptions) {\n\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t}\n\t}\n\tbuildOrUpdateScales() {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst scaleOpts = options.scales;\n\t\tconst scales = me.scales || {};\n\t\tconst updated = Object.keys(scales).reduce((obj, id) => {\n\t\t\tobj[id] = false;\n\t\t\treturn obj;\n\t\t}, {});\n\t\tlet items = [];\n\t\tif (scaleOpts) {\n\t\t\titems = items.concat(\n\t\t\t\tObject.keys(scaleOpts).map((id) => {\n\t\t\t\t\tconst scaleOptions = scaleOpts[id];\n\t\t\t\t\tconst axis = determineAxis(id, scaleOptions);\n\t\t\t\t\tconst isRadial = axis === 'r';\n\t\t\t\t\tconst isHorizontal = axis === 'x';\n\t\t\t\t\treturn {\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tdposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n\t\t\t\t\t\tdtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(items, (item) => {\n\t\t\tconst scaleOptions = item.options;\n\t\t\tconst id = scaleOptions.id;\n\t\t\tconst axis = determineAxis(id, scaleOptions);\n\t\t\tconst scaleType = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(scaleOptions.type, item.dtype);\n\t\t\tif (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t}\n\t\t\tupdated[id] = true;\n\t\t\tlet scale = null;\n\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\tscale = scales[id];\n\t\t\t} else {\n\t\t\t\tconst scaleClass = registry.getScale(scaleType);\n\t\t\t\tscale = new scaleClass({\n\t\t\t\t\tid,\n\t\t\t\t\ttype: scaleType,\n\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\tchart: me\n\t\t\t\t});\n\t\t\t\tscales[scale.id] = scale;\n\t\t\t}\n\t\t\tscale.init(scaleOptions, options);\n\t\t\tif (item.isDefault) {\n\t\t\t\tme.scale = scale;\n\t\t\t}\n\t\t});\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(updated, (hasUpdated, id) => {\n\t\t\tif (!hasUpdated) {\n\t\t\t\tdelete scales[id];\n\t\t\t}\n\t\t});\n\t\tme.scales = scales;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(scales, (scale) => {\n\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\tscale.position = scale.options.position;\n\t\t\tscale.weight = scale.options.weight;\n\t\t\tlayouts.addBox(me, scale);\n\t\t});\n\t}\n\t_updateMetasetIndex(meta, index) {\n\t\tconst metasets = this._metasets;\n\t\tconst oldIndex = meta.index;\n\t\tif (oldIndex !== index) {\n\t\t\tmetasets[oldIndex] = metasets[index];\n\t\t\tmetasets[index] = meta;\n\t\t\tmeta.index = index;\n\t\t}\n\t}\n\t_updateMetasets() {\n\t\tconst me = this;\n\t\tconst metasets = me._metasets;\n\t\tconst numData = me.data.datasets.length;\n\t\tconst numMeta = metasets.length;\n\t\tif (numMeta > numData) {\n\t\t\tfor (let i = numData; i < numMeta; ++i) {\n\t\t\t\tme._destroyDatasetMeta(i);\n\t\t\t}\n\t\t\tmetasets.splice(numData, numMeta - numData);\n\t\t}\n\t\tme._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n\t}\n\tbuildOrUpdateControllers() {\n\t\tconst me = this;\n\t\tconst newControllers = [];\n\t\tconst datasets = me.data.datasets;\n\t\tlet i, ilen;\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; i++) {\n\t\t\tconst dataset = datasets[i];\n\t\t\tlet meta = me.getDatasetMeta(i);\n\t\t\tconst type = dataset.type || me.config.type;\n\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\tme._destroyDatasetMeta(i);\n\t\t\t\tmeta = me.getDatasetMeta(i);\n\t\t\t}\n\t\t\tmeta.type = type;\n\t\t\tmeta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);\n\t\t\tmeta.order = dataset.order || 0;\n\t\t\tme._updateMetasetIndex(meta, i);\n\t\t\tmeta.label = '' + dataset.label;\n\t\t\tmeta.visible = me.isDatasetVisible(i);\n\t\t\tif (meta.controller) {\n\t\t\t\tmeta.controller.updateIndex(i);\n\t\t\t\tmeta.controller.linkScales();\n\t\t\t} else {\n\t\t\t\tconst controllerDefaults = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"][type];\n\t\t\t\tconst ControllerClass = registry.getController(type);\n\t\t\t\tObject.assign(ControllerClass.prototype, {\n\t\t\t\t\tdataElementType: registry.getElement(controllerDefaults.dataElementType),\n\t\t\t\t\tdatasetElementType: controllerDefaults.datasetElementType && registry.getElement(controllerDefaults.datasetElementType),\n\t\t\t\t\tdataElementOptions: controllerDefaults.dataElementOptions,\n\t\t\t\t\tdatasetElementOptions: controllerDefaults.datasetElementOptions\n\t\t\t\t});\n\t\t\t\tmeta.controller = new ControllerClass(me, i);\n\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t}\n\t\t}\n\t\tme._updateMetasets();\n\t\treturn newControllers;\n\t}\n\t_resetElements() {\n\t\tconst me = this;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(me.data.datasets, (dataset, datasetIndex) => {\n\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t}, me);\n\t}\n\treset() {\n\t\tthis._resetElements();\n\t\tthis._plugins.notify(this, 'reset');\n\t}\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tlet i, ilen;\n\t\tme._updating = true;\n\t\tupdateConfig(me);\n\t\tme.ensureScalesHaveIDs();\n\t\tme.buildOrUpdateScales();\n\t\tme._plugins.invalidate();\n\t\tif (me._plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\treturn;\n\t\t}\n\t\tconst newControllers = me.buildOrUpdateControllers();\n\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\n\t\t\tme.getDatasetMeta(i).controller.buildOrUpdateElements();\n\t\t}\n\t\tme._updateLayout();\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(newControllers, (controller) => {\n\t\t\tcontroller.reset();\n\t\t});\n\t\tme._updateDatasets(mode);\n\t\tme._plugins.notify(me, 'afterUpdate');\n\t\tme._layers.sort(compare2Level('z', '_idx'));\n\t\tif (me._lastEvent) {\n\t\t\tme._eventHandler(me._lastEvent, true);\n\t\t}\n\t\tme.render();\n\t\tme._updating = false;\n\t}\n\t_updateLayout() {\n\t\tconst me = this;\n\t\tif (me._plugins.notify(me, 'beforeLayout') === false) {\n\t\t\treturn;\n\t\t}\n\t\tlayouts.update(me, me.width, me.height);\n\t\tme._layers = [];\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(me.boxes, (box) => {\n\t\t\tif (box.configure) {\n\t\t\t\tbox.configure();\n\t\t\t}\n\t\t\tme._layers.push(...box._layers());\n\t\t}, me);\n\t\tme._layers.forEach((item, index) => {\n\t\t\titem._idx = index;\n\t\t});\n\t\tme._plugins.notify(me, 'afterLayout');\n\t}\n\t_updateDatasets(mode) {\n\t\tconst me = this;\n\t\tconst isFunction = typeof mode === 'function';\n\t\tif (me._plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\tme._updateDataset(i, isFunction ? mode({datasetIndex: i}) : mode);\n\t\t}\n\t\tme._plugins.notify(me, 'afterDatasetsUpdate');\n\t}\n\t_updateDataset(index, mode) {\n\t\tconst me = this;\n\t\tconst meta = me.getDatasetMeta(index);\n\t\tconst args = {meta, index, mode};\n\t\tif (me._plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\treturn;\n\t\t}\n\t\tmeta.controller._update(mode);\n\t\tme._plugins.notify(me, 'afterDatasetUpdate', [args]);\n\t}\n\trender() {\n\t\tconst me = this;\n\t\tif (me._plugins.notify(me, 'beforeRender') === false) {\n\t\t\treturn;\n\t\t}\n\t\tif (animator.has(me)) {\n\t\t\tif (me.attached && !animator.running(me)) {\n\t\t\t\tanimator.start(me);\n\t\t\t}\n\t\t} else {\n\t\t\tme.draw();\n\t\t\tonAnimationsComplete({chart: me});\n\t\t}\n\t}\n\tdraw() {\n\t\tconst me = this;\n\t\tlet i;\n\t\tme.clear();\n\t\tif (me.width <= 0 || me.height <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (me._plugins.notify(me, 'beforeDraw') === false) {\n\t\t\treturn;\n\t\t}\n\t\tconst layers = me._layers;\n\t\tfor (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n\t\t\tlayers[i].draw(me.chartArea);\n\t\t}\n\t\tme._drawDatasets();\n\t\tfor (; i < layers.length; ++i) {\n\t\t\tlayers[i].draw(me.chartArea);\n\t\t}\n\t\tme._plugins.notify(me, 'afterDraw');\n\t}\n\t_getSortedDatasetMetas(filterVisible) {\n\t\tconst me = this;\n\t\tconst metasets = me._sortedMetasets;\n\t\tconst result = [];\n\t\tlet i, ilen;\n\t\tfor (i = 0, ilen = metasets.length; i < ilen; ++i) {\n\t\t\tconst meta = metasets[i];\n\t\t\tif (!filterVisible || meta.visible) {\n\t\t\t\tresult.push(meta);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tgetSortedVisibleDatasetMetas() {\n\t\treturn this._getSortedDatasetMetas(true);\n\t}\n\t_drawDatasets() {\n\t\tconst me = this;\n\t\tif (me._plugins.notify(me, 'beforeDatasetsDraw') === false) {\n\t\t\treturn;\n\t\t}\n\t\tconst metasets = me.getSortedVisibleDatasetMetas();\n\t\tfor (let i = metasets.length - 1; i >= 0; --i) {\n\t\t\tme._drawDataset(metasets[i]);\n\t\t}\n\t\tme._plugins.notify(me, 'afterDatasetsDraw');\n\t}\n\t_drawDataset(meta) {\n\t\tconst me = this;\n\t\tconst ctx = me.ctx;\n\t\tconst clip = meta._clip;\n\t\tconst area = me.chartArea;\n\t\tconst args = {\n\t\t\tmeta,\n\t\t\tindex: meta.index,\n\t\t};\n\t\tif (me._plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\treturn;\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(ctx, {\n\t\t\tleft: clip.left === false ? 0 : area.left - clip.left,\n\t\t\tright: clip.right === false ? me.width : area.right + clip.right,\n\t\t\ttop: clip.top === false ? 0 : area.top - clip.top,\n\t\t\tbottom: clip.bottom === false ? me.height : area.bottom + clip.bottom\n\t\t});\n\t\tmeta.controller.draw();\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(ctx);\n\t\tme._plugins.notify(me, 'afterDatasetDraw', [args]);\n\t}\n\tgetElementAtEvent(e) {\n\t\treturn Interaction.modes.nearest(this, e, {intersect: true});\n\t}\n\tgetElementsAtEvent(e) {\n\t\treturn Interaction.modes.index(this, e, {intersect: true});\n\t}\n\tgetElementsAtXAxis(e) {\n\t\treturn Interaction.modes.index(this, e, {intersect: false});\n\t}\n\tgetElementsAtEventForMode(e, mode, options, useFinalPosition) {\n\t\tconst method = Interaction.modes[mode];\n\t\tif (typeof method === 'function') {\n\t\t\treturn method(this, e, options, useFinalPosition);\n\t\t}\n\t\treturn [];\n\t}\n\tgetDatasetAtEvent(e) {\n\t\treturn Interaction.modes.dataset(this, e, {intersect: true});\n\t}\n\tgetDatasetMeta(datasetIndex) {\n\t\tconst me = this;\n\t\tconst dataset = me.data.datasets[datasetIndex];\n\t\tconst metasets = me._metasets;\n\t\tlet meta = metasets.filter(x => x._dataset === dataset).pop();\n\t\tif (!meta) {\n\t\t\tmeta = metasets[datasetIndex] = {\n\t\t\t\ttype: null,\n\t\t\t\tdata: [],\n\t\t\t\tdataset: null,\n\t\t\t\tcontroller: null,\n\t\t\t\thidden: null,\n\t\t\t\txAxisID: null,\n\t\t\t\tyAxisID: null,\n\t\t\t\torder: dataset.order || 0,\n\t\t\t\tindex: datasetIndex,\n\t\t\t\t_dataset: dataset,\n\t\t\t\t_parsed: [],\n\t\t\t\t_sorted: false\n\t\t\t};\n\t\t}\n\t\treturn meta;\n\t}\n\tgetVisibleDatasetCount() {\n\t\treturn this.getSortedVisibleDatasetMetas().length;\n\t}\n\tisDatasetVisible(datasetIndex) {\n\t\tconst meta = this.getDatasetMeta(datasetIndex);\n\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t}\n\tsetDatasetVisibility(datasetIndex, visible) {\n\t\tconst meta = this.getDatasetMeta(datasetIndex);\n\t\tmeta.hidden = !visible;\n\t}\n\ttoggleDataVisibility(index) {\n\t\tthis._hiddenIndices[index] = !this._hiddenIndices[index];\n\t}\n\tgetDataVisibility(index) {\n\t\treturn !this._hiddenIndices[index];\n\t}\n\t_updateDatasetVisibility(datasetIndex, visible) {\n\t\tconst me = this;\n\t\tconst mode = visible ? 'show' : 'hide';\n\t\tconst meta = me.getDatasetMeta(datasetIndex);\n\t\tconst anims = meta.controller._resolveAnimations(undefined, mode);\n\t\tme.setDatasetVisibility(datasetIndex, visible);\n\t\tanims.update(meta, {visible});\n\t\tme.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n\t}\n\thide(datasetIndex) {\n\t\tthis._updateDatasetVisibility(datasetIndex, false);\n\t}\n\tshow(datasetIndex) {\n\t\tthis._updateDatasetVisibility(datasetIndex, true);\n\t}\n\t_destroyDatasetMeta(datasetIndex) {\n\t\tconst me = this;\n\t\tconst meta = me._metasets && me._metasets[datasetIndex];\n\t\tif (meta) {\n\t\t\tmeta.controller._destroy();\n\t\t\tdelete me._metasets[datasetIndex];\n\t\t}\n\t}\n\tdestroy() {\n\t\tconst me = this;\n\t\tconst canvas = me.canvas;\n\t\tlet i, ilen;\n\t\tme.stop();\n\t\tanimator.remove(me);\n\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\tme._destroyDatasetMeta(i);\n\t\t}\n\t\tif (canvas) {\n\t\t\tme.unbindEvents();\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"T\"])(me);\n\t\t\tme.platform.releaseContext(me.ctx);\n\t\t\tme.canvas = null;\n\t\t\tme.ctx = null;\n\t\t}\n\t\tme._plugins.notify(me, 'destroy');\n\t\tdelete Chart.instances[me.id];\n\t}\n\ttoBase64Image(...args) {\n\t\treturn this.canvas.toDataURL(...args);\n\t}\n\tbindEvents() {\n\t\tconst me = this;\n\t\tconst listeners = me._listeners;\n\t\tconst platform = me.platform;\n\t\tconst _add = (type, listener) => {\n\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\tlisteners[type] = listener;\n\t\t};\n\t\tconst _remove = (type, listener) => {\n\t\t\tif (listeners[type]) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t\tdelete listeners[type];\n\t\t\t}\n\t\t};\n\t\tlet listener = function(e, x, y) {\n\t\t\te.offsetX = x;\n\t\t\te.offsetY = y;\n\t\t\tme._eventHandler(e);\n\t\t};\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(me.options.events, (type) => _add(type, listener));\n\t\tif (me.options.responsive) {\n\t\t\tlistener = (width, height) => {\n\t\t\t\tif (me.canvas) {\n\t\t\t\t\tme.resize(false, width, height);\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet detached;\n\t\t\tconst attached = () => {\n\t\t\t\t_remove('attach', attached);\n\t\t\t\tme.attached = true;\n\t\t\t\tme.resize();\n\t\t\t\t_add('resize', listener);\n\t\t\t\t_add('detach', detached);\n\t\t\t};\n\t\t\tdetached = () => {\n\t\t\t\tme.attached = false;\n\t\t\t\t_remove('resize', listener);\n\t\t\t\t_add('attach', attached);\n\t\t\t};\n\t\t\tif (platform.isAttached(me.canvas)) {\n\t\t\t\tattached();\n\t\t\t} else {\n\t\t\t\tdetached();\n\t\t\t}\n\t\t} else {\n\t\t\tme.attached = true;\n\t\t}\n\t}\n\tunbindEvents() {\n\t\tconst me = this;\n\t\tconst listeners = me._listeners;\n\t\tif (!listeners) {\n\t\t\treturn;\n\t\t}\n\t\tdelete me._listeners;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(listeners, (listener, type) => {\n\t\t\tme.platform.removeEventListener(me, type, listener);\n\t\t});\n\t}\n\tupdateHoverStyle(items, mode, enabled) {\n\t\tconst prefix = enabled ? 'set' : 'remove';\n\t\tlet meta, item, i, ilen;\n\t\tif (mode === 'dataset') {\n\t\t\tmeta = this.getDatasetMeta(items[0].datasetIndex);\n\t\t\tmeta.controller['_' + prefix + 'DatasetHoverStyle']();\n\t\t}\n\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t\titem = items[i];\n\t\t\tif (item) {\n\t\t\t\tthis.getDatasetMeta(item.datasetIndex).controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n\t\t\t}\n\t\t}\n\t}\n\t_updateHoverStyles(active, lastActive) {\n\t\tconst me = this;\n\t\tconst options = me.options || {};\n\t\tconst hoverOptions = options.hover;\n\t\tif (lastActive.length) {\n\t\t\tme.updateHoverStyle(lastActive, hoverOptions.mode, false);\n\t\t}\n\t\tif (active.length && hoverOptions.mode) {\n\t\t\tme.updateHoverStyle(active, hoverOptions.mode, true);\n\t\t}\n\t}\n\t_eventHandler(e, replay) {\n\t\tconst me = this;\n\t\tif (me._plugins.notify(me, 'beforeEvent', [e, replay]) === false) {\n\t\t\treturn;\n\t\t}\n\t\tme._handleEvent(e, replay);\n\t\tme._plugins.notify(me, 'afterEvent', [e, replay]);\n\t\tme.render();\n\t\treturn me;\n\t}\n\t_handleEvent(e, replay) {\n\t\tconst me = this;\n\t\tconst lastActive = me._active || [];\n\t\tconst options = me.options;\n\t\tconst hoverOptions = options.hover;\n\t\tconst useFinalPosition = replay;\n\t\tlet active = [];\n\t\tlet changed = false;\n\t\tif (e.type === 'mouseout') {\n\t\t\tme._lastEvent = null;\n\t\t} else {\n\t\t\tactive = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n\t\t\tme._lastEvent = e.type === 'click' ? me._lastEvent : e;\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.onHover || options.hover.onHover, [e, active, me], me);\n\t\tif (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {\n\t\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(e, me.chartArea)) {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.onClick, [e, active, me], me);\n\t\t\t}\n\t\t}\n\t\tchanged = !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"U\"])(active, lastActive);\n\t\tif (changed || replay) {\n\t\t\tme._active = active;\n\t\t\tme._updateHoverStyles(active, lastActive);\n\t\t}\n\t\treturn changed;\n\t}\n}\nChart.defaults = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"];\nChart.instances = {};\nChart.registry = registry;\nChart.version = version;\nconst invalidatePlugins = () => Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(Chart.instances, (chart) => chart._plugins.invalidate());\nChart.register = (...items) => {\n\tregistry.add(...items);\n\tinvalidatePlugins();\n};\nChart.unregister = (...items) => {\n\tregistry.remove(...items);\n\tinvalidatePlugins();\n};\n\nconst TAU = Math.PI * 2;\nfunction clipArc(ctx, element) {\n\tconst {startAngle, endAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n\tlet angleMargin = pixelMargin / outerRadius;\n\tctx.beginPath();\n\tctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n\tif (innerRadius > pixelMargin) {\n\t\tangleMargin = pixelMargin / innerRadius;\n\t\tctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n\t} else {\n\t\tctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);\n\t}\n\tctx.closePath();\n\tctx.clip();\n}\nfunction pathArc(ctx, element) {\n\tconst {x, y, startAngle, endAngle, pixelMargin} = element;\n\tconst outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n\tconst innerRadius = element.innerRadius + pixelMargin;\n\tctx.beginPath();\n\tctx.arc(x, y, outerRadius, startAngle, endAngle);\n\tctx.arc(x, y, innerRadius, endAngle, startAngle, true);\n\tctx.closePath();\n}\nfunction drawArc(ctx, element) {\n\tif (element.fullCircles) {\n\t\telement.endAngle = element.startAngle + TAU;\n\t\tpathArc(ctx, element);\n\t\tfor (let i = 0; i < element.fullCircles; ++i) {\n\t\t\tctx.fill();\n\t\t}\n\t\telement.endAngle = element.startAngle + element.circumference % TAU;\n\t}\n\tpathArc(ctx, element);\n\tctx.fill();\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n\tconst {x, y, startAngle, endAngle, pixelMargin} = element;\n\tconst outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n\tconst innerRadius = element.innerRadius + pixelMargin;\n\tlet i;\n\tif (inner) {\n\t\telement.endAngle = element.startAngle + TAU;\n\t\tclipArc(ctx, element);\n\t\telement.endAngle = endAngle;\n\t\tif (element.endAngle === element.startAngle) {\n\t\t\telement.endAngle += TAU;\n\t\t\telement.fullCircles--;\n\t\t}\n\t}\n\tctx.beginPath();\n\tctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n\tfor (i = 0; i < element.fullCircles; ++i) {\n\t\tctx.stroke();\n\t}\n\tctx.beginPath();\n\tctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n\tfor (i = 0; i < element.fullCircles; ++i) {\n\t\tctx.stroke();\n\t}\n}\nfunction drawBorder(ctx, element) {\n\tconst {x, y, startAngle, endAngle, pixelMargin, options} = element;\n\tconst outerRadius = element.outerRadius;\n\tconst innerRadius = element.innerRadius + pixelMargin;\n\tconst inner = options.borderAlign === 'inner';\n\tif (!options.borderWidth) {\n\t\treturn;\n\t}\n\tif (inner) {\n\t\tctx.lineWidth = options.borderWidth * 2;\n\t\tctx.lineJoin = 'round';\n\t} else {\n\t\tctx.lineWidth = options.borderWidth;\n\t\tctx.lineJoin = 'bevel';\n\t}\n\tif (element.fullCircles) {\n\t\tdrawFullCircleBorders(ctx, element, inner);\n\t}\n\tif (inner) {\n\t\tclipArc(ctx, element);\n\t}\n\tctx.beginPath();\n\tctx.arc(x, y, outerRadius, startAngle, endAngle);\n\tctx.arc(x, y, innerRadius, endAngle, startAngle, true);\n\tctx.closePath();\n\tctx.stroke();\n}\nclass Arc extends Element {\n\tconstructor(cfg) {\n\t\tsuper();\n\t\tthis.options = undefined;\n\t\tthis.circumference = undefined;\n\t\tthis.startAngle = undefined;\n\t\tthis.endAngle = undefined;\n\t\tthis.innerRadius = undefined;\n\t\tthis.outerRadius = undefined;\n\t\tthis.pixelMargin = 0;\n\t\tthis.fullCircles = 0;\n\t\tif (cfg) {\n\t\t\tObject.assign(this, cfg);\n\t\t}\n\t}\n\tinRange(chartX, chartY, useFinalPosition) {\n\t\tconst point = this.getProps(['x', 'y'], useFinalPosition);\n\t\tconst {angle, distance} = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"V\"])(point, {x: chartX, y: chartY});\n\t\tconst {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n\t\t\t'startAngle',\n\t\t\t'endAngle',\n\t\t\t'innerRadius',\n\t\t\t'outerRadius',\n\t\t\t'circumference'\n\t\t], useFinalPosition);\n\t\tconst betweenAngles = circumference >= TAU || Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"W\"])(angle, startAngle, endAngle);\n\t\tconst withinRadius = (distance >= innerRadius && distance <= outerRadius);\n\t\treturn (betweenAngles && withinRadius);\n\t}\n\tgetCenterPoint(useFinalPosition) {\n\t\tconst {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n\t\t\t'x',\n\t\t\t'y',\n\t\t\t'startAngle',\n\t\t\t'endAngle',\n\t\t\t'innerRadius',\n\t\t\t'outerRadius'\n\t\t], useFinalPosition);\n\t\tconst halfAngle = (startAngle + endAngle) / 2;\n\t\tconst halfRadius = (innerRadius + outerRadius) / 2;\n\t\treturn {\n\t\t\tx: x + Math.cos(halfAngle) * halfRadius,\n\t\t\ty: y + Math.sin(halfAngle) * halfRadius\n\t\t};\n\t}\n\ttooltipPosition(useFinalPosition) {\n\t\treturn this.getCenterPoint(useFinalPosition);\n\t}\n\tdraw(ctx) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst offset = options.offset || 0;\n\t\tme.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n\t\tme.fullCircles = Math.floor(me.circumference / TAU);\n\t\tif (me.circumference === 0) {\n\t\t\treturn;\n\t\t}\n\t\tctx.save();\n\t\tif (offset && me.circumference < TAU) {\n\t\t\tconst halfAngle = (me.startAngle + me.endAngle) / 2;\n\t\t\tctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n\t\t}\n\t\tctx.fillStyle = options.backgroundColor;\n\t\tctx.strokeStyle = options.borderColor;\n\t\tdrawArc(ctx, me);\n\t\tdrawBorder(ctx, me);\n\t\tctx.restore();\n\t}\n}\nArc.id = 'arc';\nArc.defaults = {\n\tborderAlign: 'center',\n\tborderColor: '#fff',\n\tborderWidth: 2,\n\toffset: 0\n};\nArc.defaultRoutes = {\n\tbackgroundColor: 'color'\n};\n\nfunction setStyle(ctx, vm) {\n\tctx.lineCap = vm.borderCapStyle;\n\tctx.setLineDash(vm.borderDash);\n\tctx.lineDashOffset = vm.borderDashOffset;\n\tctx.lineJoin = vm.borderJoinStyle;\n\tctx.lineWidth = vm.borderWidth;\n\tctx.strokeStyle = vm.borderColor;\n}\nfunction lineTo(ctx, previous, target) {\n\tctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n\tif (options.stepped) {\n\t\treturn _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a2\"];\n\t}\n\tif (options.tension) {\n\t\treturn _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a3\"];\n\t}\n\treturn lineTo;\n}\nfunction pathVars(points, segment, params) {\n\tparams = params || {};\n\tconst count = points.length;\n\tconst start = Math.max(params.start || 0, segment.start);\n\tconst end = Math.min(params.end || count - 1, segment.end);\n\treturn {\n\t\tcount,\n\t\tstart,\n\t\tloop: segment.loop,\n\t\tilen: end < start ? count + end - start : end - start\n\t};\n}\nfunction pathSegment(ctx, line, segment, params) {\n\tconst {points, options} = line;\n\tconst {count, start, loop, ilen} = pathVars(points, segment, params);\n\tconst lineMethod = getLineMethod(options);\n\tlet {move = true, reverse} = params || {};\n\tlet i, point, prev;\n\tfor (i = 0; i <= ilen; ++i) {\n\t\tpoint = points[(start + (reverse ? ilen - i : i)) % count];\n\t\tif (point.skip) {\n\t\t\tcontinue;\n\t\t} else if (move) {\n\t\t\tctx.moveTo(point.x, point.y);\n\t\t\tmove = false;\n\t\t} else {\n\t\t\tlineMethod(ctx, prev, point, reverse, options.stepped);\n\t\t}\n\t\tprev = point;\n\t}\n\tif (loop) {\n\t\tpoint = points[(start + (reverse ? ilen : 0)) % count];\n\t\tlineMethod(ctx, prev, point, reverse, options.stepped);\n\t}\n\treturn !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n\tconst points = line.points;\n\tconst {count, start, ilen} = pathVars(points, segment, params);\n\tconst {move = true, reverse} = params || {};\n\tlet avgX = 0;\n\tlet countX = 0;\n\tlet i, point, prevX, minY, maxY, lastY;\n\tconst pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n\tconst drawX = () => {\n\t\tif (minY !== maxY) {\n\t\t\tctx.lineTo(avgX, maxY);\n\t\t\tctx.lineTo(avgX, minY);\n\t\t\tctx.lineTo(avgX, lastY);\n\t\t}\n\t};\n\tif (move) {\n\t\tpoint = points[pointIndex(0)];\n\t\tctx.moveTo(point.x, point.y);\n\t}\n\tfor (i = 0; i <= ilen; ++i) {\n\t\tpoint = points[pointIndex(i)];\n\t\tif (point.skip) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst x = point.x;\n\t\tconst y = point.y;\n\t\tconst truncX = x | 0;\n\t\tif (truncX === prevX) {\n\t\t\tif (y < minY) {\n\t\t\t\tminY = y;\n\t\t\t} else if (y > maxY) {\n\t\t\t\tmaxY = y;\n\t\t\t}\n\t\t\tavgX = (countX * avgX + x) / ++countX;\n\t\t} else {\n\t\t\tdrawX();\n\t\t\tctx.lineTo(x, y);\n\t\t\tprevX = truncX;\n\t\t\tcountX = 0;\n\t\t\tminY = maxY = y;\n\t\t}\n\t\tlastY = y;\n\t}\n\tdrawX();\n}\nfunction _getSegmentMethod(line) {\n\tconst opts = line.options;\n\tconst borderDash = opts.borderDash && opts.borderDash.length;\n\tconst useFastPath = !line._loop && !opts.tension && !opts.stepped && !borderDash;\n\treturn useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n\tif (options.stepped) {\n\t\treturn _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"$\"];\n\t}\n\tif (options.tension) {\n\t\treturn _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a0\"];\n\t}\n\treturn _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a1\"];\n}\nclass Line extends Element {\n\tconstructor(cfg) {\n\t\tsuper();\n\t\tthis.options = undefined;\n\t\tthis._loop = undefined;\n\t\tthis._fullLoop = undefined;\n\t\tthis._points = undefined;\n\t\tthis._segments = undefined;\n\t\tthis._pointsUpdated = false;\n\t\tif (cfg) {\n\t\t\tObject.assign(this, cfg);\n\t\t}\n\t}\n\tupdateControlPoints(chartArea) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tif (options.tension && !options.stepped && !me._pointsUpdated) {\n\t\t\tconst loop = options.spanGaps ? me._loop : me._fullLoop;\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(me._points, options, chartArea, loop);\n\t\t\tme._pointsUpdated = true;\n\t\t}\n\t}\n\tset points(points) {\n\t\tthis._points = points;\n\t\tdelete this._segments;\n\t}\n\tget points() {\n\t\treturn this._points;\n\t}\n\tget segments() {\n\t\treturn this._segments || (this._segments = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"Y\"])(this));\n\t}\n\tfirst() {\n\t\tconst segments = this.segments;\n\t\tconst points = this.points;\n\t\treturn segments.length && points[segments[0].start];\n\t}\n\tlast() {\n\t\tconst segments = this.segments;\n\t\tconst points = this.points;\n\t\tconst count = segments.length;\n\t\treturn count && points[segments[count - 1].end];\n\t}\n\tinterpolate(point, property) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst value = point[property];\n\t\tconst points = me.points;\n\t\tconst segments = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"Z\"])(me, {property, start: value, end: value});\n\t\tif (!segments.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst result = [];\n\t\tconst _interpolate = _getInterpolationMethod(options);\n\t\tlet i, ilen;\n\t\tfor (i = 0, ilen = segments.length; i < ilen; ++i) {\n\t\t\tconst {start, end} = segments[i];\n\t\t\tconst p1 = points[start];\n\t\t\tconst p2 = points[end];\n\t\t\tif (p1 === p2) {\n\t\t\t\tresult.push(p1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n\t\t\tconst interpolated = _interpolate(p1, p2, t, options.stepped);\n\t\t\tinterpolated[property] = point[property];\n\t\t\tresult.push(interpolated);\n\t\t}\n\t\treturn result.length === 1 ? result[0] : result;\n\t}\n\tpathSegment(ctx, segment, params) {\n\t\tconst segmentMethod = _getSegmentMethod(this);\n\t\treturn segmentMethod(ctx, this, segment, params);\n\t}\n\tpath(ctx, start, count) {\n\t\tconst me = this;\n\t\tconst segments = me.segments;\n\t\tconst ilen = segments.length;\n\t\tconst segmentMethod = _getSegmentMethod(me);\n\t\tlet loop = me._loop;\n\t\tstart = start || 0;\n\t\tcount = count || (me.points.length - start);\n\t\tfor (let i = 0; i < ilen; ++i) {\n\t\t\tloop &= segmentMethod(ctx, me, segments[i], {start, end: start + count - 1});\n\t\t}\n\t\treturn !!loop;\n\t}\n\tdraw(ctx, chartArea, start, count) {\n\t\tconst options = this.options || {};\n\t\tconst points = this.points || [];\n\t\tif (!points.length || !options.borderWidth) {\n\t\t\treturn;\n\t\t}\n\t\tctx.save();\n\t\tsetStyle(ctx, options);\n\t\tctx.beginPath();\n\t\tif (this.path(ctx, start, count)) {\n\t\t\tctx.closePath();\n\t\t}\n\t\tctx.stroke();\n\t\tctx.restore();\n\t\tthis._pointsUpdated = false;\n\t}\n}\nLine.id = 'line';\nLine.defaults = {\n\tborderCapStyle: 'butt',\n\tborderDash: [],\n\tborderDashOffset: 0,\n\tborderJoinStyle: 'miter',\n\tborderWidth: 3,\n\tcapBezierPoints: true,\n\tfill: true,\n\ttension: 0\n};\nLine.defaultRoutes = {\n\tbackgroundColor: 'color',\n\tborderColor: 'color'\n};\n\nclass Point extends Element {\n\tconstructor(cfg) {\n\t\tsuper();\n\t\tthis.options = undefined;\n\t\tthis.skip = undefined;\n\t\tthis.stop = undefined;\n\t\tif (cfg) {\n\t\t\tObject.assign(this, cfg);\n\t\t}\n\t}\n\tinRange(mouseX, mouseY, useFinalPosition) {\n\t\tconst options = this.options;\n\t\tconst {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n\t\treturn ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n\t}\n\tinXRange(mouseX, useFinalPosition) {\n\t\tconst options = this.options;\n\t\tconst {x} = this.getProps(['x'], useFinalPosition);\n\t\treturn (Math.abs(mouseX - x) < options.radius + options.hitRadius);\n\t}\n\tinYRange(mouseY, useFinalPosition) {\n\t\tconst options = this.options;\n\t\tconst {y} = this.getProps(['x'], useFinalPosition);\n\t\treturn (Math.abs(mouseY - y) < options.radius + options.hitRadius);\n\t}\n\tgetCenterPoint(useFinalPosition) {\n\t\tconst {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n\t\treturn {x, y};\n\t}\n\tsize() {\n\t\tconst options = this.options || {};\n\t\tconst radius = Math.max(options.radius, options.hoverRadius) || 0;\n\t\tconst borderWidth = radius && options.borderWidth || 0;\n\t\treturn (radius + borderWidth) * 2;\n\t}\n\tdraw(ctx, chartArea) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tif (me.skip || options.radius <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (chartArea === undefined || Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(me, chartArea)) {\n\t\t\tctx.strokeStyle = options.borderColor;\n\t\t\tctx.lineWidth = options.borderWidth;\n\t\t\tctx.fillStyle = options.backgroundColor;\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a4\"])(ctx, options, me.x, me.y);\n\t\t}\n\t}\n\tgetRange() {\n\t\tconst options = this.options || {};\n\t\treturn options.radius + options.hitRadius;\n\t}\n}\nPoint.id = 'point';\nPoint.defaults = {\n\tborderWidth: 1,\n\thitRadius: 1,\n\thoverBorderWidth: 1,\n\thoverRadius: 4,\n\tpointStyle: 'circle',\n\tradius: 3\n};\nPoint.defaultRoutes = {\n\tbackgroundColor: 'color',\n\tborderColor: 'color'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n\tconst {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n\tlet left, right, top, bottom, half;\n\tif (bar.horizontal) {\n\t\thalf = height / 2;\n\t\tleft = Math.min(x, base);\n\t\tright = Math.max(x, base);\n\t\ttop = y - half;\n\t\tbottom = y + half;\n\t} else {\n\t\thalf = width / 2;\n\t\tleft = x - half;\n\t\tright = x + half;\n\t\ttop = Math.min(y, base);\n\t\tbottom = Math.max(y, base);\n\t}\n\treturn {left, top, right, bottom};\n}\nfunction parseBorderSkipped(bar) {\n\tlet edge = bar.options.borderSkipped;\n\tconst res = {};\n\tif (!edge) {\n\t\treturn res;\n\t}\n\tedge = bar.horizontal\n\t\t? parseEdge(edge, 'left', 'right', bar.base > bar.x)\n\t\t: parseEdge(edge, 'bottom', 'top', bar.base < bar.y);\n\tres[edge] = true;\n\treturn res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n\tif (reverse) {\n\t\tedge = swap(edge, a, b);\n\t\tedge = startEnd(edge, b, a);\n\t} else {\n\t\tedge = startEnd(edge, a, b);\n\t}\n\treturn edge;\n}\nfunction swap(orig, v1, v2) {\n\treturn orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n\treturn v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction skipOrLimit(skip, value, min, max) {\n\treturn skip ? 0 : Math.max(Math.min(value, max), min);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n\tconst value = bar.options.borderWidth;\n\tconst skip = parseBorderSkipped(bar);\n\tconst o = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a5\"])(value);\n\treturn {\n\t\tt: skipOrLimit(skip.top, o.top, 0, maxH),\n\t\tr: skipOrLimit(skip.right, o.right, 0, maxW),\n\t\tb: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n\t\tl: skipOrLimit(skip.left, o.left, 0, maxW)\n\t};\n}\nfunction boundingRects(bar) {\n\tconst bounds = getBarBounds(bar);\n\tconst width = bounds.right - bounds.left;\n\tconst height = bounds.bottom - bounds.top;\n\tconst border = parseBorderWidth(bar, width / 2, height / 2);\n\treturn {\n\t\touter: {\n\t\t\tx: bounds.left,\n\t\t\ty: bounds.top,\n\t\t\tw: width,\n\t\t\th: height\n\t\t},\n\t\tinner: {\n\t\t\tx: bounds.left + border.l,\n\t\t\ty: bounds.top + border.t,\n\t\t\tw: width - border.l - border.r,\n\t\t\th: height - border.t - border.b\n\t\t}\n\t};\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n\tconst skipX = x === null;\n\tconst skipY = y === null;\n\tconst skipBoth = skipX && skipY;\n\tconst bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\treturn bounds\n\t\t&& (skipX || x >= bounds.left && x <= bounds.right)\n\t\t&& (skipY || y >= bounds.top && y <= bounds.bottom);\n}\nclass Rectangle extends Element {\n\tconstructor(cfg) {\n\t\tsuper();\n\t\tthis.options = undefined;\n\t\tthis.horizontal = undefined;\n\t\tthis.base = undefined;\n\t\tthis.width = undefined;\n\t\tthis.height = undefined;\n\t\tif (cfg) {\n\t\t\tObject.assign(this, cfg);\n\t\t}\n\t}\n\tdraw(ctx) {\n\t\tconst options = this.options;\n\t\tconst {inner, outer} = boundingRects(this);\n\t\tctx.save();\n\t\tif (outer.w !== inner.w || outer.h !== inner.h) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(outer.x, outer.y, outer.w, outer.h);\n\t\t\tctx.clip();\n\t\t\tctx.rect(inner.x, inner.y, inner.w, inner.h);\n\t\t\tctx.fillStyle = options.borderColor;\n\t\t\tctx.fill('evenodd');\n\t\t}\n\t\tctx.fillStyle = options.backgroundColor;\n\t\tctx.fillRect(inner.x, inner.y, inner.w, inner.h);\n\t\tctx.restore();\n\t}\n\tinRange(mouseX, mouseY, useFinalPosition) {\n\t\treturn inRange(this, mouseX, mouseY, useFinalPosition);\n\t}\n\tinXRange(mouseX, useFinalPosition) {\n\t\treturn inRange(this, mouseX, null, useFinalPosition);\n\t}\n\tinYRange(mouseY, useFinalPosition) {\n\t\treturn inRange(this, null, mouseY, useFinalPosition);\n\t}\n\tgetCenterPoint(useFinalPosition) {\n\t\tconst {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n\t\treturn {\n\t\t\tx: horizontal ? (x + base) / 2 : x,\n\t\t\ty: horizontal ? y : (y + base) / 2\n\t\t};\n\t}\n\tgetRange(axis) {\n\t\treturn axis === 'x' ? this.width / 2 : this.height / 2;\n\t}\n}\nRectangle.id = 'rectangle';\nRectangle.defaults = {\n\tborderSkipped: 'start',\n\tborderWidth: 0\n};\nRectangle.defaultRoutes = {\n\tbackgroundColor: 'color',\n\tborderColor: 'color'\n};\n\nfunction getLineByIndex(chart, index) {\n\tconst meta = chart.getDatasetMeta(index);\n\tconst visible = meta && chart.isDatasetVisible(index);\n\treturn visible ? meta.dataset : null;\n}\nfunction parseFillOption(line) {\n\tconst options = line.options;\n\tconst fillOption = options.fill;\n\tlet fill = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(fillOption && fillOption.target, fillOption);\n\tif (fill === undefined) {\n\t\tfill = !!options.backgroundColor;\n\t}\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\treturn fill;\n}\nfunction decodeFill(line, index, count) {\n\tconst fill = parseFillOption(line);\n\tlet target = parseFloat(fill);\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\t\treturn target;\n\t}\n\treturn ['origin', 'start', 'end', 'stack'].indexOf(fill) >= 0 && fill;\n}\nfunction computeLinearBoundary(source) {\n\tconst {scale = {}, fill} = source;\n\tlet target = null;\n\tlet horizontal;\n\tif (fill === 'start') {\n\t\ttarget = scale.bottom;\n\t} else if (fill === 'end') {\n\t\ttarget = scale.top;\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(target)) {\n\t\thorizontal = scale.isHorizontal();\n\t\treturn {\n\t\t\tx: horizontal ? target : null,\n\t\t\ty: horizontal ? null : target\n\t\t};\n\t}\n\treturn null;\n}\nclass simpleArc {\n\tconstructor(opts) {\n\t\tthis.x = opts.x;\n\t\tthis.y = opts.y;\n\t\tthis.radius = opts.radius;\n\t}\n\tpathSegment(ctx, bounds, opts) {\n\t\tconst {x, y, radius} = this;\n\t\tbounds = bounds || {start: 0, end: Math.PI * 2};\n\t\tif (opts.reverse) {\n\t\t\tctx.arc(x, y, radius, bounds.end, bounds.start, true);\n\t\t} else {\n\t\t\tctx.arc(x, y, radius, bounds.start, bounds.end);\n\t\t}\n\t\treturn !opts.bounds;\n\t}\n\tinterpolate(point, property) {\n\t\tconst {x, y, radius} = this;\n\t\tconst angle = point.angle;\n\t\tif (property === 'angle') {\n\t\t\treturn {\n\t\t\t\tx: x + Math.cos(angle) * radius,\n\t\t\t\ty: y + Math.sin(angle) * radius,\n\t\t\t\tangle\n\t\t\t};\n\t\t}\n\t}\n}\nfunction computeCircularBoundary(source) {\n\tconst {scale, fill} = source;\n\tconst options = scale.options;\n\tconst length = scale.getLabels().length;\n\tconst target = [];\n\tconst start = options.reverse ? scale.max : scale.min;\n\tconst end = options.reverse ? scale.min : scale.max;\n\tconst value = fill === 'start' ? start : fill === 'end' ? end : scale.getBaseValue();\n\tlet i, center;\n\tif (options.gridLines.circular) {\n\t\tcenter = scale.getPointPositionForValue(0, start);\n\t\treturn new simpleArc({\n\t\t\tx: center.x,\n\t\t\ty: center.y,\n\t\t\tradius: scale.getDistanceFromCenterForValue(value)\n\t\t});\n\t}\n\tfor (i = 0; i < length; ++i) {\n\t\ttarget.push(scale.getPointPositionForValue(i, value));\n\t}\n\treturn target;\n}\nfunction computeBoundary(source) {\n\tconst scale = source.scale || {};\n\tif (scale.getPointPositionForValue) {\n\t\treturn computeCircularBoundary(source);\n\t}\n\treturn computeLinearBoundary(source);\n}\nfunction pointsFromSegments(boundary, line) {\n\tconst {x = null, y = null} = boundary || {};\n\tconst linePoints = line.points;\n\tconst points = [];\n\tline.segments.forEach((segment) => {\n\t\tconst first = linePoints[segment.start];\n\t\tconst last = linePoints[segment.end];\n\t\tif (y !== null) {\n\t\t\tpoints.push({x: first.x, y});\n\t\t\tpoints.push({x: last.x, y});\n\t\t} else if (x !== null) {\n\t\t\tpoints.push({x, y: first.y});\n\t\t\tpoints.push({x, y: last.y});\n\t\t}\n\t});\n\treturn points;\n}\nfunction buildStackLine(source) {\n\tconst {chart, scale, index, line} = source;\n\tconst points = [];\n\tconst segments = line.segments;\n\tconst sourcePoints = line.points;\n\tconst linesBelow = getLinesBelow(chart, index);\n\tlinesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst segment = segments[i];\n\t\tfor (let j = segment.start; j <= segment.end; j++) {\n\t\t\taddPointsBelow(points, sourcePoints[j], linesBelow);\n\t\t}\n\t}\n\treturn new Line({points, options: {}});\n}\nconst isLineAndNotInHideAnimation = (meta) => meta.type === 'line' && !meta.hidden;\nfunction getLinesBelow(chart, index) {\n\tconst below = [];\n\tconst metas = chart.getSortedVisibleDatasetMetas();\n\tfor (let i = 0; i < metas.length; i++) {\n\t\tconst meta = metas[i];\n\t\tif (meta.index === index) {\n\t\t\tbreak;\n\t\t}\n\t\tif (isLineAndNotInHideAnimation(meta)) {\n\t\t\tbelow.unshift(meta.dataset);\n\t\t}\n\t}\n\treturn below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n\tconst postponed = [];\n\tfor (let j = 0; j < linesBelow.length; j++) {\n\t\tconst line = linesBelow[j];\n\t\tconst {first, last, point} = findPoint(line, sourcePoint, 'x');\n\t\tif (!point || (first && last)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (first) {\n\t\t\tpostponed.unshift(point);\n\t\t} else {\n\t\t\tpoints.push(point);\n\t\t\tif (!last) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpoints.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n\tconst point = line.interpolate(sourcePoint, property);\n\tif (!point) {\n\t\treturn {};\n\t}\n\tconst pointValue = point[property];\n\tconst segments = line.segments;\n\tconst linePoints = line.points;\n\tlet first = false;\n\tlet last = false;\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst segment = segments[i];\n\t\tconst firstValue = linePoints[segment.start][property];\n\t\tconst lastValue = linePoints[segment.end][property];\n\t\tif (pointValue >= firstValue && pointValue <= lastValue) {\n\t\t\tfirst = pointValue === firstValue;\n\t\t\tlast = pointValue === lastValue;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn {first, last, point};\n}\nfunction getTarget(source) {\n\tconst {chart, fill, line} = source;\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(fill)) {\n\t\treturn getLineByIndex(chart, fill);\n\t}\n\tif (fill === 'stack') {\n\t\treturn buildStackLine(source);\n\t}\n\tconst boundary = computeBoundary(source);\n\tif (boundary instanceof simpleArc) {\n\t\treturn boundary;\n\t}\n\treturn createBoundaryLine(boundary, line);\n}\nfunction createBoundaryLine(boundary, line) {\n\tlet points = [];\n\tlet _loop = false;\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(boundary)) {\n\t\t_loop = true;\n\t\tpoints = boundary;\n\t} else {\n\t\tpoints = pointsFromSegments(boundary, line);\n\t}\n\treturn points.length ? new Line({\n\t\tpoints,\n\t\toptions: {tension: 0},\n\t\t_loop,\n\t\t_fullLoop: _loop\n\t}) : null;\n}\nfunction resolveTarget(sources, index, propagate) {\n\tconst source = sources[index];\n\tlet fill = source.fill;\n\tconst visited = [index];\n\tlet target;\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(fill)) {\n\t\t\treturn fill;\n\t\t}\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\treturn false;\n}\nfunction _clip(ctx, target, clipY) {\n\tctx.beginPath();\n\ttarget.path(ctx);\n\tctx.lineTo(target.last().x, clipY);\n\tctx.lineTo(target.first().x, clipY);\n\tctx.closePath();\n\tctx.clip();\n}\nfunction getBounds(property, first, last, loop) {\n\tif (loop) {\n\t\treturn;\n\t}\n\tlet start = first[property];\n\tlet end = last[property];\n\tif (property === 'angle') {\n\t\tstart = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a6\"])(start);\n\t\tend = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a6\"])(end);\n\t}\n\treturn {property, start, end};\n}\nfunction _getEdge(a, b, prop, fn) {\n\tif (a && b) {\n\t\treturn fn(a[prop], b[prop]);\n\t}\n\treturn a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _segments(line, target, property) {\n\tconst segments = line.segments;\n\tconst points = line.points;\n\tconst tpoints = target.points;\n\tconst parts = [];\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst segment = segments[i];\n\t\tconst bounds = getBounds(property, points[segment.start], points[segment.end], segment.loop);\n\t\tif (!target.segments) {\n\t\t\tparts.push({\n\t\t\t\tsource: segment,\n\t\t\t\ttarget: bounds,\n\t\t\t\tstart: points[segment.start],\n\t\t\t\tend: points[segment.end]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tconst subs = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"Z\"])(target, bounds);\n\t\tfor (let j = 0; j < subs.length; ++j) {\n\t\t\tconst sub = subs[j];\n\t\t\tconst subBounds = getBounds(property, tpoints[sub.start], tpoints[sub.end], sub.loop);\n\t\t\tconst fillSources = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a7\"])(segment, points, subBounds);\n\t\t\tfor (let k = 0; k < fillSources.length; k++) {\n\t\t\t\tparts.push({\n\t\t\t\t\tsource: fillSources[k],\n\t\t\t\t\ttarget: sub,\n\t\t\t\t\tstart: {\n\t\t\t\t\t\t[property]: _getEdge(bounds, subBounds, 'start', Math.max)\n\t\t\t\t\t},\n\t\t\t\t\tend: {\n\t\t\t\t\t\t[property]: _getEdge(bounds, subBounds, 'end', Math.min)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn parts;\n}\nfunction clipBounds(ctx, scale, bounds) {\n\tconst {top, bottom} = scale.chart.chartArea;\n\tconst {property, start, end} = bounds || {};\n\tif (property === 'x') {\n\t\tctx.beginPath();\n\t\tctx.rect(start, top, end - start, bottom - top);\n\t\tctx.clip();\n\t}\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n\tconst interpolatedPoint = target.interpolate(point, property);\n\tif (interpolatedPoint) {\n\t\tctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n\t}\n}\nfunction _fill(ctx, cfg) {\n\tconst {line, target, property, color, scale} = cfg;\n\tconst segments = _segments(line, target, property);\n\tctx.fillStyle = color;\n\tfor (let i = 0, ilen = segments.length; i < ilen; ++i) {\n\t\tconst {source: src, target: tgt, start, end} = segments[i];\n\t\tctx.save();\n\t\tclipBounds(ctx, scale, getBounds(property, start, end));\n\t\tctx.beginPath();\n\t\tconst lineLoop = !!line.pathSegment(ctx, src);\n\t\tif (lineLoop) {\n\t\t\tctx.closePath();\n\t\t} else {\n\t\t\tinterpolatedLineTo(ctx, target, end, property);\n\t\t}\n\t\tconst targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n\t\tconst loop = lineLoop && targetLoop;\n\t\tif (!loop) {\n\t\t\tinterpolatedLineTo(ctx, target, start, property);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill(loop ? 'evenodd' : 'nonzero');\n\t\tctx.restore();\n\t}\n}\nfunction doFill(ctx, cfg) {\n\tconst {line, target, above, below, area, scale} = cfg;\n\tconst property = line._loop ? 'angle' : 'x';\n\tctx.save();\n\tif (property === 'x' && below !== above) {\n\t\t_clip(ctx, target, area.top);\n\t\t_fill(ctx, {line, target, color: above, scale, property});\n\t\tctx.restore();\n\t\tctx.save();\n\t\t_clip(ctx, target, area.bottom);\n\t}\n\t_fill(ctx, {line, target, color: below, scale, property});\n\tctx.restore();\n}\nvar plugin_filler = {\n\tid: 'filler',\n\tafterDatasetsUpdate(chart, options) {\n\t\tconst count = (chart.data.datasets || []).length;\n\t\tconst propagate = options.propagate;\n\t\tconst sources = [];\n\t\tlet meta, i, line, source;\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tline = meta.dataset;\n\t\t\tsource = null;\n\t\t\tif (line && line.options && line instanceof Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tfill: decodeFill(line, i, count),\n\t\t\t\t\tchart,\n\t\t\t\t\tscale: meta.vScale,\n\t\t\t\t\tline\n\t\t\t\t};\n\t\t\t}\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source || source.fill === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t}\n\t},\n\tbeforeDatasetsDraw(chart) {\n\t\tconst metasets = chart.getSortedVisibleDatasetMetas();\n\t\tconst area = chart.chartArea;\n\t\tlet i, meta;\n\t\tfor (i = metasets.length - 1; i >= 0; --i) {\n\t\t\tmeta = metasets[i].$filler;\n\t\t\tif (meta) {\n\t\t\t\tmeta.line.updateControlPoints(area);\n\t\t\t}\n\t\t}\n\t},\n\tbeforeDatasetDraw(chart, args) {\n\t\tconst area = chart.chartArea;\n\t\tconst ctx = chart.ctx;\n\t\tconst source = args.meta.$filler;\n\t\tif (!source || source.fill === false) {\n\t\t\treturn;\n\t\t}\n\t\tconst target = getTarget(source);\n\t\tconst {line, scale} = source;\n\t\tconst lineOpts = line.options;\n\t\tconst fillOption = lineOpts.fill;\n\t\tconst color = lineOpts.backgroundColor;\n\t\tconst {above = color, below = color} = fillOption || {};\n\t\tif (target && line.points.length) {\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(ctx, area);\n\t\t\tdoFill(ctx, {line, target, above, below, area, scale});\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(ctx);\n\t\t}\n\t},\n\tdefaults: {\n\t\tpropagate: true\n\t}\n};\n\nfunction getBoxWidth(labelOpts, fontSize) {\n\tconst {boxWidth} = labelOpts;\n\treturn (labelOpts.usePointStyle && boxWidth > fontSize) || Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(boxWidth) ?\n\t\tfontSize :\n\t\tboxWidth;\n}\nfunction getBoxHeight(labelOpts, fontSize) {\n\tconst {boxHeight} = labelOpts;\n\treturn (labelOpts.usePointStyle && boxHeight > fontSize) || Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(boxHeight) ?\n\t\tfontSize :\n\t\tboxHeight;\n}\nclass Legend extends Element {\n\tconstructor(config) {\n\t\tsuper();\n\t\tObject.assign(this, config);\n\t\tthis.legendHitBoxes = [];\n\t\tthis._hoveredItem = null;\n\t\tthis.doughnutMode = false;\n\t\tthis.chart = config.chart;\n\t\tthis.options = config.options;\n\t\tthis.ctx = config.ctx;\n\t\tthis.legendItems = undefined;\n\t\tthis.columnWidths = undefined;\n\t\tthis.columnHeights = undefined;\n\t\tthis.lineWidths = undefined;\n\t\tthis._minSize = undefined;\n\t\tthis.maxHeight = undefined;\n\t\tthis.maxWidth = undefined;\n\t\tthis.top = undefined;\n\t\tthis.bottom = undefined;\n\t\tthis.left = undefined;\n\t\tthis.right = undefined;\n\t\tthis.height = undefined;\n\t\tthis.width = undefined;\n\t\tthis._margins = undefined;\n\t\tthis.paddingTop = undefined;\n\t\tthis.paddingBottom = undefined;\n\t\tthis.paddingLeft = undefined;\n\t\tthis.paddingRight = undefined;\n\t\tthis.position = undefined;\n\t\tthis.weight = undefined;\n\t\tthis.fullWidth = undefined;\n\t}\n\tbeforeUpdate() {}\n\tupdate(maxWidth, maxHeight, margins) {\n\t\tconst me = this;\n\t\tme.beforeUpdate();\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme._margins = margins;\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\tme.afterUpdate();\n\t}\n\tafterUpdate() {}\n\tbeforeSetDimensions() {}\n\tsetDimensions() {\n\t\tconst me = this;\n\t\tif (me.isHorizontal()) {\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\t\tme._minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t}\n\tafterSetDimensions() {}\n\tbeforeBuildLabels() {}\n\tbuildLabels() {\n\t\tconst me = this;\n\t\tconst labelOpts = me.options.labels || {};\n\t\tlet legendItems = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(labelOpts.generateLabels, [me.chart], me) || [];\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter((item) => labelOpts.filter(item, me.chart.data));\n\t\t}\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\t\tme.legendItems = legendItems;\n\t}\n\tafterBuildLabels() {}\n\tbeforeFit() {}\n\tfit() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst labelOpts = opts.labels;\n\t\tconst display = opts.display;\n\t\tconst ctx = me.ctx;\n\t\tconst labelFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(labelOpts.font, me.chart.options.font);\n\t\tconst fontSize = labelFont.size;\n\t\tconst boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\tconst boxHeight = getBoxHeight(labelOpts, fontSize);\n\t\tconst itemHeight = Math.max(boxHeight, fontSize);\n\t\tconst hitboxes = me.legendHitBoxes = [];\n\t\tconst minSize = me._minSize;\n\t\tconst isHorizontal = me.isHorizontal();\n\t\tconst titleHeight = me._computeTitleHeight();\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth;\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight;\n\t\t}\n\t\tif (!display) {\n\t\t\tme.width = minSize.width = me.height = minSize.height = 0;\n\t\t\treturn;\n\t\t}\n\t\tctx.font = labelFont.string;\n\t\tif (isHorizontal) {\n\t\t\tconst lineWidths = me.lineWidths = [0];\n\t\t\tlet totalHeight = titleHeight;\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tme.legendItems.forEach((legendItem, i) => {\n\t\t\t\tconst width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\t\t\tif (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\n\t\t\t\t\ttotalHeight += itemHeight + labelOpts.padding;\n\t\t\t\t\tlineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n\t\t\t\t}\n\t\t\t\thitboxes[i] = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\twidth,\n\t\t\t\t\theight: itemHeight\n\t\t\t\t};\n\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t});\n\t\t\tminSize.height += totalHeight;\n\t\t} else {\n\t\t\tconst vPadding = labelOpts.padding;\n\t\t\tconst columnWidths = me.columnWidths = [];\n\t\t\tconst columnHeights = me.columnHeights = [];\n\t\t\tlet totalWidth = labelOpts.padding;\n\t\t\tlet currentColWidth = 0;\n\t\t\tlet currentColHeight = 0;\n\t\t\tconst heightLimit = minSize.height - titleHeight;\n\t\t\tme.legendItems.forEach((legendItem, i) => {\n\t\t\t\tconst itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\t\t\tif (i > 0 && currentColHeight + fontSize + 2 * vPadding > heightLimit) {\n\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tcolumnHeights.push(currentColHeight);\n\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t}\n\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\tcurrentColHeight += fontSize + vPadding;\n\t\t\t\thitboxes[i] = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\theight: itemHeight,\n\t\t\t\t};\n\t\t\t});\n\t\t\ttotalWidth += currentColWidth;\n\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\tcolumnHeights.push(currentColHeight);\n\t\t\tminSize.width += totalWidth;\n\t\t}\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t}\n\tafterFit() {}\n\tisHorizontal() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t}\n\tdraw() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst labelOpts = opts.labels;\n\t\tconst defaultColor = _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].color;\n\t\tconst legendHeight = me.height;\n\t\tconst columnHeights = me.columnHeights;\n\t\tconst legendWidth = me.width;\n\t\tconst lineWidths = me.lineWidths;\n\t\tif (!opts.display) {\n\t\t\treturn;\n\t\t}\n\t\tme.drawTitle();\n\t\tconst rtlHelper = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(opts.rtl, me.left, me._minSize.width);\n\t\tconst ctx = me.ctx;\n\t\tconst labelFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(labelOpts.font, me.chart.options.font);\n\t\tconst fontColor = labelFont.color;\n\t\tconst fontSize = labelFont.size;\n\t\tlet cursor;\n\t\tctx.textAlign = rtlHelper.textAlign('left');\n\t\tctx.textBaseline = 'middle';\n\t\tctx.lineWidth = 0.5;\n\t\tctx.strokeStyle = fontColor;\n\t\tctx.fillStyle = fontColor;\n\t\tctx.font = labelFont.string;\n\t\tconst boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\tconst boxHeight = getBoxHeight(labelOpts, fontSize);\n\t\tconst height = Math.max(fontSize, boxHeight);\n\t\tconst hitboxes = me.legendHitBoxes;\n\t\tconst drawLegendBox = function(x, y, legendItem) {\n\t\t\tif (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.save();\n\t\t\tconst lineWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineWidth, 1);\n\t\t\tctx.fillStyle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.fillStyle, defaultColor);\n\t\t\tctx.lineCap = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineCap, 'butt');\n\t\t\tctx.lineDashOffset = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineDashOffset, 0);\n\t\t\tctx.lineJoin = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineJoin, 'miter');\n\t\t\tctx.lineWidth = lineWidth;\n\t\t\tctx.strokeStyle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.strokeStyle, defaultColor);\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineDash, []));\n\t\t\t}\n\t\t\tif (labelOpts && labelOpts.usePointStyle) {\n\t\t\t\tconst drawOptions = {\n\t\t\t\t\tradius: boxWidth * Math.SQRT2 / 2,\n\t\t\t\t\tpointStyle: legendItem.pointStyle,\n\t\t\t\t\trotation: legendItem.rotation,\n\t\t\t\t\tborderWidth: lineWidth\n\t\t\t\t};\n\t\t\t\tconst centerX = rtlHelper.xPlus(x, boxWidth / 2);\n\t\t\t\tconst centerY = y + fontSize / 2;\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a4\"])(ctx, drawOptions, centerX, centerY);\n\t\t\t} else {\n\t\t\t\tconst yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), yBoxTop, boxWidth, boxHeight);\n\t\t\t\tif (lineWidth !== 0) {\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), yBoxTop, boxWidth, boxHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.restore();\n\t\t};\n\t\tconst fillText = function(x, y, legendItem, textWidth) {\n\t\t\tconst halfFontSize = fontSize / 2;\n\t\t\tconst xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);\n\t\t\tconst yMiddle = y + (height / 2);\n\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\t\t\tif (legendItem.hidden) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.lineWidth = 2;\n\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\tctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t};\n\t\tconst alignmentOffset = function(dimension, blockSize) {\n\t\t\tswitch (opts.align) {\n\t\t\tcase 'start':\n\t\t\t\treturn labelOpts.padding;\n\t\t\tcase 'end':\n\t\t\t\treturn dimension - blockSize;\n\t\t\tdefault:\n\t\t\t\treturn (dimension - blockSize + labelOpts.padding) / 2;\n\t\t\t}\n\t\t};\n\t\tconst isHorizontal = me.isHorizontal();\n\t\tconst titleHeight = this._computeTitleHeight();\n\t\tif (isHorizontal) {\n\t\t\tcursor = {\n\t\t\t\tx: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n\t\t\t\ty: me.top + labelOpts.padding + titleHeight,\n\t\t\t\tline: 0\n\t\t\t};\n\t\t} else {\n\t\t\tcursor = {\n\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\ty: me.top + alignmentOffset(legendHeight, columnHeights[0]) + titleHeight,\n\t\t\t\tline: 0\n\t\t\t};\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a9\"])(me.ctx, opts.textDirection);\n\t\tconst itemHeight = height + labelOpts.padding;\n\t\tme.legendItems.forEach((legendItem, i) => {\n\t\t\tconst textWidth = ctx.measureText(legendItem.text).width;\n\t\t\tconst width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\tlet x = cursor.x;\n\t\t\tlet y = cursor.y;\n\t\t\trtlHelper.setWidth(me._minSize.width);\n\t\t\tif (isHorizontal) {\n\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me._minSize.width) {\n\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t\tx = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n\t\t\t\t}\n\t\t\t} else if (i > 0 && y + itemHeight > me.top + me._minSize.height) {\n\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\tcursor.line++;\n\t\t\t\ty = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\n\t\t\t}\n\t\t\tconst realX = rtlHelper.x(x);\n\t\t\tdrawLegendBox(realX, y, legendItem);\n\t\t\thitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);\n\t\t\thitboxes[i].top = y;\n\t\t\tfillText(realX, y, legendItem, textWidth);\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor.x += width + labelOpts.padding;\n\t\t\t} else {\n\t\t\t\tcursor.y += itemHeight;\n\t\t\t}\n\t\t});\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"aa\"])(me.ctx, opts.textDirection);\n\t}\n\tdrawTitle() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst titleOpts = opts.title;\n\t\tconst titleFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(titleOpts.font, me.chart.options.font);\n\t\tconst titlePadding = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(titleOpts.padding);\n\t\tif (!titleOpts.display) {\n\t\t\treturn;\n\t\t}\n\t\tconst rtlHelper = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(opts.rtl, me.left, me._minSize.width);\n\t\tconst ctx = me.ctx;\n\t\tconst position = titleOpts.position;\n\t\tlet x, textAlign;\n\t\tconst halfFontSize = titleFont.size / 2;\n\t\tlet y = me.top + titlePadding.top + halfFontSize;\n\t\tlet left = me.left;\n\t\tlet maxWidth = me.width;\n\t\tif (this.isHorizontal()) {\n\t\t\tmaxWidth = Math.max(...me.lineWidths);\n\t\t\tswitch (opts.align) {\n\t\t\tcase 'start':\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\tleft = me.right - maxWidth;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tleft = ((me.left + me.right) / 2) - (maxWidth / 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst maxHeight = Math.max(...me.columnHeights);\n\t\t\tswitch (opts.align) {\n\t\t\tcase 'start':\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\ty += me.height - maxHeight;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ty += (me.height - maxHeight) / 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch (position) {\n\t\tcase 'start':\n\t\t\tx = left;\n\t\t\ttextAlign = 'left';\n\t\t\tbreak;\n\t\tcase 'end':\n\t\t\tx = left + maxWidth;\n\t\t\ttextAlign = 'right';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tx = left + (maxWidth / 2);\n\t\t\ttextAlign = 'center';\n\t\t\tbreak;\n\t\t}\n\t\tctx.textAlign = rtlHelper.textAlign(textAlign);\n\t\tctx.textBaseline = 'middle';\n\t\tctx.strokeStyle = titleFont.color;\n\t\tctx.fillStyle = titleFont.color;\n\t\tctx.font = titleFont.string;\n\t\tctx.fillText(titleOpts.text, x, y);\n\t}\n\t_computeTitleHeight() {\n\t\tconst titleOpts = this.options.title;\n\t\tconst titleFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(titleOpts.font, this.chart.options.font);\n\t\tconst titlePadding = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(titleOpts.padding);\n\t\treturn titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n\t}\n\t_getLegendItemAt(x, y) {\n\t\tconst me = this;\n\t\tlet i, hitBox, lh;\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\tlh = me.legendHitBoxes;\n\t\t\tfor (i = 0; i < lh.length; ++i) {\n\t\t\t\thitBox = lh[i];\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\treturn me.legendItems[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\thandleEvent(e) {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover && !opts.onLeave) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tconst hoveredItem = me._getLegendItemAt(e.x, e.y);\n\t\tif (type === 'click') {\n\t\t\tif (hoveredItem) {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(opts.onClick, [e, hoveredItem, me], me);\n\t\t\t}\n\t\t} else {\n\t\t\tif (opts.onLeave && hoveredItem !== me._hoveredItem) {\n\t\t\t\tif (me._hoveredItem) {\n\t\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(opts.onLeave, [e, me._hoveredItem, me], me);\n\t\t\t\t}\n\t\t\t\tme._hoveredItem = hoveredItem;\n\t\t\t}\n\t\t\tif (hoveredItem) {\n\t\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(opts.onHover, [e, hoveredItem, me], me);\n\t\t\t}\n\t\t}\n\t}\n}\nfunction resolveOptions(options) {\n\treturn options !== false && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({}, [_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].plugins.legend, options]);\n}\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tconst legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart\n\t});\n\tlayouts.configure(chart, legend, legendOpts);\n\tlayouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\nvar plugin_legend = {\n\tid: 'legend',\n\t_element: Legend,\n\tbeforeInit(chart) {\n\t\tconst legendOpts = resolveOptions(chart.options.legend);\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\tbeforeUpdate(chart) {\n\t\tconst legendOpts = resolveOptions(chart.options.legend);\n\t\tconst legend = chart.legend;\n\t\tif (legendOpts) {\n\t\t\tif (legend) {\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tlayouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\tafterUpdate(chart) {\n\t\tif (chart.legend) {\n\t\t\tchart.legend.buildLabels();\n\t\t}\n\t},\n\tafterEvent(chart, e) {\n\t\tconst legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t},\n\tdefaults: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\talign: 'center',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\t\tonClick(e, legendItem, legend) {\n\t\t\tconst index = legendItem.datasetIndex;\n\t\t\tconst ci = legend.chart;\n\t\t\tif (ci.isDatasetVisible(index)) {\n\t\t\t\tci.hide(index);\n\t\t\t\tlegendItem.hidden = true;\n\t\t\t} else {\n\t\t\t\tci.show(index);\n\t\t\t\tlegendItem.hidden = false;\n\t\t\t}\n\t\t},\n\t\tonHover: null,\n\t\tonLeave: null,\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\tgenerateLabels(chart) {\n\t\t\t\tconst datasets = chart.data.datasets;\n\t\t\t\tconst options = chart.options.legend || {};\n\t\t\t\tconst usePointStyle = options.labels && options.labels.usePointStyle;\n\t\t\t\treturn chart._getSortedDatasetMetas().map((meta) => {\n\t\t\t\t\tconst style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: datasets[meta.index].label,\n\t\t\t\t\t\tfillStyle: style.backgroundColor,\n\t\t\t\t\t\thidden: !meta.visible,\n\t\t\t\t\t\tlineCap: style.borderCapStyle,\n\t\t\t\t\t\tlineDash: style.borderDash,\n\t\t\t\t\t\tlineDashOffset: style.borderDashOffset,\n\t\t\t\t\t\tlineJoin: style.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: style.borderWidth,\n\t\t\t\t\t\tstrokeStyle: style.borderColor,\n\t\t\t\t\t\tpointStyle: style.pointStyle,\n\t\t\t\t\t\trotation: style.rotation,\n\t\t\t\t\t\tdatasetIndex: meta.index\n\t\t\t\t\t};\n\t\t\t\t}, this);\n\t\t\t}\n\t\t},\n\t\ttitle: {\n\t\t\tdisplay: false,\n\t\t\tposition: 'center',\n\t\t\ttext: '',\n\t\t}\n\t}\n};\n\nclass Title extends Element {\n\tconstructor(config) {\n\t\tsuper();\n\t\tObject.assign(this, config);\n\t\tthis.chart = config.chart;\n\t\tthis.options = config.options;\n\t\tthis.ctx = config.ctx;\n\t\tthis._margins = undefined;\n\t\tthis._padding = undefined;\n\t\tthis.top = undefined;\n\t\tthis.bottom = undefined;\n\t\tthis.left = undefined;\n\t\tthis.right = undefined;\n\t\tthis.width = undefined;\n\t\tthis.height = undefined;\n\t\tthis.maxWidth = undefined;\n\t\tthis.maxHeight = undefined;\n\t\tthis.position = undefined;\n\t\tthis.weight = undefined;\n\t\tthis.fullWidth = undefined;\n\t}\n\tbeforeUpdate() {}\n\tupdate(maxWidth, maxHeight, margins) {\n\t\tconst me = this;\n\t\tme.beforeUpdate();\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme._margins = margins;\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\tme.afterUpdate();\n\t}\n\tafterUpdate() {}\n\tbeforeSetDimensions() {}\n\tsetDimensions() {\n\t\tconst me = this;\n\t\tif (me.isHorizontal()) {\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\t}\n\tafterSetDimensions() {}\n\tbeforeBuildLabels() {}\n\tbuildLabels() {}\n\tafterBuildLabels() {}\n\tbeforeFit() {}\n\tfit() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst minSize = {};\n\t\tconst isHorizontal = me.isHorizontal();\n\t\tif (!opts.display) {\n\t\t\tme.width = minSize.width = me.height = minSize.height = 0;\n\t\t\treturn;\n\t\t}\n\t\tconst lineCount = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(opts.text) ? opts.text.length : 1;\n\t\tme._padding = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(opts.padding);\n\t\tconst textSize = lineCount * Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(opts.font, me.chart.options.font).lineHeight + me._padding.height;\n\t\tme.width = minSize.width = isHorizontal ? me.maxWidth : textSize;\n\t\tme.height = minSize.height = isHorizontal ? textSize : me.maxHeight;\n\t}\n\tafterFit() {}\n\tisHorizontal() {\n\t\tconst pos = this.options.position;\n\t\treturn pos === 'top' || pos === 'bottom';\n\t}\n\tdraw() {\n\t\tconst me = this;\n\t\tconst ctx = me.ctx;\n\t\tconst opts = me.options;\n\t\tif (!opts.display) {\n\t\t\treturn;\n\t\t}\n\t\tconst fontOpts = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(opts.font, me.chart.options.font);\n\t\tconst lineHeight = fontOpts.lineHeight;\n\t\tconst offset = lineHeight / 2 + me._padding.top;\n\t\tlet rotation = 0;\n\t\tconst top = me.top;\n\t\tconst left = me.left;\n\t\tconst bottom = me.bottom;\n\t\tconst right = me.right;\n\t\tlet maxWidth, titleX, titleY;\n\t\tlet align;\n\t\tif (me.isHorizontal()) {\n\t\t\tswitch (opts.align) {\n\t\t\tcase 'start':\n\t\t\t\ttitleX = left;\n\t\t\t\talign = 'left';\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\ttitleX = right;\n\t\t\t\talign = 'right';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttitleX = left + ((right - left) / 2);\n\t\t\t\talign = 'center';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttitleY = top + offset;\n\t\t\tmaxWidth = right - left;\n\t\t} else {\n\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\tswitch (opts.align) {\n\t\t\tcase 'start':\n\t\t\t\ttitleY = opts.position === 'left' ? bottom : top;\n\t\t\t\talign = 'left';\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\ttitleY = opts.position === 'left' ? top : bottom;\n\t\t\t\talign = 'right';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\talign = 'center';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmaxWidth = bottom - top;\n\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t}\n\t\tctx.save();\n\t\tctx.fillStyle = fontOpts.color;\n\t\tctx.font = fontOpts.string;\n\t\tctx.translate(titleX, titleY);\n\t\tctx.rotate(rotation);\n\t\tctx.textAlign = align;\n\t\tctx.textBaseline = 'middle';\n\t\tconst text = opts.text;\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(text)) {\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\ty += lineHeight;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t}\n\t\tctx.restore();\n\t}\n}\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\tconst title = new Title({\n\t\tctx: chart.ctx,\n\t\toptions: titleOpts,\n\t\tchart\n\t});\n\tlayouts.configure(chart, title, titleOpts);\n\tlayouts.addBox(chart, title);\n\tchart.titleBlock = title;\n}\nvar plugin_title = {\n\tid: 'title',\n\t_element: Title,\n\tbeforeInit(chart) {\n\t\tconst titleOpts = chart.options.title;\n\t\tif (titleOpts) {\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t}\n\t},\n\tbeforeUpdate(chart) {\n\t\tconst titleOpts = chart.options.title;\n\t\tconst titleBlock = chart.titleBlock;\n\t\tif (titleOpts) {\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(titleOpts, _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].plugins.title);\n\t\t\tif (titleBlock) {\n\t\t\t\tlayouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t} else if (titleBlock) {\n\t\t\tlayouts.removeBox(chart, titleBlock);\n\t\t\tdelete chart.titleBlock;\n\t\t}\n\t},\n\tdefaults: {\n\t\talign: 'center',\n\t\tdisplay: false,\n\t\tfont: {\n\t\t\tstyle: 'bold',\n\t\t},\n\t\tfullWidth: true,\n\t\tpadding: 10,\n\t\tposition: 'top',\n\t\ttext: '',\n\t\tweight: 2000\n\t}\n};\n\nconst positioners = {\n\taverage(items) {\n\t\tif (!items.length) {\n\t\t\treturn false;\n\t\t}\n\t\tlet i, len;\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tlet count = 0;\n\t\tfor (i = 0, len = items.length; i < len; ++i) {\n\t\t\tconst el = items[i].element;\n\t\t\tif (el && el.hasValue()) {\n\t\t\t\tconst pos = el.tooltipPosition();\n\t\t\t\tx += pos.x;\n\t\t\t\ty += pos.y;\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tx: x / count,\n\t\t\ty: y / count\n\t\t};\n\t},\n\tnearest(items, eventPosition) {\n\t\tlet x = eventPosition.x;\n\t\tlet y = eventPosition.y;\n\t\tlet minDistance = Number.POSITIVE_INFINITY;\n\t\tlet i, len, nearestElement;\n\t\tfor (i = 0, len = items.length; i < len; ++i) {\n\t\t\tconst el = items[i].element;\n\t\t\tif (el && el.hasValue()) {\n\t\t\t\tconst center = el.getCenterPoint();\n\t\t\t\tconst d = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ab\"])(eventPosition, center);\n\t\t\t\tif (d < minDistance) {\n\t\t\t\t\tminDistance = d;\n\t\t\t\t\tnearestElement = el;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nearestElement) {\n\t\t\tconst tp = nearestElement.tooltipPosition();\n\t\t\tx = tp.x;\n\t\t\ty = tp.y;\n\t\t}\n\t\treturn {\n\t\t\tx,\n\t\t\ty\n\t\t};\n\t}\n};\nfunction pushOrConcat(base, toPush) {\n\tif (toPush) {\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(toPush)) {\n\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t} else {\n\t\t\tbase.push(toPush);\n\t\t}\n\t}\n\treturn base;\n}\nfunction splitNewlines(str) {\n\tif ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n\t\treturn str.split('\\n');\n\t}\n\treturn str;\n}\nfunction createTooltipItem(chart, item) {\n\tconst {element, datasetIndex, index} = item;\n\tconst controller = chart.getDatasetMeta(datasetIndex).controller;\n\tconst {label, value} = controller.getLabelAndValue(index);\n\treturn {\n\t\tchart,\n\t\tlabel,\n\t\tdataPoint: controller.getParsed(index),\n\t\tformattedValue: value,\n\t\tdataset: controller.getDataset(),\n\t\tdataIndex: index,\n\t\tdatasetIndex,\n\t\telement\n\t};\n}\nfunction resolveOptions$1(options, fallbackFont) {\n\toptions = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({}, [_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].plugins.tooltip, options]);\n\toptions.bodyFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(options.bodyFont, fallbackFont);\n\toptions.titleFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(options.titleFont, fallbackFont);\n\toptions.footerFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(options.footerFont, fallbackFont);\n\toptions.boxHeight = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.boxHeight, options.bodyFont.size);\n\toptions.boxWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.boxWidth, options.bodyFont.size);\n\treturn options;\n}\nfunction getTooltipSize(tooltip) {\n\tconst ctx = tooltip._chart.ctx;\n\tconst {body, footer, options, title} = tooltip;\n\tconst {bodyFont, footerFont, titleFont, boxWidth, boxHeight} = options;\n\tconst titleLineCount = title.length;\n\tconst footerLineCount = footer.length;\n\tconst bodyLineItemCount = body.length;\n\tlet height = options.yPadding * 2;\n\tlet width = 0;\n\tlet combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n\tcombinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\tif (titleLineCount) {\n\t\theight += titleLineCount * titleFont.size\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n\t}\n\tif (combinedBodyLength) {\n\t\tconst bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.size) : bodyFont.size;\n\t\theight += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.size\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n\t}\n\tif (footerLineCount) {\n\t\theight += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.size\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n\t}\n\tlet widthPadding = 0;\n\tconst maxLineWidth = function(line) {\n\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t};\n\tctx.save();\n\tctx.font = titleFont.string;\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(tooltip.title, maxLineWidth);\n\tctx.font = bodyFont.string;\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\twidthPadding = options.displayColors ? (boxWidth + 2) : 0;\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(body, (bodyItem) => {\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(bodyItem.before, maxLineWidth);\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(bodyItem.lines, maxLineWidth);\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(bodyItem.after, maxLineWidth);\n\t});\n\twidthPadding = 0;\n\tctx.font = footerFont.string;\n\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(tooltip.footer, maxLineWidth);\n\tctx.restore();\n\twidth += 2 * options.xPadding;\n\treturn {width, height};\n}\nfunction determineAlignment(chart, options, size) {\n\tconst {x, y, width, height} = size;\n\tconst chartArea = chart.chartArea;\n\tlet xAlign = 'center';\n\tlet yAlign = 'center';\n\tif (y < height) {\n\t\tyAlign = 'top';\n\t} else if (y > (chart.height - height)) {\n\t\tyAlign = 'bottom';\n\t}\n\tlet lf, rf;\n\tconst midX = (chartArea.left + chartArea.right) / 2;\n\tconst midY = (chartArea.top + chartArea.bottom) / 2;\n\tif (yAlign === 'center') {\n\t\tlf = (value) => value <= midX;\n\t\trf = (value) => value > midX;\n\t} else {\n\t\tlf = (value) => value <= (width / 2);\n\t\trf = (value) => value >= (chart.width - (width / 2));\n\t}\n\tconst olf = (value) => value + width + options.caretSize + options.caretPadding > chart.width;\n\tconst orf = (value) => value - width - options.caretSize - options.caretPadding < 0;\n\tconst yf = (value) => value <= midY ? 'top' : 'bottom';\n\tif (lf(x)) {\n\t\txAlign = 'left';\n\t\tif (olf(x)) {\n\t\t\txAlign = 'center';\n\t\t\tyAlign = yf(y);\n\t\t}\n\t} else if (rf(x)) {\n\t\txAlign = 'right';\n\t\tif (orf(x)) {\n\t\t\txAlign = 'center';\n\t\t\tyAlign = yf(y);\n\t\t}\n\t}\n\treturn {\n\t\txAlign: options.xAlign ? options.xAlign : xAlign,\n\t\tyAlign: options.yAlign ? options.yAlign : yAlign\n\t};\n}\nfunction alignX(size, xAlign, chartWidth) {\n\tlet {x, width} = size;\n\tif (xAlign === 'right') {\n\t\tx -= width;\n\t} else if (xAlign === 'center') {\n\t\tx -= (width / 2);\n\t\tif (x + width > chartWidth) {\n\t\t\tx = chartWidth - width;\n\t\t}\n\t\tif (x < 0) {\n\t\t\tx = 0;\n\t\t}\n\t}\n\treturn x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n\tlet {y, height} = size;\n\tif (yAlign === 'top') {\n\t\ty += paddingAndSize;\n\t} else if (yAlign === 'bottom') {\n\t\ty -= height + paddingAndSize;\n\t} else {\n\t\ty -= (height / 2);\n\t}\n\treturn y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n\tconst {caretSize, caretPadding, cornerRadius} = options;\n\tconst {xAlign, yAlign} = alignment;\n\tconst paddingAndSize = caretSize + caretPadding;\n\tconst radiusAndPadding = cornerRadius + caretPadding;\n\tlet x = alignX(size, xAlign, chart.width);\n\tconst y = alignY(size, yAlign, paddingAndSize);\n\tif (yAlign === 'center') {\n\t\tif (xAlign === 'left') {\n\t\t\tx += paddingAndSize;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx -= paddingAndSize;\n\t\t}\n\t} else if (xAlign === 'left') {\n\t\tx -= radiusAndPadding;\n\t} else if (xAlign === 'right') {\n\t\tx += radiusAndPadding;\n\t}\n\treturn {x, y};\n}\nfunction getAlignedX(tooltip, align) {\n\tconst options = tooltip.options;\n\treturn align === 'center'\n\t\t? tooltip.x + tooltip.width / 2\n\t\t: align === 'right'\n\t\t\t? tooltip.x + tooltip.width - options.xPadding\n\t\t\t: tooltip.x + options.xPadding;\n}\nfunction getBeforeAfterBodyLines(callback) {\n\treturn pushOrConcat([], splitNewlines(callback));\n}\nclass Tooltip extends Element {\n\tconstructor(config) {\n\t\tsuper();\n\t\tthis.opacity = 0;\n\t\tthis._active = [];\n\t\tthis._chart = config._chart;\n\t\tthis._eventPosition = undefined;\n\t\tthis._size = undefined;\n\t\tthis._cachedAnimations = undefined;\n\t\tthis.$animations = undefined;\n\t\tthis.options = undefined;\n\t\tthis.dataPoints = undefined;\n\t\tthis.title = undefined;\n\t\tthis.beforeBody = undefined;\n\t\tthis.body = undefined;\n\t\tthis.afterBody = undefined;\n\t\tthis.footer = undefined;\n\t\tthis.xAlign = undefined;\n\t\tthis.yAlign = undefined;\n\t\tthis.x = undefined;\n\t\tthis.y = undefined;\n\t\tthis.height = undefined;\n\t\tthis.width = undefined;\n\t\tthis.caretX = undefined;\n\t\tthis.caretY = undefined;\n\t\tthis.labelColors = undefined;\n\t\tthis.labelTextColors = undefined;\n\t\tthis.initialize();\n\t}\n\tinitialize() {\n\t\tconst me = this;\n\t\tconst chartOpts = me._chart.options;\n\t\tme.options = resolveOptions$1(chartOpts.tooltips, chartOpts.font);\n\t}\n\t_resolveAnimations() {\n\t\tconst me = this;\n\t\tconst cached = me._cachedAnimations;\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\t\tconst chart = me._chart;\n\t\tconst options = me.options;\n\t\tconst opts = options.enabled && chart.options.animation && options.animation;\n\t\tconst animations = new Animations(me._chart, opts);\n\t\tme._cachedAnimations = Object.freeze(animations);\n\t\treturn animations;\n\t}\n\tgetTitle(context) {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst callbacks = opts.callbacks;\n\t\tconst beforeTitle = callbacks.beforeTitle.apply(me, [context]);\n\t\tconst title = callbacks.title.apply(me, [context]);\n\t\tconst afterTitle = callbacks.afterTitle.apply(me, [context]);\n\t\tlet lines = [];\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\n\t\treturn lines;\n\t}\n\tgetBeforeBody(tooltipItems) {\n\t\treturn getBeforeAfterBodyLines(this.options.callbacks.beforeBody.apply(this, [tooltipItems]));\n\t}\n\tgetBody(tooltipItems) {\n\t\tconst me = this;\n\t\tconst callbacks = me.options.callbacks;\n\t\tconst bodyItems = [];\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(tooltipItems, (context) => {\n\t\t\tconst bodyItem = {\n\t\t\t\tbefore: [],\n\t\t\t\tlines: [],\n\t\t\t\tafter: []\n\t\t\t};\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, context)));\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, context));\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, context)));\n\t\t\tbodyItems.push(bodyItem);\n\t\t});\n\t\treturn bodyItems;\n\t}\n\tgetAfterBody(tooltipItems) {\n\t\treturn getBeforeAfterBodyLines(this.options.callbacks.afterBody.apply(this, [tooltipItems]));\n\t}\n\tgetFooter(tooltipItems) {\n\t\tconst me = this;\n\t\tconst callbacks = me.options.callbacks;\n\t\tconst beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);\n\t\tconst footer = callbacks.footer.apply(me, [tooltipItems]);\n\t\tconst afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);\n\t\tlet lines = [];\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\n\t\treturn lines;\n\t}\n\t_createItems() {\n\t\tconst me = this;\n\t\tconst active = me._active;\n\t\tconst options = me.options;\n\t\tconst data = me._chart.data;\n\t\tconst labelColors = [];\n\t\tconst labelTextColors = [];\n\t\tlet tooltipItems = [];\n\t\tlet i, len;\n\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\ttooltipItems.push(createTooltipItem(me._chart, active[i]));\n\t\t}\n\t\tif (options.filter) {\n\t\t\ttooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n\t\t}\n\t\tif (options.itemSort) {\n\t\t\ttooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n\t\t}\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(tooltipItems, (context) => {\n\t\t\tlabelColors.push(options.callbacks.labelColor.call(me, context));\n\t\t\tlabelTextColors.push(options.callbacks.labelTextColor.call(me, context));\n\t\t});\n\t\tme.labelColors = labelColors;\n\t\tme.labelTextColors = labelTextColors;\n\t\tme.dataPoints = tooltipItems;\n\t\treturn tooltipItems;\n\t}\n\tupdate(changed) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst active = me._active;\n\t\tlet properties;\n\t\tif (!active.length) {\n\t\t\tif (me.opacity !== 0) {\n\t\t\t\tproperties = {\n\t\t\t\t\topacity: 0\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tconst position = positioners[options.position].call(me, active, me._eventPosition);\n\t\t\tconst tooltipItems = me._createItems();\n\t\t\tme.title = me.getTitle(tooltipItems);\n\t\t\tme.beforeBody = me.getBeforeBody(tooltipItems);\n\t\t\tme.body = me.getBody(tooltipItems);\n\t\t\tme.afterBody = me.getAfterBody(tooltipItems);\n\t\t\tme.footer = me.getFooter(tooltipItems);\n\t\t\tconst size = me._size = getTooltipSize(me);\n\t\t\tconst positionAndSize = Object.assign({}, position, size);\n\t\t\tconst alignment = determineAlignment(me._chart, options, positionAndSize);\n\t\t\tconst backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, me._chart);\n\t\t\tme.xAlign = alignment.xAlign;\n\t\t\tme.yAlign = alignment.yAlign;\n\t\t\tproperties = {\n\t\t\t\topacity: 1,\n\t\t\t\tx: backgroundPoint.x,\n\t\t\t\ty: backgroundPoint.y,\n\t\t\t\twidth: size.width,\n\t\t\t\theight: size.height,\n\t\t\t\tcaretX: position.x,\n\t\t\t\tcaretY: position.y\n\t\t\t};\n\t\t}\n\t\tif (properties) {\n\t\t\tme._resolveAnimations().update(me, properties);\n\t\t}\n\t\tif (changed && options.custom) {\n\t\t\toptions.custom.call(me, {chart: me._chart, tooltip: me});\n\t\t}\n\t}\n\tdrawCaret(tooltipPoint, ctx, size) {\n\t\tconst caretPosition = this.getCaretPosition(tooltipPoint, size);\n\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t}\n\tgetCaretPosition(tooltipPoint, size) {\n\t\tconst {xAlign, yAlign, options} = this;\n\t\tconst {cornerRadius, caretSize} = options;\n\t\tconst {x: ptX, y: ptY} = tooltipPoint;\n\t\tconst {width, height} = size;\n\t\tlet x1, x2, x3, y1, y2, y3;\n\t\tif (yAlign === 'center') {\n\t\t\ty2 = ptY + (height / 2);\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx1 = ptX;\n\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\ty3 = y2 - caretSize;\n\t\t\t} else {\n\t\t\t\tx1 = ptX + width;\n\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\ty3 = y2 + caretSize;\n\t\t\t}\n\t\t\tx3 = x1;\n\t\t} else {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t} else {\n\t\t\t\tx2 = this.caretX;\n\t\t\t}\n\t\t\tif (yAlign === 'top') {\n\t\t\t\ty1 = ptY;\n\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\tx3 = x2 + caretSize;\n\t\t\t} else {\n\t\t\t\ty1 = ptY + height;\n\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\tx1 = x2 + caretSize;\n\t\t\t\tx3 = x2 - caretSize;\n\t\t\t}\n\t\t\ty3 = y1;\n\t\t}\n\t\treturn {x1, x2, x3, y1, y2, y3};\n\t}\n\tdrawTitle(pt, ctx) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst title = me.title;\n\t\tconst length = title.length;\n\t\tlet titleFont, titleSpacing, i;\n\t\tif (length) {\n\t\t\tconst rtlHelper = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(options.rtl, me.x, me.width);\n\t\t\tpt.x = getAlignedX(me, options.titleAlign);\n\t\t\tctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n\t\t\tctx.textBaseline = 'middle';\n\t\t\ttitleFont = options.titleFont;\n\t\t\ttitleSpacing = options.titleSpacing;\n\t\t\tctx.fillStyle = options.titleFont.color;\n\t\t\tctx.font = titleFont.string;\n\t\t\tfor (i = 0; i < length; ++i) {\n\t\t\t\tctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.size / 2);\n\t\t\t\tpt.y += titleFont.size + titleSpacing;\n\t\t\t\tif (i + 1 === length) {\n\t\t\t\t\tpt.y += options.titleMarginBottom - titleSpacing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_drawColorBox(ctx, pt, i, rtlHelper) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst labelColors = me.labelColors[i];\n\t\tconst {boxHeight, boxWidth, bodyFont} = options;\n\t\tconst colorX = getAlignedX(me, 'left');\n\t\tconst rtlColorX = rtlHelper.x(colorX);\n\t\tconst yOffSet = boxHeight < bodyFont.size ? (bodyFont.size - boxHeight) / 2 : 0;\n\t\tconst colorY = pt.y + yOffSet;\n\t\tctx.fillStyle = options.multiKeyBackground;\n\t\tctx.fillRect(rtlHelper.leftForLtr(rtlColorX, boxWidth), colorY, boxWidth, boxHeight);\n\t\tctx.lineWidth = 1;\n\t\tctx.strokeStyle = labelColors.borderColor;\n\t\tctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, boxWidth), colorY, boxWidth, boxHeight);\n\t\tctx.fillStyle = labelColors.backgroundColor;\n\t\tctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2), colorY + 1, boxWidth - 2, boxHeight - 2);\n\t\tctx.fillStyle = me.labelTextColors[i];\n\t}\n\tdrawBody(pt, ctx) {\n\t\tconst me = this;\n\t\tconst {body, options} = me;\n\t\tconst {bodyFont, bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth} = options;\n\t\tlet bodyLineHeight = bodyFont.size;\n\t\tlet xLinePadding = 0;\n\t\tconst rtlHelper = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(options.rtl, me.x, me.width);\n\t\tconst fillLineOfText = function(line) {\n\t\t\tctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n\t\t\tpt.y += bodyLineHeight + bodySpacing;\n\t\t};\n\t\tconst bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n\t\tlet bodyItem, textColor, lines, i, j, ilen, jlen;\n\t\tctx.textAlign = bodyAlign;\n\t\tctx.textBaseline = 'middle';\n\t\tctx.font = bodyFont.string;\n\t\tpt.x = getAlignedX(me, bodyAlignForCalculation);\n\t\tctx.fillStyle = bodyFont.color;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(me.beforeBody, fillLineOfText);\n\t\txLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n\t\t\t? bodyAlign === 'center' ? (boxWidth / 2 + 1) : (boxWidth + 2)\n\t\t\t: 0;\n\t\tfor (i = 0, ilen = body.length; i < ilen; ++i) {\n\t\t\tbodyItem = body[i];\n\t\t\ttextColor = me.labelTextColors[i];\n\t\t\tctx.fillStyle = textColor;\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(bodyItem.before, fillLineOfText);\n\t\t\tlines = bodyItem.lines;\n\t\t\tif (displayColors && lines.length) {\n\t\t\t\tme._drawColorBox(ctx, pt, i, rtlHelper);\n\t\t\t\tbodyLineHeight = Math.max(bodyFont.size, boxHeight);\n\t\t\t}\n\t\t\tfor (j = 0, jlen = lines.length; j < jlen; ++j) {\n\t\t\t\tfillLineOfText(lines[j]);\n\t\t\t\tbodyLineHeight = bodyFont.size;\n\t\t\t}\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(bodyItem.after, fillLineOfText);\n\t\t}\n\t\txLinePadding = 0;\n\t\tbodyLineHeight = bodyFont.size;\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(me.afterBody, fillLineOfText);\n\t\tpt.y -= bodySpacing;\n\t}\n\tdrawFooter(pt, ctx) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst footer = me.footer;\n\t\tconst length = footer.length;\n\t\tlet footerFont, i;\n\t\tif (length) {\n\t\t\tconst rtlHelper = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(options.rtl, me.x, me.width);\n\t\t\tpt.x = getAlignedX(me, options.footerAlign);\n\t\t\tpt.y += options.footerMarginTop;\n\t\t\tctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tfooterFont = options.footerFont;\n\t\t\tctx.fillStyle = options.footerFont.color;\n\t\t\tctx.font = footerFont.string;\n\t\t\tfor (i = 0; i < length; ++i) {\n\t\t\t\tctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.size / 2);\n\t\t\t\tpt.y += footerFont.size + options.footerSpacing;\n\t\t\t}\n\t\t}\n\t}\n\tdrawBackground(pt, ctx, tooltipSize) {\n\t\tconst {xAlign, yAlign, options} = this;\n\t\tconst {x, y} = pt;\n\t\tconst {width, height} = tooltipSize;\n\t\tconst radius = options.cornerRadius;\n\t\tctx.fillStyle = options.backgroundColor;\n\t\tctx.strokeStyle = options.borderColor;\n\t\tctx.lineWidth = options.borderWidth;\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tif (yAlign === 'top') {\n\t\t\tthis.drawCaret(pt, ctx, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\tthis.drawCaret(pt, ctx, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tif (yAlign === 'bottom') {\n\t\t\tthis.drawCaret(pt, ctx, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\tthis.drawCaret(pt, ctx, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t\tctx.fill();\n\t\tif (options.borderWidth > 0) {\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\t_updateAnimationTarget() {\n\t\tconst me = this;\n\t\tconst chart = me._chart;\n\t\tconst options = me.options;\n\t\tconst anims = me.$animations;\n\t\tconst animX = anims && anims.x;\n\t\tconst animY = anims && anims.y;\n\t\tif (animX || animY) {\n\t\t\tconst position = positioners[options.position].call(me, me._active, me._eventPosition);\n\t\t\tif (!position) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst size = me._size = getTooltipSize(me);\n\t\t\tconst positionAndSize = Object.assign({}, position, me._size);\n\t\t\tconst alignment = determineAlignment(chart, options, positionAndSize);\n\t\t\tconst point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n\t\t\tif (animX._to !== point.x || animY._to !== point.y) {\n\t\t\t\tme.xAlign = alignment.xAlign;\n\t\t\t\tme.yAlign = alignment.yAlign;\n\t\t\t\tme.width = size.width;\n\t\t\t\tme.height = size.height;\n\t\t\t\tme.caretX = position.x;\n\t\t\t\tme.caretY = position.y;\n\t\t\t\tme._resolveAnimations().update(me, point);\n\t\t\t}\n\t\t}\n\t}\n\tdraw(ctx) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tlet opacity = me.opacity;\n\t\tif (!opacity) {\n\t\t\treturn;\n\t\t}\n\t\tme._updateAnimationTarget();\n\t\tconst tooltipSize = {\n\t\t\twidth: me.width,\n\t\t\theight: me.height\n\t\t};\n\t\tconst pt = {\n\t\t\tx: me.x,\n\t\t\ty: me.y\n\t\t};\n\t\topacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\t\tconst hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;\n\t\tif (options.enabled && hasTooltipContent) {\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tme.drawBackground(pt, ctx, tooltipSize);\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a9\"])(ctx, options.textDirection);\n\t\t\tpt.y += options.yPadding;\n\t\t\tme.drawTitle(pt, ctx);\n\t\t\tme.drawBody(pt, ctx);\n\t\t\tme.drawFooter(pt, ctx);\n\t\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"aa\"])(ctx, options.textDirection);\n\t\t\tctx.restore();\n\t\t}\n\t}\n\thandleEvent(e, replay) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst lastActive = me._active || [];\n\t\tlet changed = false;\n\t\tlet active = [];\n\t\tif (e.type !== 'mouseout') {\n\t\t\tactive = me._chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\t\t\tif (options.reverse) {\n\t\t\t\tactive.reverse();\n\t\t\t}\n\t\t}\n\t\tconst position = positioners[options.position].call(me, active, e);\n\t\tconst positionChanged = this.caretX !== position.x || this.caretY !== position.y;\n\t\tchanged = replay || !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"U\"])(active, lastActive) || positionChanged;\n\t\tif (changed) {\n\t\t\tme._active = active;\n\t\t\tif (options.enabled || options.custom) {\n\t\t\t\tme._eventPosition = {\n\t\t\t\t\tx: e.x,\n\t\t\t\t\ty: e.y\n\t\t\t\t};\n\t\t\t\tme.update(true);\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n\tid: 'tooltip',\n\t_element: Tooltip,\n\tpositioners,\n\tafterInit(chart) {\n\t\tconst tooltipOpts = chart.options.tooltips;\n\t\tif (tooltipOpts) {\n\t\t\tchart.tooltip = new Tooltip({_chart: chart});\n\t\t}\n\t},\n\tbeforeUpdate(chart) {\n\t\tif (chart.tooltip) {\n\t\t\tchart.tooltip.initialize();\n\t\t}\n\t},\n\treset(chart) {\n\t\tif (chart.tooltip) {\n\t\t\tchart.tooltip.initialize();\n\t\t}\n\t},\n\tafterDraw(chart) {\n\t\tconst tooltip = chart.tooltip;\n\t\tconst args = {\n\t\t\ttooltip\n\t\t};\n\t\tif (chart._plugins.notify(chart, 'beforeTooltipDraw', [args]) === false) {\n\t\t\treturn;\n\t\t}\n\t\tif (tooltip) {\n\t\t\ttooltip.draw(chart.ctx);\n\t\t}\n\t\tchart._plugins.notify(chart, 'afterTooltipDraw', [args]);\n\t},\n\tafterEvent(chart, e, replay) {\n\t\tif (chart.tooltip) {\n\t\t\tconst useFinalPosition = replay;\n\t\t\tchart.tooltip.handleEvent(e, useFinalPosition);\n\t\t}\n\t},\n\tdefaults: {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFont: {\n\t\t\tstyle: 'bold',\n\t\t\tcolor: '#fff',\n\t\t},\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFont: {\n\t\t\tcolor: '#fff',\n\t\t},\n\t\tbodyAlign: 'left',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFont: {\n\t\t\tcolor: '#fff',\n\t\t\tstyle: 'bold',\n\t\t},\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tanimation: {\n\t\t\tduration: 400,\n\t\t\teasing: 'easeOutQuart',\n\t\t\tnumbers: {\n\t\t\t\ttype: 'number',\n\t\t\t\tproperties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\teasing: 'linear',\n\t\t\t\tduration: 200\n\t\t\t}\n\t\t},\n\t\tcallbacks: {\n\t\t\tbeforeTitle: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\ttitle(tooltipItems) {\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tconst item = tooltipItems[0];\n\t\t\t\t\tconst labels = item.chart.data.labels;\n\t\t\t\t\tconst labelCount = labels ? labels.length : 0;\n\t\t\t\t\tif (item.label) {\n\t\t\t\t\t\treturn item.label;\n\t\t\t\t\t} else if (labelCount > 0 && item.dataIndex < labelCount) {\n\t\t\t\t\t\treturn labels[item.dataIndex];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tafterTitle: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tbeforeBody: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tbeforeLabel: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tlabel(tooltipItem) {\n\t\t\t\tlet label = tooltipItem.dataset.label || '';\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tconst value = tooltipItem.formattedValue;\n\t\t\t\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(value)) {\n\t\t\t\t\tlabel += value;\n\t\t\t\t}\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor(tooltipItem) {\n\t\t\t\tconst meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tconst options = meta.controller.getStyle(tooltipItem.dataIndex);\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: options.borderColor,\n\t\t\t\t\tbackgroundColor: options.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tlabelTextColor() {\n\t\t\t\treturn this.options.bodyFont.color;\n\t\t\t},\n\t\t\tafterLabel: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tafterBody: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tbeforeFooter: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tfooter: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"],\n\t\t\tafterFooter: _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"n\"]\n\t\t}\n\t},\n};\n\nclass CategoryScale extends Scale {\n\tconstructor(cfg) {\n\t\tsuper(cfg);\n\t\tthis._startValue = undefined;\n\t\tthis._valueRange = 0;\n\t}\n\tparse(raw, index) {\n\t\tconst labels = this.getLabels();\n\t\tif (labels[index] === raw) {\n\t\t\treturn index;\n\t\t}\n\t\tconst first = labels.indexOf(raw);\n\t\tconst last = labels.lastIndexOf(raw);\n\t\treturn first === -1 || first !== last ? index : first;\n\t}\n\tdetermineDataLimits() {\n\t\tconst me = this;\n\t\tconst max = me.getLabels().length - 1;\n\t\tme.min = Math.max(me._userMin || 0, 0);\n\t\tme.max = Math.min(me._userMax || max, max);\n\t}\n\tbuildTicks() {\n\t\tconst me = this;\n\t\tconst min = me.min;\n\t\tconst max = me.max;\n\t\tconst offset = me.options.offset;\n\t\tconst ticks = [];\n\t\tlet labels = me.getLabels();\n\t\tlabels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\t\tme._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n\t\tme._startValue = me.min - (offset ? 0.5 : 0);\n\t\tfor (let value = min; value <= max; value++) {\n\t\t\tticks.push({value});\n\t\t}\n\t\treturn ticks;\n\t}\n\tgetLabelForValue(value) {\n\t\tconst me = this;\n\t\tconst labels = me.getLabels();\n\t\tif (value >= 0 && value < labels.length) {\n\t\t\treturn labels[value];\n\t\t}\n\t\treturn value;\n\t}\n\tconfigure() {\n\t\tconst me = this;\n\t\tsuper.configure();\n\t\tif (!me.isHorizontal()) {\n\t\t\tme._reversePixels = !me._reversePixels;\n\t\t}\n\t}\n\tgetPixelForValue(value) {\n\t\tconst me = this;\n\t\tif (typeof value !== 'number') {\n\t\t\tvalue = me.parse(value);\n\t\t}\n\t\treturn me.getPixelForDecimal((value - me._startValue) / me._valueRange);\n\t}\n\tgetPixelForTick(index) {\n\t\tconst me = this;\n\t\tconst ticks = me.ticks;\n\t\tif (index < 0 || index > ticks.length - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn me.getPixelForValue(ticks[index].value);\n\t}\n\tgetValueForPixel(pixel) {\n\t\tconst me = this;\n\t\tconst value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\n\t\treturn Math.min(Math.max(value, 0), me.ticks.length - 1);\n\t}\n\tgetBasePixel() {\n\t\treturn this.bottom;\n\t}\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n\tticks: {\n\t\tcallback: CategoryScale.prototype.getLabelForValue\n\t}\n};\n\nfunction niceNum(range) {\n\tconst exponent = Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(range));\n\tconst fraction = range / Math.pow(10, exponent);\n\tlet niceFraction;\n\tif (fraction <= 1.0) {\n\t\tniceFraction = 1;\n\t} else if (fraction <= 2) {\n\t\tniceFraction = 2;\n\t} else if (fraction <= 5) {\n\t\tniceFraction = 5;\n\t} else {\n\t\tniceFraction = 10;\n\t}\n\treturn niceFraction * Math.pow(10, exponent);\n}\nfunction generateTicks(generationOptions, dataRange) {\n\tconst ticks = [];\n\tconst MIN_SPACING = 1e-14;\n\tconst {stepSize, min, max, precision} = generationOptions;\n\tconst unit = stepSize || 1;\n\tconst maxNumSpaces = generationOptions.maxTicks - 1;\n\tconst {min: rmin, max: rmax} = dataRange;\n\tlet spacing = niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n\tlet factor, niceMin, niceMax, numSpaces;\n\tif (spacing < MIN_SPACING && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(min) && Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(max)) {\n\t\treturn [{value: rmin}, {value: rmax}];\n\t}\n\tnumSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\tif (numSpaces > maxNumSpaces) {\n\t\tspacing = niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n\t}\n\tif (stepSize || Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(precision)) {\n\t\tfactor = Math.pow(10, Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ad\"])(spacing));\n\t} else {\n\t\tfactor = Math.pow(10, precision);\n\t\tspacing = Math.ceil(spacing * factor) / factor;\n\t}\n\tniceMin = Math.floor(rmin / spacing) * spacing;\n\tniceMax = Math.ceil(rmax / spacing) * spacing;\n\tif (stepSize && !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(min) && !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(max)) {\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"af\"])((max - min) / stepSize, spacing / 1000)) {\n\t\t\tniceMin = min;\n\t\t\tniceMax = max;\n\t\t}\n\t}\n\tnumSpaces = (niceMax - niceMin) / spacing;\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ae\"])(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\tniceMin = Math.round(niceMin * factor) / factor;\n\tniceMax = Math.round(niceMax * factor) / factor;\n\tticks.push({value: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(min) ? niceMin : min});\n\tfor (let j = 1; j < numSpaces; ++j) {\n\t\tticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n\t}\n\tticks.push({value: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(max) ? niceMax : max});\n\treturn ticks;\n}\nclass LinearScaleBase extends Scale {\n\tconstructor(cfg) {\n\t\tsuper(cfg);\n\t\tthis.start = undefined;\n\t\tthis.end = undefined;\n\t\tthis._startValue = undefined;\n\t\tthis._endValue = undefined;\n\t\tthis._valueRange = 0;\n\t}\n\tparse(raw, index) {\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(raw)) {\n\t\t\treturn NaN;\n\t\t}\n\t\tif ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n\t\t\treturn NaN;\n\t\t}\n\t\treturn +raw;\n\t}\n\thandleTickRangeOptions() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tif (opts.beginAtZero) {\n\t\t\tconst minSign = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(me.min);\n\t\t\tconst maxSign = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(me.max);\n\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\tme.max = 0;\n\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\tme.min = 0;\n\t\t\t}\n\t\t}\n\t\tconst setMin = opts.min !== undefined || opts.suggestedMin !== undefined;\n\t\tconst setMax = opts.max !== undefined || opts.suggestedMax !== undefined;\n\t\tif (opts.min !== undefined) {\n\t\t\tme.min = opts.min;\n\t\t} else if (opts.suggestedMin !== undefined) {\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = opts.suggestedMin;\n\t\t\t} else {\n\t\t\t\tme.min = Math.min(me.min, opts.suggestedMin);\n\t\t\t}\n\t\t}\n\t\tif (opts.max !== undefined) {\n\t\t\tme.max = opts.max;\n\t\t} else if (opts.suggestedMax !== undefined) {\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = opts.suggestedMax;\n\t\t\t} else {\n\t\t\t\tme.max = Math.max(me.max, opts.suggestedMax);\n\t\t\t}\n\t\t}\n\t\tif (setMin !== setMax) {\n\t\t\tif (me.min >= me.max) {\n\t\t\t\tif (setMin) {\n\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (me.min === me.max) {\n\t\t\tme.max++;\n\t\t\tif (!opts.beginAtZero) {\n\t\t\t\tme.min--;\n\t\t\t}\n\t\t}\n\t}\n\tgetTickLimit() {\n\t\tconst me = this;\n\t\tconst tickOpts = me.options.ticks;\n\t\tlet {maxTicksLimit, stepSize} = tickOpts;\n\t\tlet maxTicks;\n\t\tif (stepSize) {\n\t\t\tmaxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n\t\t} else {\n\t\t\tmaxTicks = me.computeTickLimit();\n\t\t\tmaxTicksLimit = maxTicksLimit || 11;\n\t\t}\n\t\tif (maxTicksLimit) {\n\t\t\tmaxTicks = Math.min(maxTicksLimit, maxTicks);\n\t\t}\n\t\treturn maxTicks;\n\t}\n\tcomputeTickLimit() {\n\t\treturn Number.POSITIVE_INFINITY;\n\t}\n\tbuildTicks() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst tickOpts = opts.ticks;\n\t\tlet maxTicks = me.getTickLimit();\n\t\tmaxTicks = Math.max(2, maxTicks);\n\t\tconst numericGeneratorOptions = {\n\t\t\tmaxTicks,\n\t\t\tmin: opts.min,\n\t\t\tmax: opts.max,\n\t\t\tprecision: tickOpts.precision,\n\t\t\tstepSize: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t};\n\t\tconst ticks = generateTicks(numericGeneratorOptions, me);\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ac\"])(ticks, me, 'value');\n\t\tif (opts.reverse) {\n\t\t\tticks.reverse();\n\t\t\tme.start = me.max;\n\t\t\tme.end = me.min;\n\t\t} else {\n\t\t\tme.start = me.min;\n\t\t\tme.end = me.max;\n\t\t}\n\t\treturn ticks;\n\t}\n\tconfigure() {\n\t\tconst me = this;\n\t\tconst ticks = me.ticks;\n\t\tlet start = me.min;\n\t\tlet end = me.max;\n\t\tsuper.configure();\n\t\tif (me.options.offset && ticks.length) {\n\t\t\tconst offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n\t\t\tstart -= offset;\n\t\t\tend += offset;\n\t\t}\n\t\tme._startValue = start;\n\t\tme._endValue = end;\n\t\tme._valueRange = end - start;\n\t}\n\tgetLabelForValue(value) {\n\t\treturn new Intl.NumberFormat(this.options.locale).format(value);\n\t}\n}\n\nclass LinearScale extends LinearScaleBase {\n\tdetermineDataLimits() {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst {min, max} = me.getMinMax(true);\n\t\tme.min = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(min) ? min : Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.suggestedMin, 0);\n\t\tme.max = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(max) ? max : Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.suggestedMax, 1);\n\t\tif (options.stacked && min > 0) {\n\t\t\tme.min = 0;\n\t\t}\n\t\tme.handleTickRangeOptions();\n\t}\n\tcomputeTickLimit() {\n\t\tconst me = this;\n\t\tif (me.isHorizontal()) {\n\t\t\treturn Math.ceil(me.width / 40);\n\t\t}\n\t\tconst tickFont = me._resolveTickFontOptions(0);\n\t\treturn Math.ceil(me.height / tickFont.lineHeight);\n\t}\n\tgetPixelForValue(value) {\n\t\tconst me = this;\n\t\treturn me.getPixelForDecimal((value - me._startValue) / me._valueRange);\n\t}\n\tgetValueForPixel(pixel) {\n\t\treturn this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n\t}\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n\tticks: {\n\t\tcallback: Ticks.formatters.numeric\n\t}\n};\n\nfunction isMajor(tickVal) {\n\tconst remain = tickVal / (Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(tickVal))));\n\treturn remain === 1;\n}\nfunction finiteOrDefault(value, def) {\n\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(value) ? value : def;\n}\nfunction generateTicks$1(generationOptions, dataRange) {\n\tconst endExp = Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(dataRange.max));\n\tconst endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tconst ticks = [];\n\tlet tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(dataRange.min))));\n\tlet exp = Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(tickVal));\n\tlet significand = Math.floor(tickVal / Math.pow(10, exp));\n\tlet precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\tdo {\n\t\tticks.push({value: tickVal, major: isMajor(tickVal)});\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\tconst lastTick = finiteOrDefault(generationOptions.max, tickVal);\n\tticks.push({value: lastTick, major: isMajor(tickVal)});\n\treturn ticks;\n}\nclass LogarithmicScale extends Scale {\n\tconstructor(cfg) {\n\t\tsuper(cfg);\n\t\tthis.start = undefined;\n\t\tthis.end = undefined;\n\t\tthis._startValue = undefined;\n\t\tthis._valueRange = 0;\n\t}\n\tparse(raw, index) {\n\t\tconst value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n\t\tif (value === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(value) && value > 0 ? value : NaN;\n\t}\n\tdetermineDataLimits() {\n\t\tconst me = this;\n\t\tconst {min, max} = me.getMinMax(true);\n\t\tme.min = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(min) ? Math.max(0, min) : null;\n\t\tme.max = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(max) ? Math.max(0, max) : null;\n\t\tme.handleTickRangeOptions();\n\t}\n\thandleTickRangeOptions() {\n\t\tconst me = this;\n\t\tconst DEFAULT_MIN = 1;\n\t\tconst DEFAULT_MAX = 10;\n\t\tlet min = me.min;\n\t\tlet max = me.max;\n\t\tif (min === max) {\n\t\t\tif (min <= 0) {\n\t\t\t\tmin = DEFAULT_MIN;\n\t\t\t\tmax = DEFAULT_MAX;\n\t\t\t} else {\n\t\t\t\tmin = Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(min)) - 1);\n\t\t\t\tmax = Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(max)) + 1);\n\t\t\t}\n\t\t}\n\t\tif (min <= 0) {\n\t\t\tmin = Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(max)) - 1);\n\t\t}\n\t\tif (max <= 0) {\n\t\t\tmax = Math.pow(10, Math.floor(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(min)) + 1);\n\t\t}\n\t\tme.min = min;\n\t\tme.max = max;\n\t}\n\tbuildTicks() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tconst generationOptions = {\n\t\t\tmin: me._userMin,\n\t\t\tmax: me._userMax\n\t\t};\n\t\tconst ticks = generateTicks$1(generationOptions, me);\n\t\tlet reverse = !me.isHorizontal();\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ac\"])(ticks, me, 'value');\n\t\tif (opts.reverse) {\n\t\t\treverse = !reverse;\n\t\t\tme.start = me.max;\n\t\t\tme.end = me.min;\n\t\t} else {\n\t\t\tme.start = me.min;\n\t\t\tme.end = me.max;\n\t\t}\n\t\tif (reverse) {\n\t\t\tticks.reverse();\n\t\t}\n\t\treturn ticks;\n\t}\n\tgetLabelForValue(value) {\n\t\treturn value === undefined ? '0' : new Intl.NumberFormat(this.options.locale).format(value);\n\t}\n\tconfigure() {\n\t\tconst me = this;\n\t\tconst start = me.min;\n\t\tsuper.configure();\n\t\tme._startValue = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(start);\n\t\tme._valueRange = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(me.max) - Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(start);\n\t}\n\tgetPixelForValue(value) {\n\t\tconst me = this;\n\t\tif (value === undefined || value === 0) {\n\t\t\tvalue = me.min;\n\t\t}\n\t\treturn me.getPixelForDecimal(value === me.min\n\t\t\t? 0\n\t\t\t: (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(value) - me._startValue) / me._valueRange);\n\t}\n\tgetValueForPixel(pixel) {\n\t\tconst me = this;\n\t\tconst decimal = me.getDecimalForPixel(pixel);\n\t\treturn Math.pow(10, me._startValue + decimal * me._valueRange);\n\t}\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n\tticks: {\n\t\tcallback: Ticks.formatters.logarithmic,\n\t\tmajor: {\n\t\t\tenabled: true\n\t\t}\n\t}\n};\n\nfunction getTickBackdropHeight(opts) {\n\tconst tickOpts = opts.ticks;\n\tif (tickOpts.display && opts.display) {\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(tickOpts.font && tickOpts.font.size, _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"].font.size) + tickOpts.backdropPaddingY * 2;\n\t}\n\treturn 0;\n}\nfunction measureLabelSize(ctx, lineHeight, label) {\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label)) {\n\t\treturn {\n\t\t\tw: Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ag\"])(ctx, ctx.font, label),\n\t\t\th: label.length * lineHeight\n\t\t};\n\t}\n\treturn {\n\t\tw: ctx.measureText(label).width,\n\t\th: lineHeight\n\t};\n}\nfunction determineLimits(angle, pos, size, min, max) {\n\tif (angle === min || angle === max) {\n\t\treturn {\n\t\t\tstart: pos - (size / 2),\n\t\t\tend: pos + (size / 2)\n\t\t};\n\t} else if (angle < min || angle > max) {\n\t\treturn {\n\t\t\tstart: pos - size,\n\t\t\tend: pos\n\t\t};\n\t}\n\treturn {\n\t\tstart: pos,\n\t\tend: pos + size\n\t};\n}\nfunction fitWithPointLabels(scale) {\n\tconst furthestLimits = {\n\t\tl: 0,\n\t\tr: scale.width,\n\t\tt: 0,\n\t\tb: scale.height - scale.paddingTop\n\t};\n\tconst furthestAngles = {};\n\tlet i, textSize, pointPosition;\n\tscale._pointLabelSizes = [];\n\tconst valueCount = scale.chart.data.labels.length;\n\tfor (i = 0; i < valueCount; i++) {\n\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n\t\tconst context = {\n\t\t\tchart: scale.chart,\n\t\t\tscale,\n\t\t\tindex: i,\n\t\t\tlabel: scale.pointLabels[i]\n\t\t};\n\t\tconst plFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([scale.options.pointLabels.font], context, i), scale.chart.options.font);\n\t\tscale.ctx.font = plFont.string;\n\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);\n\t\tscale._pointLabelSizes[i] = textSize;\n\t\tconst angleRadians = scale.getIndexAngle(i);\n\t\tconst angle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(angleRadians);\n\t\tconst hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\tconst vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\tfurthestAngles.l = angleRadians;\n\t\t}\n\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\tfurthestAngles.r = angleRadians;\n\t\t}\n\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\tfurthestAngles.t = angleRadians;\n\t\t}\n\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\tfurthestAngles.b = angleRadians;\n\t\t}\n\t}\n\tscale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n}\nfunction getTextAlignForAngle(angle) {\n\tif (angle === 0 || angle === 180) {\n\t\treturn 'center';\n\t} else if (angle < 180) {\n\t\treturn 'left';\n\t}\n\treturn 'right';\n}\nfunction fillText(ctx, text, position, lineHeight) {\n\tlet y = position.y + lineHeight / 2;\n\tlet i, ilen;\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(text)) {\n\t\tfor (i = 0, ilen = text.length; i < ilen; ++i) {\n\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\ty += lineHeight;\n\t\t}\n\t} else {\n\t\tctx.fillText(text, position.x, y);\n\t}\n}\nfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\tif (angle === 90 || angle === 270) {\n\t\tposition.y -= (textSize.h / 2);\n\t} else if (angle > 270 || angle < 90) {\n\t\tposition.y -= textSize.h;\n\t}\n}\nfunction drawPointLabels(scale) {\n\tconst ctx = scale.ctx;\n\tconst opts = scale.options;\n\tconst pointLabelOpts = opts.pointLabels;\n\tconst tickBackdropHeight = getTickBackdropHeight(opts);\n\tconst outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\tctx.save();\n\tctx.textBaseline = 'middle';\n\tfor (let i = scale.chart.data.labels.length - 1; i >= 0; i--) {\n\t\tconst extra = (i === 0 ? tickBackdropHeight / 2 : 0);\n\t\tconst pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\n\t\tconst context = {\n\t\t\tchart: scale.chart,\n\t\t\tscale,\n\t\t\tindex: i,\n\t\t\tlabel: scale.pointLabels[i],\n\t\t};\n\t\tconst plFont = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"P\"])(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([pointLabelOpts.font], context, i), scale.chart.options.font);\n\t\tctx.font = plFont.string;\n\t\tctx.fillStyle = plFont.color;\n\t\tconst angle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(scale.getIndexAngle(i));\n\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\tfillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);\n\t}\n\tctx.restore();\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\tconst ctx = scale.ctx;\n\tconst circular = gridLineOpts.circular;\n\tconst valueCount = scale.chart.data.labels.length;\n\tconst context = {\n\t\tchart: scale.chart,\n\t\tscale,\n\t\tindex,\n\t\ttick: scale.ticks[index],\n\t};\n\tconst lineColor = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLineOpts.color], context, index - 1);\n\tconst lineWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLineOpts.lineWidth], context, index - 1);\n\tlet pointPosition;\n\tif ((!circular && !valueCount) || !lineColor || !lineWidth) {\n\t\treturn;\n\t}\n\tctx.save();\n\tctx.strokeStyle = lineColor;\n\tctx.lineWidth = lineWidth;\n\tif (ctx.setLineDash) {\n\t\tctx.setLineDash(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLineOpts.borderDash, []], context));\n\t\tctx.lineDashOffset = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([gridLineOpts.borderDashOffset], context, index - 1);\n\t}\n\tctx.beginPath();\n\tif (circular) {\n\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t} else {\n\t\tpointPosition = scale.getPointPosition(0, radius);\n\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\t\tfor (let i = 1; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t}\n\t}\n\tctx.closePath();\n\tctx.stroke();\n\tctx.restore();\n}\nfunction numberOrZero(param) {\n\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(param) ? param : 0;\n}\nclass RadialLinearScale extends LinearScaleBase {\n\tconstructor(cfg) {\n\t\tsuper(cfg);\n\t\tthis.xCenter = undefined;\n\t\tthis.yCenter = undefined;\n\t\tthis.drawingArea = undefined;\n\t\tthis.pointLabels = [];\n\t}\n\tinit(options) {\n\t\tsuper.init(options);\n\t\tthis.axis = 'r';\n\t}\n\tsetDimensions() {\n\t\tconst me = this;\n\t\tme.width = me.maxWidth;\n\t\tme.height = me.maxHeight;\n\t\tme.paddingTop = getTickBackdropHeight(me.options) / 2;\n\t\tme.xCenter = Math.floor(me.width / 2);\n\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n\t\tme.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n\t}\n\tdetermineDataLimits() {\n\t\tconst me = this;\n\t\tconst {min, max} = me.getMinMax(false);\n\t\tme.min = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(min) && !isNaN(min) ? min : 0;\n\t\tme.max = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(max) && !isNaN(max) ? max : 0;\n\t\tme.handleTickRangeOptions();\n\t}\n\tcomputeTickLimit() {\n\t\treturn Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n\t}\n\tgenerateTickLabels(ticks) {\n\t\tconst me = this;\n\t\tLinearScaleBase.prototype.generateTickLabels.call(me, ticks);\n\t\tme.pointLabels = me.chart.data.labels.map((value, index) => {\n\t\t\tconst label = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(me.options.pointLabels.callback, [value, index], me);\n\t\t\treturn label || label === 0 ? label : '';\n\t\t});\n\t}\n\tfit() {\n\t\tconst me = this;\n\t\tconst opts = me.options;\n\t\tif (opts.display && opts.pointLabels.display) {\n\t\t\tfitWithPointLabels(me);\n\t\t} else {\n\t\t\tme.setCenterPoint(0, 0, 0, 0);\n\t\t}\n\t}\n\t_setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\tconst me = this;\n\t\tlet radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\tlet radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\tlet radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\tlet radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\t\tme.drawingArea = Math.min(\n\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t}\n\tsetCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\tconst me = this;\n\t\tconst maxRight = me.width - rightMovement - me.drawingArea;\n\t\tconst maxLeft = leftMovement + me.drawingArea;\n\t\tconst maxTop = topMovement + me.drawingArea;\n\t\tconst maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\n\t\tme.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);\n\t\tme.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);\n\t}\n\tgetIndexAngle(index) {\n\t\tconst chart = this.chart;\n\t\tconst angleMultiplier = Math.PI * 2 / chart.data.labels.length;\n\t\tconst options = chart.options || {};\n\t\tconst startAngle = options.startAngle || 0;\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a6\"])(index * angleMultiplier + Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(startAngle));\n\t}\n\tgetDistanceFromCenterForValue(value) {\n\t\tconst me = this;\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(value)) {\n\t\t\treturn NaN;\n\t\t}\n\t\tconst scalingFactor = me.drawingArea / (me.max - me.min);\n\t\tif (me.options.reverse) {\n\t\t\treturn (me.max - value) * scalingFactor;\n\t\t}\n\t\treturn (value - me.min) * scalingFactor;\n\t}\n\tgetValueForDistanceFromCenter(distance) {\n\t\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(distance)) {\n\t\t\treturn NaN;\n\t\t}\n\t\tconst me = this;\n\t\tconst scaledDistance = distance / (me.drawingArea / (me.max - me.min));\n\t\treturn me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;\n\t}\n\tgetPointPosition(index, distanceFromCenter) {\n\t\tconst me = this;\n\t\tconst angle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\treturn {\n\t\t\tx: Math.cos(angle) * distanceFromCenter + me.xCenter,\n\t\t\ty: Math.sin(angle) * distanceFromCenter + me.yCenter,\n\t\t\tangle\n\t\t};\n\t}\n\tgetPointPositionForValue(index, value) {\n\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t}\n\tgetBasePosition(index) {\n\t\treturn this.getPointPositionForValue(index || 0, this.getBaseValue());\n\t}\n\tdrawGrid() {\n\t\tconst me = this;\n\t\tconst ctx = me.ctx;\n\t\tconst opts = me.options;\n\t\tconst gridLineOpts = opts.gridLines;\n\t\tconst angleLineOpts = opts.angleLines;\n\t\tlet i, offset, position;\n\t\tif (opts.pointLabels.display) {\n\t\t\tdrawPointLabels(me);\n\t\t}\n\t\tif (gridLineOpts.display) {\n\t\t\tme.ticks.forEach((tick, index) => {\n\t\t\t\tif (index !== 0) {\n\t\t\t\t\toffset = me.getDistanceFromCenterForValue(me.ticks[index].value);\n\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, offset, index);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (angleLineOpts.display) {\n\t\t\tctx.save();\n\t\t\tfor (i = me.chart.data.labels.length - 1; i >= 0; i--) {\n\t\t\t\tconst context = {\n\t\t\t\t\tchart: me.chart,\n\t\t\t\t\tscale: me,\n\t\t\t\t\tindex: i,\n\t\t\t\t\tlabel: me.pointLabels[i],\n\t\t\t\t};\n\t\t\t\tconst lineWidth = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([angleLineOpts.lineWidth, gridLineOpts.lineWidth], context, i);\n\t\t\t\tconst color = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([angleLineOpts.color, gridLineOpts.color], context, i);\n\t\t\t\tif (!lineWidth || !color) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tctx.lineWidth = lineWidth;\n\t\t\t\tctx.strokeStyle = color;\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\tctx.setLineDash(Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([angleLineOpts.borderDash, gridLineOpts.borderDash, []], context));\n\t\t\t\t\tctx.lineDashOffset = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0], context, i);\n\t\t\t\t}\n\t\t\t\toffset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\n\t\t\t\tposition = me.getPointPosition(i, offset);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(me.xCenter, me.yCenter);\n\t\t\t\tctx.lineTo(position.x, position.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n\tdrawLabels() {\n\t\tconst me = this;\n\t\tconst ctx = me.ctx;\n\t\tconst opts = me.options;\n\t\tconst tickOpts = opts.ticks;\n\t\tif (!tickOpts.display) {\n\t\t\treturn;\n\t\t}\n\t\tconst startAngle = me.getIndexAngle(0);\n\t\tlet offset, width;\n\t\tctx.save();\n\t\tctx.translate(me.xCenter, me.yCenter);\n\t\tctx.rotate(startAngle);\n\t\tctx.textAlign = 'center';\n\t\tctx.textBaseline = 'middle';\n\t\tme.ticks.forEach((tick, index) => {\n\t\t\tconst context = {\n\t\t\t\tchart: me.chart,\n\t\t\t\tscale: me,\n\t\t\t\tindex,\n\t\t\t\ttick,\n\t\t\t};\n\t\t\tif (index === 0 && !opts.reverse) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst tickFont = me._resolveTickFontOptions(index);\n\t\t\tctx.font = tickFont.string;\n\t\t\toffset = me.getDistanceFromCenterForValue(me.ticks[index].value);\n\t\t\tconst showLabelBackdrop = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([tickOpts.showLabelBackdrop], context, index);\n\t\t\tif (showLabelBackdrop) {\n\t\t\t\twidth = ctx.measureText(tick.label).width;\n\t\t\t\tctx.fillStyle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([tickOpts.backdropColor], context, index);\n\t\t\t\tctx.fillRect(\n\t\t\t\t\t-width / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t-offset - tickFont.size / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\twidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY * 2\n\t\t\t\t);\n\t\t\t}\n\t\t\tctx.fillStyle = tickFont.color;\n\t\t\tctx.fillText(tick.label, 0, -offset);\n\t\t});\n\t\tctx.restore();\n\t}\n\tdrawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n\tdisplay: true,\n\tanimate: true,\n\tposition: 'chartArea',\n\tangleLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0,0,0,0.1)',\n\t\tlineWidth: 1,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\tgridLines: {\n\t\tcircular: false\n\t},\n\tticks: {\n\t\tshowLabelBackdrop: true,\n\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\t\tbackdropPaddingY: 2,\n\t\tbackdropPaddingX: 2,\n\t\tcallback: Ticks.formatters.numeric\n\t},\n\tpointLabels: {\n\t\tdisplay: true,\n\t\tfont: {\n\t\t\tsize: 10\n\t\t},\n\t\tcallback(label) {\n\t\t\treturn label;\n\t\t}\n\t}\n};\n\nconst MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nconst INTERVALS = {\n\tmillisecond: {common: true, size: 1, steps: 1000},\n\tsecond: {common: true, size: 1000, steps: 60},\n\tminute: {common: true, size: 60000, steps: 60},\n\thour: {common: true, size: 3600000, steps: 24},\n\tday: {common: true, size: 86400000, steps: 30},\n\tweek: {common: false, size: 604800000, steps: 4},\n\tmonth: {common: true, size: 2.628e9, steps: 12},\n\tquarter: {common: false, size: 7.884e9, steps: 4},\n\tyear: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n\treturn a - b;\n}\nfunction parse(scale, input) {\n\tif (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(input)) {\n\t\treturn null;\n\t}\n\tconst adapter = scale._adapter;\n\tconst options = scale.options.time;\n\tconst {parser, round, isoWeekday} = options;\n\tlet value = input;\n\tif (typeof parser === 'function') {\n\t\tvalue = parser(value);\n\t}\n\tif (!Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(value)) {\n\t\tvalue = typeof parser === 'string'\n\t\t\t? adapter.parse(value, parser)\n\t\t\t: adapter.parse(value);\n\t}\n\tif (value === null) {\n\t\treturn value;\n\t}\n\tif (round) {\n\t\tvalue = round === 'week' && (Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(isoWeekday) || isoWeekday === true)\n\t\t\t? scale._adapter.startOf(value, 'isoWeek', isoWeekday)\n\t\t\t: scale._adapter.startOf(value, round);\n\t}\n\treturn +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tconst ilen = UNITS.length;\n\tfor (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tconst interval = INTERVALS[UNITS[i]];\n\t\tconst factor = interval.steps ? interval.steps : MAX_INTEGER;\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\treturn UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n\tfor (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tconst unit = UNITS[i];\n\t\tif (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n\tfor (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\nfunction addTick(ticks, time, timestamps) {\n\tif (!timestamps) {\n\t\tticks[time] = true;\n\t} else if (timestamps.length) {\n\t\tconst {lo, hi} = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"aj\"])(timestamps, time);\n\t\tconst timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n\t\tticks[timestamp] = true;\n\t}\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n\tconst adapter = scale._adapter;\n\tconst first = +adapter.startOf(ticks[0].value, majorUnit);\n\tconst last = ticks[ticks.length - 1].value;\n\tlet major, index;\n\tfor (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n\t\tindex = map[major];\n\t\tif (index >= 0) {\n\t\t\tticks[index].major = true;\n\t\t}\n\t}\n\treturn ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n\tconst ticks = [];\n\tconst map = {};\n\tconst ilen = values.length;\n\tlet i, value;\n\tfor (i = 0; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmap[value] = i;\n\t\tticks.push({\n\t\t\tvalue,\n\t\t\tmajor: false\n\t\t});\n\t}\n\treturn (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis._cache = {\n\t\t\tdata: [],\n\t\t\tlabels: [],\n\t\t\tall: []\n\t\t};\n\t\tthis._unit = 'day';\n\t\tthis._majorUnit = undefined;\n\t\tthis._offsets = {};\n\t\tthis._normalized = false;\n\t}\n\tinit(scaleOpts, opts) {\n\t\tconst time = scaleOpts.time || (scaleOpts.time = {});\n\t\tconst adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\t\tObject(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(time.displayFormats, adapter.formats());\n\t\tsuper.init(scaleOpts);\n\t\tthis._normalized = opts.normalized;\n\t}\n\tparse(raw, index) {\n\t\tif (raw === undefined) {\n\t\t\treturn NaN;\n\t\t}\n\t\treturn parse(this, raw);\n\t}\n\tinvalidateCaches() {\n\t\tthis._cache = {\n\t\t\tdata: [],\n\t\t\tlabels: [],\n\t\t\tall: []\n\t\t};\n\t}\n\tdetermineDataLimits() {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst adapter = me._adapter;\n\t\tconst unit = options.time.unit || 'day';\n\t\tlet {min, max, minDefined, maxDefined} = me.getUserBounds();\n\t\tfunction _applyBounds(bounds) {\n\t\t\tif (!minDefined && !isNaN(bounds.min)) {\n\t\t\t\tmin = Math.min(min, bounds.min);\n\t\t\t}\n\t\t\tif (!maxDefined && !isNaN(bounds.max)) {\n\t\t\t\tmax = Math.max(max, bounds.max);\n\t\t\t}\n\t\t}\n\t\tif (!minDefined || !maxDefined) {\n\t\t\t_applyBounds(me._getLabelBounds());\n\t\t\tif (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n\t\t\t\t_applyBounds(me.getMinMax(false));\n\t\t\t}\n\t\t}\n\t\tmin = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n\t\tmax = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\t\tme.min = Math.min(min, max);\n\t\tme.max = Math.max(min + 1, max);\n\t}\n\t_getLabelBounds() {\n\t\tconst arr = this.getLabelTimestamps();\n\t\tlet min = Number.POSITIVE_INFINITY;\n\t\tlet max = Number.NEGATIVE_INFINITY;\n\t\tif (arr.length) {\n\t\t\tmin = arr[0];\n\t\t\tmax = arr[arr.length - 1];\n\t\t}\n\t\treturn {min, max};\n\t}\n\tbuildTicks() {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst timeOpts = options.time;\n\t\tconst tickOpts = options.ticks;\n\t\tconst timestamps = tickOpts.source === 'labels' ? me.getLabelTimestamps() : me._generate();\n\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\tme.min = me._userMin || timestamps[0];\n\t\t\tme.max = me._userMax || timestamps[timestamps.length - 1];\n\t\t}\n\t\tconst min = me.min;\n\t\tconst max = me.max;\n\t\tconst ticks = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ah\"])(timestamps, min, max);\n\t\tme._unit = timeOpts.unit || (tickOpts.autoSkip\n\t\t\t? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min))\n\t\t\t: determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\n\t\tme._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined\n\t\t\t: determineMajorUnit(me._unit);\n\t\tme.initOffsets(timestamps);\n\t\tif (options.reverse) {\n\t\t\tticks.reverse();\n\t\t}\n\t\treturn ticksFromTimestamps(me, ticks, me._majorUnit);\n\t}\n\tinitOffsets(timestamps) {\n\t\tconst me = this;\n\t\tlet start = 0;\n\t\tlet end = 0;\n\t\tlet first, last;\n\t\tif (me.options.offset && timestamps.length) {\n\t\t\tfirst = me.getDecimalForValue(timestamps[0]);\n\t\t\tif (timestamps.length === 1) {\n\t\t\t\tstart = 1 - first;\n\t\t\t} else {\n\t\t\t\tstart = (me.getDecimalForValue(timestamps[1]) - first) / 2;\n\t\t\t}\n\t\t\tlast = me.getDecimalForValue(timestamps[timestamps.length - 1]);\n\t\t\tif (timestamps.length === 1) {\n\t\t\t\tend = last;\n\t\t\t} else {\n\t\t\t\tend = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n\t\t\t}\n\t\t}\n\t\tme._offsets = {start, end, factor: 1 / (start + 1 + end)};\n\t}\n\t_generate() {\n\t\tconst me = this;\n\t\tconst adapter = me._adapter;\n\t\tconst min = me.min;\n\t\tconst max = me.max;\n\t\tconst options = me.options;\n\t\tconst timeOpts = options.time;\n\t\tconst minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));\n\t\tconst stepSize = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(timeOpts.stepSize, 1);\n\t\tconst weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\t\tconst hasWeekday = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(weekday) || weekday === true;\n\t\tconst ticks = {};\n\t\tlet first = min;\n\t\tlet time;\n\t\tif (hasWeekday) {\n\t\t\tfirst = +adapter.startOf(first, 'isoWeek', weekday);\n\t\t}\n\t\tfirst = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\t\tif (adapter.diff(max, min, minor) > 100000 * stepSize) {\n\t\t\tthrow new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n\t\t}\n\t\tconst timestamps = options.ticks.source === 'data' && me.getDataTimestamps();\n\t\tfor (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {\n\t\t\taddTick(ticks, time, timestamps);\n\t\t}\n\t\tif (time === max || options.bounds === 'ticks') {\n\t\t\taddTick(ticks, time, timestamps);\n\t\t}\n\t\treturn Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n\t}\n\tgetLabelForValue(value) {\n\t\tconst me = this;\n\t\tconst adapter = me._adapter;\n\t\tconst timeOpts = me.options.time;\n\t\tif (timeOpts.tooltipFormat) {\n\t\t\treturn adapter.format(value, timeOpts.tooltipFormat);\n\t\t}\n\t\treturn adapter.format(value, timeOpts.displayFormats.datetime);\n\t}\n\t_tickFormatFunction(time, index, ticks, format) {\n\t\tconst me = this;\n\t\tconst options = me.options;\n\t\tconst formats = options.time.displayFormats;\n\t\tconst unit = me._unit;\n\t\tconst majorUnit = me._majorUnit;\n\t\tconst minorFormat = unit && formats[unit];\n\t\tconst majorFormat = majorUnit && formats[majorUnit];\n\t\tconst tick = ticks[index];\n\t\tconst major = majorUnit && majorFormat && tick && tick.major;\n\t\tconst label = me._adapter.format(time, format || (major ? majorFormat : minorFormat));\n\t\tconst formatter = options.ticks.callback;\n\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t}\n\tgenerateTickLabels(ticks) {\n\t\tlet i, ilen, tick;\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\ttick = ticks[i];\n\t\t\ttick.label = this._tickFormatFunction(tick.value, i, ticks);\n\t\t}\n\t}\n\tgetDecimalForValue(value) {\n\t\tconst me = this;\n\t\treturn (value - me.min) / (me.max - me.min);\n\t}\n\tgetPixelForValue(value) {\n\t\tconst me = this;\n\t\tconst offsets = me._offsets;\n\t\tconst pos = me.getDecimalForValue(value);\n\t\treturn me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n\t}\n\tgetValueForPixel(pixel) {\n\t\tconst me = this;\n\t\tconst offsets = me._offsets;\n\t\tconst pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n\t\treturn me.min + pos * (me.max - me.min);\n\t}\n\t_getLabelSize(label) {\n\t\tconst me = this;\n\t\tconst ticksOpts = me.options.ticks;\n\t\tconst tickLabelWidth = me.ctx.measureText(label).width;\n\t\tconst angle = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n\t\tconst cosRotation = Math.cos(angle);\n\t\tconst sinRotation = Math.sin(angle);\n\t\tconst tickFontSize = me._resolveTickFontOptions(0).size;\n\t\treturn {\n\t\t\tw: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n\t\t\th: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n\t\t};\n\t}\n\t_getLabelCapacity(exampleTime) {\n\t\tconst me = this;\n\t\tconst timeOpts = me.options.time;\n\t\tconst displayFormats = timeOpts.displayFormats;\n\t\tconst format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n\t\tconst exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\n\t\tconst size = me._getLabelSize(exampleLabel);\n\t\tconst capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;\n\t\treturn capacity > 0 ? capacity : 1;\n\t}\n\tgetDataTimestamps() {\n\t\tconst me = this;\n\t\tlet timestamps = me._cache.data || [];\n\t\tlet i, ilen;\n\t\tif (timestamps.length) {\n\t\t\treturn timestamps;\n\t\t}\n\t\tconst metas = me.getMatchingVisibleMetas();\n\t\tif (me._normalized && metas.length) {\n\t\t\treturn (me._cache.data = metas[0].controller.getAllParsedValues(me));\n\t\t}\n\t\tfor (i = 0, ilen = metas.length; i < ilen; ++i) {\n\t\t\ttimestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));\n\t\t}\n\t\treturn (me._cache.data = me.normalize(timestamps));\n\t}\n\tgetLabelTimestamps() {\n\t\tconst me = this;\n\t\tconst timestamps = me._cache.labels || [];\n\t\tlet i, ilen;\n\t\tif (timestamps.length) {\n\t\t\treturn timestamps;\n\t\t}\n\t\tconst labels = me.getLabels();\n\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\ttimestamps.push(parse(me, labels[i]));\n\t\t}\n\t\treturn (me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps));\n\t}\n\tnormalize(values) {\n\t\treturn Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"ai\"])(values.sort(sorter));\n\t}\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n\tbounds: 'data',\n\tadapters: {},\n\ttime: {\n\t\tparser: false,\n\t\tunit: false,\n\t\tround: false,\n\t\tisoWeekday: false,\n\t\tminUnit: 'millisecond',\n\t\tdisplayFormats: {}\n\t},\n\tticks: {\n\t\tsource: 'auto',\n\t\tmajor: {\n\t\t\tenabled: false\n\t\t}\n\t}\n};\n\nfunction interpolate(table, val, reverse) {\n\tlet prevSource, nextSource, prevTarget, nextTarget;\n\tif (reverse) {\n\t\tprevSource = Math.floor(val);\n\t\tnextSource = Math.ceil(val);\n\t\tprevTarget = table[prevSource];\n\t\tnextTarget = table[nextSource];\n\t} else {\n\t\tconst result = Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"aj\"])(table, val);\n\t\tprevTarget = result.lo;\n\t\tnextTarget = result.hi;\n\t\tprevSource = table[prevTarget];\n\t\tnextSource = table[nextTarget];\n\t}\n\tconst span = nextSource - prevSource;\n\treturn span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis._table = [];\n\t\tthis._maxIndex = undefined;\n\t}\n\tinitOffsets() {\n\t\tconst me = this;\n\t\tconst timestamps = me._getTimestampsForTable();\n\t\tme._table = me.buildLookupTable(timestamps);\n\t\tme._maxIndex = me._table.length - 1;\n\t\tsuper.initOffsets(timestamps);\n\t}\n\tbuildLookupTable(timestamps) {\n\t\tconst me = this;\n\t\tconst {min, max} = me;\n\t\tif (!timestamps.length) {\n\t\t\treturn [\n\t\t\t\t{time: min, pos: 0},\n\t\t\t\t{time: max, pos: 1}\n\t\t\t];\n\t\t}\n\t\tconst items = [min];\n\t\tlet i, ilen, curr;\n\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\tcurr = timestamps[i];\n\t\t\tif (curr > min && curr < max) {\n\t\t\t\titems.push(curr);\n\t\t\t}\n\t\t}\n\t\titems.push(max);\n\t\treturn items;\n\t}\n\t_getTimestampsForTable() {\n\t\tconst me = this;\n\t\tlet timestamps = me._cache.all || [];\n\t\tif (timestamps.length) {\n\t\t\treturn timestamps;\n\t\t}\n\t\tconst data = me.getDataTimestamps();\n\t\tconst label = me.getLabelTimestamps();\n\t\tif (data.length && label.length) {\n\t\t\ttimestamps = me.normalize(data.concat(label));\n\t\t} else {\n\t\t\ttimestamps = data.length ? data : label;\n\t\t}\n\t\ttimestamps = me._cache.all = timestamps;\n\t\treturn timestamps;\n\t}\n\tgetPixelForValue(value, index) {\n\t\tconst me = this;\n\t\tconst offsets = me._offsets;\n\t\tconst pos = me._normalized && me._maxIndex > 0 && !Object(_chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(index)\n\t\t\t? index / me._maxIndex : me.getDecimalForValue(value);\n\t\treturn me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n\t}\n\tgetDecimalForValue(value) {\n\t\treturn interpolate(this._table, value) / this._maxIndex;\n\t}\n\tgetValueForPixel(pixel) {\n\t\tconst me = this;\n\t\tconst offsets = me._offsets;\n\t\tconst decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n\t\treturn interpolate(me._table, decimal * this._maxIndex, true);\n\t}\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./node_modules/chart.js/dist/chart.esm.js?")},"./node_modules/chart.js/dist/chunks/helpers.rtl.js":
/*!**********************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.rtl.js ***!
  \**********************************************************/
/*! exports provided: $, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, _, a, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$\", function() { return _steppedInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return _rlookupByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return toPadding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return getMaximumSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return _getParentNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return readUsedSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return throttled; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return supportsEventListenerOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return log10; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"J\", function() { return isNumberFinite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"K\", function() { return callback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return toDegrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return _measureText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return _int32Range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"O\", function() { return _alignPixel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P\", function() { return toFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Q\", function() { return _factorize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R\", function() { return uid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"S\", function() { return retinaScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"T\", function() { return clear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"U\", function() { return _elementsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"V\", function() { return getAngleFromPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"W\", function() { return _angleBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X\", function() { return _updateBezierControlPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Y\", function() { return _computeSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Z\", function() { return _boundSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_\", function() { return _capitalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return resolve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a0\", function() { return _bezierInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a1\", function() { return _pointInLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a2\", function() { return _steppedLineTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a3\", function() { return _bezierCurveTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a4\", function() { return drawPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a5\", function() { return toTRBL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a6\", function() { return _normalizeAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a7\", function() { return _boundSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a8\", function() { return getRtlAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a9\", function() { return overrideTextDirection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aa\", function() { return restoreTextDirection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ab\", function() { return distanceBetweenPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ac\", function() { return _setMinAndMaxByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ad\", function() { return _decimalPlaces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ae\", function() { return almostEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"af\", function() { return almostWhole; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ag\", function() { return _longestText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ah\", function() { return _filterBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ai\", function() { return _arrayUnique; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aj\", function() { return _lookup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ak\", function() { return fontString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"al\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"am\", function() { return _mergerIf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"an\", function() { return _deprecated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ao\", function() { return toFontString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ap\", function() { return splineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aq\", function() { return splineCurveMonotone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ar\", function() { return getStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"as\", function() { return toLineHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"at\", function() { return _angleDiff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return defaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return effects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return resolveObjectKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return getHoverColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return mergeIf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return _merger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return _limitValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return listenArrayEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return clipArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return unclipArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return isNullOrUndef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return requestAnimFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return sign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return unlistenArrayEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return valueOrDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return _lookupByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return toRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return getRelativePosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return _isPointInArea; });\n/*!\n * Chart.js v3.0.0-beta.3\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n\tif (typeof window === 'undefined') {\n\t\treturn function(callback) {\n\t\t\treturn callback();\n\t\t};\n\t}\n\treturn window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n\tconst updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n\tlet ticking = false;\n\tlet args = [];\n\treturn function(...rest) {\n\t\targs = updateArgs(rest);\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\trequestAnimFrame.call(window, () => {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\nconst effects = {\n\tlinear(t) {\n\t\treturn t;\n\t},\n\teaseInQuad(t) {\n\t\treturn t * t;\n\t},\n\teaseOutQuad(t) {\n\t\treturn -t * (t - 2);\n\t},\n\teaseInOutQuad(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t;\n\t\t}\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t},\n\teaseInCubic(t) {\n\t\treturn t * t * t;\n\t},\n\teaseOutCubic(t) {\n\t\treturn (t -= 1) * t * t + 1;\n\t},\n\teaseInOutCubic(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t},\n\teaseInQuart(t) {\n\t\treturn t * t * t * t;\n\t},\n\teaseOutQuart(t) {\n\t\treturn -((t -= 1) * t * t * t - 1);\n\t},\n\teaseInOutQuart(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t;\n\t\t}\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t},\n\teaseInQuint(t) {\n\t\treturn t * t * t * t * t;\n\t},\n\teaseOutQuint(t) {\n\t\treturn (t -= 1) * t * t * t * t + 1;\n\t},\n\teaseInOutQuint(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t},\n\teaseInSine(t) {\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t},\n\teaseOutSine(t) {\n\t\treturn Math.sin(t * (Math.PI / 2));\n\t},\n\teaseInOutSine(t) {\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t},\n\teaseInExpo(t) {\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t},\n\teaseOutExpo(t) {\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t},\n\teaseInOutExpo(t) {\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t}\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t},\n\teaseInCirc(t) {\n\t\tif (t >= 1) {\n\t\t\treturn t;\n\t\t}\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t},\n\teaseOutCirc(t) {\n\t\treturn Math.sqrt(1 - (t -= 1) * t);\n\t},\n\teaseInOutCirc(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t}\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t},\n\teaseInElastic(t) {\n\t\tlet s = 1.70158;\n\t\tlet p = 0;\n\t\tlet a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\t{\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t},\n\teaseOutElastic(t) {\n\t\tlet s = 1.70158;\n\t\tlet p = 0;\n\t\tlet a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\t{\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t},\n\teaseInOutElastic(t) {\n\t\tlet s = 1.70158;\n\t\tlet p = 0;\n\t\tlet a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((t /= 0.5) === 2) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.45;\n\t\t}\n\t\t{\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\tif (t < 1) {\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t}\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t},\n\teaseInBack(t) {\n\t\tconst s = 1.70158;\n\t\treturn t * t * ((s + 1) * t - s);\n\t},\n\teaseOutBack(t) {\n\t\tconst s = 1.70158;\n\t\treturn (t -= 1) * t * ((s + 1) * t + s) + 1;\n\t},\n\teaseInOutBack(t) {\n\t\tlet s = 1.70158;\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t},\n\teaseInBounce(t) {\n\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t},\n\teaseOutBounce(t) {\n\t\tif (t < (1 / 2.75)) {\n\t\t\treturn 7.5625 * t * t;\n\t\t}\n\t\tif (t < (2 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t}\n\t\tif (t < (2.5 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t}\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t},\n\teaseInOutBounce(t) {\n\t\tif (t < 0.5) {\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t}\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t}\n};\n\nfunction noop() {}\nconst uid = (function() {\n\tlet id = 0;\n\treturn function() {\n\t\treturn id++;\n\t};\n}());\nfunction isNullOrUndef(value) {\n\treturn value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n\tif (Array.isArray && Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tconst type = Object.prototype.toString.call(value);\n\tif (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n\t\treturn true;\n\t}\n\treturn false;\n}\nfunction isObject(value) {\n\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction valueOrDefault(value, defaultValue) {\n\treturn typeof value === 'undefined' ? defaultValue : value;\n}\nfunction callback(fn, args, thisArg) {\n\tif (fn && typeof fn.call === 'function') {\n\t\treturn fn.apply(thisArg, args);\n\t}\n}\nfunction each(loopable, fn, thisArg, reverse) {\n\tlet i, len, keys;\n\tif (isArray(loopable)) {\n\t\tlen = loopable.length;\n\t\tif (reverse) {\n\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t}\n\t\t}\n\t} else if (isObject(loopable)) {\n\t\tkeys = Object.keys(loopable);\n\t\tlen = keys.length;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t}\n\t}\n}\nfunction _elementsEqual(a0, a1) {\n\tlet i, ilen, v0, v1;\n\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\treturn false;\n\t}\n\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\tv0 = a0[i];\n\t\tv1 = a1[i];\n\t\tif (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nfunction clone(source) {\n\tif (isArray(source)) {\n\t\treturn source.map(clone);\n\t}\n\tif (isObject(source)) {\n\t\tconst target = {};\n\t\tconst keys = Object.keys(source);\n\t\tconst klen = keys.length;\n\t\tlet k = 0;\n\t\tfor (; k < klen; ++k) {\n\t\t\ttarget[keys[k]] = clone(source[keys[k]]);\n\t\t}\n\t\treturn target;\n\t}\n\treturn source;\n}\nfunction _merger(key, target, source, options) {\n\tconst tval = target[key];\n\tconst sval = source[key];\n\tif (isObject(tval) && isObject(sval)) {\n\t\tmerge(tval, sval, options);\n\t} else {\n\t\ttarget[key] = clone(sval);\n\t}\n}\nfunction merge(target, source, options) {\n\tconst sources = isArray(source) ? source : [source];\n\tconst ilen = sources.length;\n\tif (!isObject(target)) {\n\t\treturn target;\n\t}\n\toptions = options || {};\n\tconst merger = options.merger || _merger;\n\tfor (let i = 0; i < ilen; ++i) {\n\t\tsource = sources[i];\n\t\tif (!isObject(source)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst keys = Object.keys(source);\n\t\tfor (let k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\tmerger(keys[k], target, source, options);\n\t\t}\n\t}\n\treturn target;\n}\nfunction mergeIf(target, source) {\n\treturn merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n\tconst tval = target[key];\n\tconst sval = source[key];\n\tif (isObject(tval) && isObject(sval)) {\n\t\tmergeIf(tval, sval);\n\t} else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n\t\ttarget[key] = clone(sval);\n\t}\n}\nfunction _deprecated(scope, value, previous, current) {\n\tif (value !== undefined) {\n\t\tconsole.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n\t}\n}\nfunction resolveObjectKey(obj, key) {\n\tif (key.length < 3) {\n\t\treturn obj[key];\n\t}\n\tconst keys = key.split('.');\n\tfor (let i = 0, n = keys.length; i < n; ++i) {\n\t\tconst k = keys[i];\n\t\tif (k in obj) {\n\t\t\tobj = obj[k];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\treturn obj;\n}\nfunction _capitalize(str) {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction getScope(node, key) {\n\tif (!key) {\n\t\treturn node;\n\t}\n\tconst keys = key.split('.');\n\tfor (let i = 0, n = keys.length; i < n; ++i) {\n\t\tconst k = keys[i];\n\t\tnode = node[k] || (node[k] = {});\n\t}\n\treturn node;\n}\nclass Defaults {\n\tconstructor() {\n\t\tthis.color = 'rgba(0,0,0,0.1)';\n\t\tthis.elements = {};\n\t\tthis.events = [\n\t\t\t'mousemove',\n\t\t\t'mouseout',\n\t\t\t'click',\n\t\t\t'touchstart',\n\t\t\t'touchmove'\n\t\t];\n\t\tthis.font = {\n\t\t\tcolor: '#666',\n\t\t\tfamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t\tsize: 12,\n\t\t\tstyle: 'normal',\n\t\t\tlineHeight: 1.2,\n\t\t\tweight: null,\n\t\t\tlineWidth: 0,\n\t\t\tstrokeStyle: undefined\n\t\t};\n\t\tthis.hover = {\n\t\t\tonHover: null,\n\t\t\tmode: 'nearest',\n\t\t\tintersect: true\n\t\t};\n\t\tthis.maintainAspectRatio = true;\n\t\tthis.onClick = null;\n\t\tthis.responsive = true;\n\t\tthis.showLines = true;\n\t\tthis.plugins = {};\n\t\tthis.scale = undefined;\n\t\tthis.doughnut = undefined;\n\t\tthis.scales = {};\n\t\tthis.controllers = undefined;\n\t}\n\tset(scope, values) {\n\t\treturn merge(getScope(this, scope), values);\n\t}\n\tget(scope) {\n\t\treturn getScope(this, scope);\n\t}\n\troute(scope, name, targetScope, targetName) {\n\t\tconst scopeObject = getScope(this, scope);\n\t\tconst targetScopeObject = getScope(this, targetScope);\n\t\tconst privateName = '_' + name;\n\t\tObject.defineProperties(scopeObject, {\n\t\t\t[privateName]: {\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t[name]: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn valueOrDefault(this[privateName], targetScopeObject[targetName]);\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tthis[privateName] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\nvar defaults = new Defaults();\n\nconst PI = Math.PI;\nconst RAD_PER_DEG = PI / 180;\nconst DOUBLE_PI = PI * 2;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nfunction toFontString(font) {\n\tif (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n\t\treturn null;\n\t}\n\treturn (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n\tlet textWidth = data[string];\n\tif (!textWidth) {\n\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\tgc.push(string);\n\t}\n\tif (textWidth > longest) {\n\t\tlongest = textWidth;\n\t}\n\treturn longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n\tcache = cache || {};\n\tlet data = cache.data = cache.data || {};\n\tlet gc = cache.garbageCollect = cache.garbageCollect || [];\n\tif (cache.font !== font) {\n\t\tdata = cache.data = {};\n\t\tgc = cache.garbageCollect = [];\n\t\tcache.font = font;\n\t}\n\tctx.save();\n\tctx.font = font;\n\tlet longest = 0;\n\tconst ilen = arrayOfThings.length;\n\tlet i, j, jlen, thing, nestedThing;\n\tfor (i = 0; i < ilen; i++) {\n\t\tthing = arrayOfThings[i];\n\t\tif (thing !== undefined && thing !== null && isArray(thing) !== true) {\n\t\t\tlongest = _measureText(ctx, data, gc, longest, thing);\n\t\t} else if (isArray(thing)) {\n\t\t\tfor (j = 0, jlen = thing.length; j < jlen; j++) {\n\t\t\t\tnestedThing = thing[j];\n\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n\t\t\t\t\tlongest = _measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tctx.restore();\n\tconst gcLen = gc.length / 2;\n\tif (gcLen > arrayOfThings.length) {\n\t\tfor (i = 0; i < gcLen; i++) {\n\t\t\tdelete data[gc[i]];\n\t\t}\n\t\tgc.splice(0, gcLen);\n\t}\n\treturn longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n\tconst devicePixelRatio = chart.currentDevicePixelRatio;\n\tconst halfWidth = width / 2;\n\treturn Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clear(chart) {\n\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n}\nfunction drawPoint(ctx, options, x, y) {\n\tlet type, xOffset, yOffset, size, cornerRadius;\n\tconst style = options.pointStyle;\n\tconst rotation = options.rotation;\n\tconst radius = options.radius;\n\tlet rad = (rotation || 0) * RAD_PER_DEG;\n\tif (style && typeof style === 'object') {\n\t\ttype = style.toString();\n\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\tctx.save();\n\t\t\tctx.translate(x, y);\n\t\t\tctx.rotate(rad);\n\t\t\tctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n\t\t\tctx.restore();\n\t\t\treturn;\n\t\t}\n\t}\n\tif (isNaN(radius) || radius <= 0) {\n\t\treturn;\n\t}\n\tctx.beginPath();\n\tswitch (style) {\n\tdefault:\n\t\tctx.arc(x, y, radius, 0, DOUBLE_PI);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'triangle':\n\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\trad += TWO_THIRDS_PI;\n\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\trad += TWO_THIRDS_PI;\n\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'rectRounded':\n\t\tcornerRadius = radius * 0.516;\n\t\tsize = radius - cornerRadius;\n\t\txOffset = Math.cos(rad + QUARTER_PI) * size;\n\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\n\t\tctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n\t\tctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n\t\tctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n\t\tctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'rect':\n\t\tif (!rotation) {\n\t\t\tsize = Math.SQRT1_2 * radius;\n\t\t\tctx.rect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\t}\n\t\trad += QUARTER_PI;\n\tcase 'rectRot':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'crossRot':\n\t\trad += QUARTER_PI;\n\tcase 'cross':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\tbreak;\n\tcase 'star':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\trad += QUARTER_PI;\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\tbreak;\n\tcase 'line':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tbreak;\n\tcase 'dash':\n\t\tctx.moveTo(x, y);\n\t\tctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n\t\tbreak;\n\t}\n\tctx.fill();\n\tif (options.borderWidth > 0) {\n\t\tctx.stroke();\n\t}\n}\nfunction _isPointInArea(point, area) {\n\tconst epsilon = 0.5;\n\treturn point.x > area.left - epsilon && point.x < area.right + epsilon &&\n\t\tpoint.y > area.top - epsilon && point.y < area.bottom + epsilon;\n}\nfunction clipArea(ctx, area) {\n\tctx.save();\n\tctx.beginPath();\n\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\tctx.clip();\n}\nfunction unclipArea(ctx) {\n\tctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n\tif (!previous) {\n\t\treturn ctx.lineTo(target.x, target.y);\n\t}\n\tif (mode === 'middle') {\n\t\tconst midpoint = (previous.x + target.x) / 2.0;\n\t\tctx.lineTo(midpoint, previous.y);\n\t\tctx.lineTo(midpoint, target.y);\n\t} else if (mode === 'after' !== !!flip) {\n\t\tctx.lineTo(previous.x, target.y);\n\t} else {\n\t\tctx.lineTo(target.x, previous.y);\n\t}\n\tctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n\tif (!previous) {\n\t\treturn ctx.lineTo(target.x, target.y);\n\t}\n\tctx.bezierCurveTo(\n\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\ttarget.x,\n\t\ttarget.y);\n}\n\nfunction toLineHeight(value, size) {\n\tconst matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\tif (!matches || matches[1] === 'normal') {\n\t\treturn size * 1.2;\n\t}\n\tvalue = +matches[2];\n\tswitch (matches[3]) {\n\tcase 'px':\n\t\treturn value;\n\tcase '%':\n\t\tvalue /= 100;\n\t\tbreak;\n\t}\n\treturn size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction toTRBL(value) {\n\tlet t, r, b, l;\n\tif (isObject(value)) {\n\t\tt = numberOrZero(value.top);\n\t\tr = numberOrZero(value.right);\n\t\tb = numberOrZero(value.bottom);\n\t\tl = numberOrZero(value.left);\n\t} else {\n\t\tt = r = b = l = numberOrZero(value);\n\t}\n\treturn {\n\t\ttop: t,\n\t\tright: r,\n\t\tbottom: b,\n\t\tleft: l\n\t};\n}\nfunction toPadding(value) {\n\tconst obj = toTRBL(value);\n\tobj.width = obj.left + obj.right;\n\tobj.height = obj.top + obj.bottom;\n\treturn obj;\n}\nfunction toFont(options, fallback) {\n\toptions = options || {};\n\tfallback = fallback || defaults.font;\n\tlet size = valueOrDefault(options.size, fallback.size);\n\tif (typeof size === 'string') {\n\t\tsize = parseInt(size, 10);\n\t}\n\tconst font = {\n\t\tcolor: valueOrDefault(options.color, fallback.color),\n\t\tfamily: valueOrDefault(options.family, fallback.family),\n\t\tlineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n\t\tlineWidth: valueOrDefault(options.lineWidth, fallback.lineWidth),\n\t\tsize,\n\t\tstyle: valueOrDefault(options.style, fallback.style),\n\t\tweight: valueOrDefault(options.weight, fallback.weight),\n\t\tstrokeStyle: valueOrDefault(options.strokeStyle, fallback.strokeStyle),\n\t\tstring: ''\n\t};\n\tfont.string = toFontString(font);\n\treturn font;\n}\nfunction resolve(inputs, context, index, info) {\n\tlet cacheable = true;\n\tlet i, ilen, value;\n\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\tvalue = inputs[i];\n\t\tif (value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\tvalue = value(context);\n\t\t\tcacheable = false;\n\t\t}\n\t\tif (index !== undefined && isArray(value)) {\n\t\t\tvalue = value[index % value.length];\n\t\t\tcacheable = false;\n\t\t}\n\t\tif (value !== undefined) {\n\t\t\tif (info && !cacheable) {\n\t\t\t\tinfo.cacheable = false;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/*!\n * @kurkle/color v0.1.9\n * https://github.com/kurkle/color#readme\n * (c) 2020 Jukka Kurkela\n * Released under the MIT License\n */\nconst map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = '0123456789ABCDEF';\nconst h1 = (b) => hex[b & 0xF];\nconst h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));\nfunction isShort(v) {\n\treturn eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\n}\nfunction hexParse(str) {\n\tvar len = str.length;\n\tvar ret;\n\tif (str[0] === '#') {\n\t\tif (len === 4 || len === 5) {\n\t\t\tret = {\n\t\t\t\tr: 255 & map[str[1]] * 17,\n\t\t\t\tg: 255 & map[str[2]] * 17,\n\t\t\t\tb: 255 & map[str[3]] * 17,\n\t\t\t\ta: len === 5 ? map[str[4]] * 17 : 255\n\t\t\t};\n\t\t} else if (len === 7 || len === 9) {\n\t\t\tret = {\n\t\t\t\tr: map[str[1]] << 4 | map[str[2]],\n\t\t\t\tg: map[str[3]] << 4 | map[str[4]],\n\t\t\t\tb: map[str[5]] << 4 | map[str[6]],\n\t\t\t\ta: len === 9 ? (map[str[7]] << 4 | map[str[8]]) : 255\n\t\t\t};\n\t\t}\n\t}\n\treturn ret;\n}\nfunction hexString(v) {\n\tvar f = isShort(v) ? h1 : h2;\n\treturn v\n\t\t? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')\n\t\t: v;\n}\nfunction round(v) {\n\treturn v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n\treturn lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n\treturn lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n\treturn lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n\treturn lim(round(v * 100), 0, 100);\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n\tconst m = RGB_RE.exec(str);\n\tlet a = 255;\n\tlet r, g, b;\n\tif (!m) {\n\t\treturn;\n\t}\n\tif (m[7] !== r) {\n\t\tconst v = +m[7];\n\t\ta = 255 & (m[8] ? p2b(v) : v * 255);\n\t}\n\tr = +m[1];\n\tg = +m[3];\n\tb = +m[5];\n\tr = 255 & (m[2] ? p2b(r) : r);\n\tg = 255 & (m[4] ? p2b(g) : g);\n\tb = 255 & (m[6] ? p2b(b) : b);\n\treturn {\n\t\tr: r,\n\t\tg: g,\n\t\tb: b,\n\t\ta: a\n\t};\n}\nfunction rgbString(v) {\n\treturn v && (\n\t\tv.a < 255\n\t\t\t? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n\t\t\t: `rgb(${v.r}, ${v.g}, ${v.b})`\n\t);\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n\tconst a = s * Math.min(l, 1 - l);\n\tconst f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n\treturn [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n\tconst f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n\treturn [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n\tconst rgb = hsl2rgbn(h, 1, 0.5);\n\tlet i;\n\tif (w + b > 1) {\n\t\ti = 1 / (w + b);\n\t\tw *= i;\n\t\tb *= i;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] *= 1 - w - b;\n\t\trgb[i] += w;\n\t}\n\treturn rgb;\n}\nfunction rgb2hsl(v) {\n\tconst range = 255;\n\tconst r = v.r / range;\n\tconst g = v.g / range;\n\tconst b = v.b / range;\n\tconst max = Math.max(r, g, b);\n\tconst min = Math.min(r, g, b);\n\tconst l = (max + min) / 2;\n\tlet h, s, d;\n\tif (max !== min) {\n\t\td = max - min;\n\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\th = max === r\n\t\t\t? ((g - b) / d) + (g < b ? 6 : 0)\n\t\t\t: max === g\n\t\t\t\t? (b - r) / d + 2\n\t\t\t\t: (r - g) / d + 4;\n\t\th = h * 60 + 0.5;\n\t}\n\treturn [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n\treturn (\n\t\tArray.isArray(a)\n\t\t\t? f(a[0], a[1], a[2])\n\t\t\t: f(a, b, c)\n\t).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n\treturn calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n\treturn calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n\treturn calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n\treturn (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n\tconst m = HUE_RE.exec(str);\n\tlet a = 255;\n\tlet v;\n\tif (!m) {\n\t\treturn;\n\t}\n\tif (m[5] !== v) {\n\t\ta = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n\t}\n\tconst h = hue(+m[2]);\n\tconst p1 = +m[3] / 100;\n\tconst p2 = +m[4] / 100;\n\tif (m[1] === 'hwb') {\n\t\tv = hwb2rgb(h, p1, p2);\n\t} else if (m[1] === 'hsv') {\n\t\tv = hsv2rgb(h, p1, p2);\n\t} else {\n\t\tv = hsl2rgb(h, p1, p2);\n\t}\n\treturn {\n\t\tr: v[0],\n\t\tg: v[1],\n\t\tb: v[2],\n\t\ta: a\n\t};\n}\nfunction rotate(v, deg) {\n\tvar h = rgb2hsl(v);\n\th[0] = hue(h[0] + deg);\n\th = hsl2rgb(h);\n\tv.r = h[0];\n\tv.g = h[1];\n\tv.b = h[2];\n}\nfunction hslString(v) {\n\tif (!v) {\n\t\treturn;\n\t}\n\tconst a = rgb2hsl(v);\n\tconst h = a[0];\n\tconst s = n2p(a[1]);\n\tconst l = n2p(a[2]);\n\treturn v.a < 255\n\t\t? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n\t\t: `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map$1 = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n\tconst unpacked = {};\n\tconst keys = Object.keys(names);\n\tconst tkeys = Object.keys(map$1);\n\tlet i, j, k, ok, nk;\n\tfor (i = 0; i < keys.length; i++) {\n\t\tok = nk = keys[i];\n\t\tfor (j = 0; j < tkeys.length; j++) {\n\t\t\tk = tkeys[j];\n\t\t\tnk = nk.replace(k, map$1[k]);\n\t\t}\n\t\tk = parseInt(names[ok], 16);\n\t\tunpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n\t}\n\treturn unpacked;\n}\nlet names$1;\nfunction nameParse(str) {\n\tif (!names$1) {\n\t\tnames$1 = unpack();\n\t\tnames$1.transparent = [0, 0, 0, 0];\n\t}\n\tconst a = names$1[str.toLowerCase()];\n\treturn a && {\n\t\tr: a[0],\n\t\tg: a[1],\n\t\tb: a[2],\n\t\ta: a.length === 4 ? a[3] : 255\n\t};\n}\nfunction modHSL(v, i, ratio) {\n\tif (v) {\n\t\tlet tmp = rgb2hsl(v);\n\t\ttmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n\t\ttmp = hsl2rgb(tmp);\n\t\tv.r = tmp[0];\n\t\tv.g = tmp[1];\n\t\tv.b = tmp[2];\n\t}\n}\nfunction clone$1(v, proto) {\n\treturn v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n\tvar v = {r: 0, g: 0, b: 0, a: 255};\n\tif (Array.isArray(input)) {\n\t\tif (input.length >= 3) {\n\t\t\tv = {r: input[0], g: input[1], b: input[2], a: 255};\n\t\t\tif (input.length > 3) {\n\t\t\t\tv.a = n2b(input[3]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tv = clone$1(input, {r: 0, g: 0, b: 0, a: 1});\n\t\tv.a = n2b(v.a);\n\t}\n\treturn v;\n}\nfunction functionParse(str) {\n\tif (str.charAt(0) === 'r') {\n\t\treturn rgbParse(str);\n\t}\n\treturn hueParse(str);\n}\nclass Color {\n\tconstructor(input) {\n\t\tif (input instanceof Color) {\n\t\t\treturn input;\n\t\t}\n\t\tconst type = typeof input;\n\t\tlet v;\n\t\tif (type === 'object') {\n\t\t\tv = fromObject(input);\n\t\t} else if (type === 'string') {\n\t\t\tv = hexParse(input) || nameParse(input) || functionParse(input);\n\t\t}\n\t\tthis._rgb = v;\n\t\tthis._valid = !!v;\n\t}\n\tget valid() {\n\t\treturn this._valid;\n\t}\n\tget rgb() {\n\t\tvar v = clone$1(this._rgb);\n\t\tif (v) {\n\t\t\tv.a = b2n(v.a);\n\t\t}\n\t\treturn v;\n\t}\n\tset rgb(obj) {\n\t\tthis._rgb = fromObject(obj);\n\t}\n\trgbString() {\n\t\treturn this._valid ? rgbString(this._rgb) : this._rgb;\n\t}\n\thexString() {\n\t\treturn this._valid ? hexString(this._rgb) : this._rgb;\n\t}\n\thslString() {\n\t\treturn this._valid ? hslString(this._rgb) : this._rgb;\n\t}\n\tmix(color, weight) {\n\t\tconst me = this;\n\t\tif (color) {\n\t\t\tconst c1 = me.rgb;\n\t\t\tconst c2 = color.rgb;\n\t\t\tlet w2;\n\t\t\tconst p = weight === w2 ? 0.5 : weight;\n\t\t\tconst w = 2 * p - 1;\n\t\t\tconst a = c1.a - c2.a;\n\t\t\tconst w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\t\tw2 = 1 - w1;\n\t\t\tc1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n\t\t\tc1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n\t\t\tc1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n\t\t\tc1.a = p * c1.a + (1 - p) * c2.a;\n\t\t\tme.rgb = c1;\n\t\t}\n\t\treturn me;\n\t}\n\tclone() {\n\t\treturn new Color(this.rgb);\n\t}\n\talpha(a) {\n\t\tthis._rgb.a = n2b(a);\n\t\treturn this;\n\t}\n\tclearer(ratio) {\n\t\tconst rgb = this._rgb;\n\t\trgb.a *= 1 - ratio;\n\t\treturn this;\n\t}\n\tgreyscale() {\n\t\tconst rgb = this._rgb;\n\t\tconst val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n\t\trgb.r = rgb.g = rgb.b = val;\n\t\treturn this;\n\t}\n\topaquer(ratio) {\n\t\tconst rgb = this._rgb;\n\t\trgb.a *= 1 + ratio;\n\t\treturn this;\n\t}\n\tnegate() {\n\t\tconst v = this._rgb;\n\t\tv.r = 255 - v.r;\n\t\tv.g = 255 - v.g;\n\t\tv.b = 255 - v.b;\n\t\treturn this;\n\t}\n\tlighten(ratio) {\n\t\tmodHSL(this._rgb, 2, ratio);\n\t\treturn this;\n\t}\n\tdarken(ratio) {\n\t\tmodHSL(this._rgb, 2, -ratio);\n\t\treturn this;\n\t}\n\tsaturate(ratio) {\n\t\tmodHSL(this._rgb, 1, ratio);\n\t\treturn this;\n\t}\n\tdesaturate(ratio) {\n\t\tmodHSL(this._rgb, 1, -ratio);\n\t\treturn this;\n\t}\n\trotate(deg) {\n\t\trotate(this._rgb, deg);\n\t\treturn this;\n\t}\n}\nfunction index_esm(input) {\n\treturn new Color(input);\n}\n\nconst isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;\nfunction color(value) {\n\treturn isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n\treturn isPatternOrGradient(value)\n\t\t? value\n\t\t: index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nfunction _lookup(table, value, cmp) {\n\tcmp = cmp || ((index) => table[index] < value);\n\tlet hi = table.length - 1;\n\tlet lo = 0;\n\tlet mid;\n\twhile (hi - lo > 1) {\n\t\tmid = (lo + hi) >> 1;\n\t\tif (cmp(mid)) {\n\t\t\tlo = mid;\n\t\t} else {\n\t\t\thi = mid;\n\t\t}\n\t}\n\treturn {lo, hi};\n}\nconst _lookupByKey = (table, key, value) =>\n\t_lookup(table, value, index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n\t_lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n\tlet start = 0;\n\tlet end = values.length;\n\twhile (start < end && values[start] < min) {\n\t\tstart++;\n\t}\n\twhile (end > start && values[end - 1] > max) {\n\t\tend--;\n\t}\n\treturn start > 0 || end < values.length\n\t\t? values.slice(start, end)\n\t\t: values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n\tif (array._chartjs) {\n\t\tarray._chartjs.listeners.push(listener);\n\t\treturn;\n\t}\n\tObject.defineProperty(array, '_chartjs', {\n\t\tconfigurable: true,\n\t\tenumerable: false,\n\t\tvalue: {\n\t\t\tlisteners: [listener]\n\t\t}\n\t});\n\tarrayEvents.forEach((key) => {\n\t\tconst method = '_onData' + _capitalize(key);\n\t\tconst base = array[key];\n\t\tObject.defineProperty(array, key, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue(...args) {\n\t\t\t\tconst res = base.apply(this, args);\n\t\t\t\tarray._chartjs.listeners.forEach((object) => {\n\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\tobject[method](...args);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t});\n}\nfunction unlistenArrayEvents(array, listener) {\n\tconst stub = array._chartjs;\n\tif (!stub) {\n\t\treturn;\n\t}\n\tconst listeners = stub.listeners;\n\tconst index = listeners.indexOf(listener);\n\tif (index !== -1) {\n\t\tlisteners.splice(index, 1);\n\t}\n\tif (listeners.length > 0) {\n\t\treturn;\n\t}\n\tarrayEvents.forEach((key) => {\n\t\tdelete array[key];\n\t});\n\tdelete array._chartjs;\n}\nfunction _arrayUnique(items) {\n\tconst set = new Set();\n\tlet i, ilen;\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tset.add(items[i]);\n\t}\n\tif (set.size === ilen) {\n\t\treturn items;\n\t}\n\tconst result = [];\n\tset.forEach(item => {\n\t\tresult.push(item);\n\t});\n\treturn result;\n}\n\nconst PI$1 = Math.PI;\nconst TAU = 2 * PI$1;\nconst PITAU = TAU + PI$1;\nfunction _factorize(value) {\n\tconst result = [];\n\tconst sqrt = Math.sqrt(value);\n\tlet i;\n\tfor (i = 1; i < sqrt; i++) {\n\t\tif (value % i === 0) {\n\t\t\tresult.push(i);\n\t\t\tresult.push(value / i);\n\t\t}\n\t}\n\tif (sqrt === (sqrt | 0)) {\n\t\tresult.push(sqrt);\n\t}\n\tresult.sort((a, b) => a - b).pop();\n\treturn result;\n}\nconst log10 = Math.log10 || function(x) {\n\tconst exponent = Math.log(x) * Math.LOG10E;\n\tconst powerOf10 = Math.round(exponent);\n\tconst isPowerOf10 = x === Math.pow(10, powerOf10);\n\treturn isPowerOf10 ? powerOf10 : exponent;\n};\nfunction isNumber(n) {\n\treturn !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n\treturn Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n\tconst rounded = Math.round(x);\n\treturn ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n\tlet i, ilen, value;\n\tfor (i = 0, ilen = array.length; i < ilen; i++) {\n\t\tvalue = array[i][property];\n\t\tif (!isNaN(value)) {\n\t\t\ttarget.min = Math.min(target.min, value);\n\t\t\ttarget.max = Math.max(target.max, value);\n\t\t}\n\t}\n}\nconst sign = Math.sign ?\n\tfunction(x) {\n\t\treturn Math.sign(x);\n\t} :\n\tfunction(x) {\n\t\tx = +x;\n\t\tif (x === 0 || isNaN(x)) {\n\t\t\treturn x;\n\t\t}\n\t\treturn x > 0 ? 1 : -1;\n\t};\nfunction toRadians(degrees) {\n\treturn degrees * (PI$1 / 180);\n}\nfunction toDegrees(radians) {\n\treturn radians * (180 / PI$1);\n}\nfunction _decimalPlaces(x) {\n\tif (!isNumberFinite(x)) {\n\t\treturn;\n\t}\n\tlet e = 1;\n\tlet p = 0;\n\twhile (Math.round(x * e) / e !== x) {\n\t\te *= 10;\n\t\tp++;\n\t}\n\treturn p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n\tconst distanceFromXCenter = anglePoint.x - centrePoint.x;\n\tconst distanceFromYCenter = anglePoint.y - centrePoint.y;\n\tconst radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\tlet angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\tif (angle < (-0.5 * PI$1)) {\n\t\tangle += TAU;\n\t}\n\treturn {\n\t\tangle,\n\t\tdistance: radialDistanceFromCenter\n\t};\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n\treturn (a - b + PITAU) % TAU - PI$1;\n}\nfunction _normalizeAngle(a) {\n\treturn (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end) {\n\tconst a = _normalizeAngle(angle);\n\tconst s = _normalizeAngle(start);\n\tconst e = _normalizeAngle(end);\n\tconst angleToStart = _normalizeAngle(s - a);\n\tconst angleToEnd = _normalizeAngle(e - a);\n\tconst startToAngle = _normalizeAngle(a - s);\n\tconst endToAngle = _normalizeAngle(a - e);\n\treturn a === s || a === e || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n\treturn Math.max(min, Math.min(max, value));\n}\nfunction _int32Range(value) {\n\treturn _limitValue(value, -2147483648, 2147483647);\n}\n\nfunction _getParentNode(domNode) {\n\tlet parent = domNode.parentNode;\n\tif (parent && parent.toString() === '[object ShadowRoot]') {\n\t\tparent = parent.host;\n\t}\n\treturn parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n\tlet valueInPixels;\n\tif (typeof styleValue === 'string') {\n\t\tvalueInPixels = parseInt(styleValue, 10);\n\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t}\n\t} else {\n\t\tvalueInPixels = styleValue;\n\t}\n\treturn valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n\treturn el.currentStyle ?\n\t\tel.currentStyle[property] :\n\t\tgetComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n\tconst result = {};\n\tsuffix = suffix ? '-' + suffix : '';\n\tfor (let i = 0; i < 4; i++) {\n\t\tconst pos = positions[i];\n\t\tresult[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n\t}\n\tresult.width = result.left + result.right;\n\tresult.height = result.top + result.bottom;\n\treturn result;\n}\nfunction getCanvasPosition(evt, canvas) {\n\tconst e = evt.originalEvent || evt;\n\tconst touches = e.touches;\n\tconst source = touches && touches.length ? touches[0] : e;\n\tconst {offsetX, offsetY} = source;\n\tlet box = false;\n\tlet x, y;\n\tif (offsetX > 0 || offsetY > 0) {\n\t\tx = offsetX;\n\t\ty = offsetY;\n\t} else {\n\t\tconst rect = canvas.getBoundingClientRect();\n\t\tx = source.clientX - rect.left;\n\t\ty = source.clientY - rect.top;\n\t\tbox = true;\n\t}\n\treturn {x, y, box};\n}\nfunction getRelativePosition(evt, chart) {\n\tconst {canvas, currentDevicePixelRatio} = chart;\n\tconst style = getComputedStyle(canvas);\n\tconst borderBox = style.boxSizing === 'border-box';\n\tconst paddings = getPositionedStyle(style, 'padding');\n\tconst borders = getPositionedStyle(style, 'border', 'width');\n\tconst {x, y, box} = getCanvasPosition(evt, canvas);\n\tconst xOffset = paddings.left + (box && borders.left);\n\tconst yOffset = paddings.top + (box && borders.top);\n\tlet {width, height} = chart;\n\tif (borderBox) {\n\t\twidth -= paddings.width + borders.width;\n\t\theight -= paddings.height + borders.height;\n\t}\n\treturn {\n\t\tx: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n\t\ty: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n\t};\n}\nconst infinity = Number.POSITIVE_INFINITY;\nfunction getContainerSize(canvas, width, height) {\n\tlet maxWidth, maxHeight;\n\tif (width === undefined || height === undefined) {\n\t\tconst container = _getParentNode(canvas);\n\t\tif (!container) {\n\t\t\twidth = canvas.clientWidth;\n\t\t\theight = canvas.clientHeight;\n\t\t} else {\n\t\t\tconst rect = container.getBoundingClientRect();\n\t\t\tconst containerStyle = getComputedStyle(container);\n\t\t\tconst containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n\t\t\tconst contarinerPadding = getPositionedStyle(containerStyle, 'padding');\n\t\t\twidth = rect.width - contarinerPadding.width - containerBorder.width;\n\t\t\theight = rect.height - contarinerPadding.height - containerBorder.height;\n\t\t\tmaxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n\t\t\tmaxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n\t\t}\n\t}\n\treturn {\n\t\twidth,\n\t\theight,\n\t\tmaxWidth: maxWidth || infinity,\n\t\tmaxHeight: maxHeight || infinity\n\t};\n}\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n\tconst style = getComputedStyle(canvas);\n\tconst margins = getPositionedStyle(style, 'margin');\n\tconst maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || infinity;\n\tconst maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || infinity;\n\tconst containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n\tlet {width, height} = containerSize;\n\tif (style.boxSizing === 'content-box') {\n\t\tconst borders = getPositionedStyle(style, 'border', 'width');\n\t\tconst paddings = getPositionedStyle(style, 'padding');\n\t\twidth -= paddings.width + borders.width;\n\t\theight -= paddings.height + borders.height;\n\t}\n\twidth = Math.max(0, width - margins.width);\n\theight = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n\treturn {\n\t\twidth: Math.min(width, maxWidth, containerSize.maxWidth),\n\t\theight: Math.min(height, maxHeight, containerSize.maxHeight)\n\t};\n}\nfunction retinaScale(chart, forceRatio) {\n\tconst pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;\n\tconst {canvas, width, height} = chart;\n\tcanvas.height = height * pixelRatio;\n\tcanvas.width = width * pixelRatio;\n\tchart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\tif (canvas.style && !canvas.style.height && !canvas.style.width) {\n\t\tcanvas.style.height = height + 'px';\n\t\tcanvas.style.width = width + 'px';\n\t}\n}\nconst supportsEventListenerOptions = (function() {\n\tlet passiveSupported = false;\n\ttry {\n\t\tconst options = {\n\t\t\tget passive() {\n\t\t\t\tpassiveSupported = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\twindow.addEventListener('test', null, options);\n\t\twindow.removeEventListener('test', null, options);\n\t} catch (e) {\n\t}\n\treturn passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n\tconst value = getStyle(element, property);\n\tconst matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\treturn matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n\treturn {\n\t\tx: p1.x + t * (p2.x - p1.x),\n\t\ty: p1.y + t * (p2.y - p1.y)\n\t};\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n\treturn {\n\t\tx: p1.x + t * (p2.x - p1.x),\n\t\ty: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n\t\t: mode === 'after' ? t < 1 ? p1.y : p2.y\n\t\t: t > 0 ? p2.y : p1.y\n\t};\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n\tconst cp1 = {x: p1.controlPointNextX, y: p1.controlPointNextY};\n\tconst cp2 = {x: p2.controlPointPreviousX, y: p2.controlPointPreviousY};\n\tconst a = _pointInLine(p1, cp1, t);\n\tconst b = _pointInLine(cp1, cp2, t);\n\tconst c = _pointInLine(cp2, p2, t);\n\tconst d = _pointInLine(a, b, t);\n\tconst e = _pointInLine(b, c, t);\n\treturn _pointInLine(d, e, t);\n}\n\nfunction propertyFn(property) {\n\tif (property === 'angle') {\n\t\treturn {\n\t\t\tbetween: _angleBetween,\n\t\t\tcompare: _angleDiff,\n\t\t\tnormalize: _normalizeAngle,\n\t\t};\n\t}\n\treturn {\n\t\tbetween: (n, s, e) => n >= s && n <= e,\n\t\tcompare: (a, b) => a - b,\n\t\tnormalize: x => x\n\t};\n}\nfunction makeSubSegment(start, end, loop, count) {\n\treturn {\n\t\tstart: start % count,\n\t\tend: end % count,\n\t\tloop: loop && (end - start + 1) % count === 0\n\t};\n}\nfunction getSegment(segment, points, bounds) {\n\tconst {property, start: startBound, end: endBound} = bounds;\n\tconst {between, normalize} = propertyFn(property);\n\tconst count = points.length;\n\tlet {start, end, loop} = segment;\n\tlet i, ilen;\n\tif (loop) {\n\t\tstart += count;\n\t\tend += count;\n\t\tfor (i = 0, ilen = count; i < ilen; ++i) {\n\t\t\tif (!between(normalize(points[start % count][property]), startBound, endBound)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart--;\n\t\t\tend--;\n\t\t}\n\t\tstart %= count;\n\t\tend %= count;\n\t}\n\tif (end < start) {\n\t\tend += count;\n\t}\n\treturn {start, end, loop};\n}\nfunction _boundSegment(segment, points, bounds) {\n\tif (!bounds) {\n\t\treturn [segment];\n\t}\n\tconst {property, start: startBound, end: endBound} = bounds;\n\tconst count = points.length;\n\tconst {compare, between, normalize} = propertyFn(property);\n\tconst {start, end, loop} = getSegment(segment, points, bounds);\n\tconst result = [];\n\tlet inside = false;\n\tlet subStart = null;\n\tlet value, point, prevValue;\n\tconst startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n\tconst endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n\tconst shouldStart = () => inside || startIsBefore();\n\tconst shouldStop = () => !inside || endIsBefore();\n\tfor (let i = start, prev = start; i <= end; ++i) {\n\t\tpoint = points[i % count];\n\t\tif (point.skip) {\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = normalize(point[property]);\n\t\tinside = between(value, startBound, endBound);\n\t\tif (subStart === null && shouldStart()) {\n\t\t\tsubStart = compare(value, startBound) === 0 ? i : prev;\n\t\t}\n\t\tif (subStart !== null && shouldStop()) {\n\t\t\tresult.push(makeSubSegment(subStart, i, loop, count));\n\t\t\tsubStart = null;\n\t\t}\n\t\tprev = i;\n\t\tprevValue = value;\n\t}\n\tif (subStart !== null) {\n\t\tresult.push(makeSubSegment(subStart, end, loop, count));\n\t}\n\treturn result;\n}\nfunction _boundSegments(line, bounds) {\n\tconst result = [];\n\tconst segments = line.segments;\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst sub = _boundSegment(segments[i], line.points, bounds);\n\t\tif (sub.length) {\n\t\t\tresult.push(...sub);\n\t\t}\n\t}\n\treturn result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n\tlet start = 0;\n\tlet end = count - 1;\n\tif (loop && !spanGaps) {\n\t\twhile (start < count && !points[start].skip) {\n\t\t\tstart++;\n\t\t}\n\t}\n\twhile (start < count && points[start].skip) {\n\t\tstart++;\n\t}\n\tstart %= count;\n\tif (loop) {\n\t\tend += start;\n\t}\n\twhile (end > start && points[end % count].skip) {\n\t\tend--;\n\t}\n\tend %= count;\n\treturn {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n\tconst count = points.length;\n\tconst result = [];\n\tlet last = start;\n\tlet prev = points[start];\n\tlet end;\n\tfor (end = start + 1; end <= max; ++end) {\n\t\tconst cur = points[end % count];\n\t\tif (cur.skip || cur.stop) {\n\t\t\tif (!prev.skip) {\n\t\t\t\tloop = false;\n\t\t\t\tresult.push({start: start % count, end: (end - 1) % count, loop});\n\t\t\t\tstart = last = cur.stop ? end : null;\n\t\t\t}\n\t\t} else {\n\t\t\tlast = end;\n\t\t\tif (prev.skip) {\n\t\t\t\tstart = end;\n\t\t\t}\n\t\t}\n\t\tprev = cur;\n\t}\n\tif (last !== null) {\n\t\tresult.push({start: start % count, end: last % count, loop});\n\t}\n\treturn result;\n}\nfunction _computeSegments(line) {\n\tconst points = line.points;\n\tconst spanGaps = line.options.spanGaps;\n\tconst count = points.length;\n\tif (!count) {\n\t\treturn [];\n\t}\n\tconst loop = !!line._loop;\n\tconst {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\tif (spanGaps === true) {\n\t\treturn [{start, end, loop}];\n\t}\n\tconst max = end < start ? end + count : end;\n\tconst completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n\treturn solidSegments(points, start, max, completeLoop);\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n\tconst previous = firstPoint.skip ? middlePoint : firstPoint;\n\tconst current = middlePoint;\n\tconst next = afterPoint.skip ? middlePoint : afterPoint;\n\tconst d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\tconst d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\tlet s01 = d01 / (d01 + d12);\n\tlet s12 = d12 / (d01 + d12);\n\ts01 = isNaN(s01) ? 0 : s01;\n\ts12 = isNaN(s12) ? 0 : s12;\n\tconst fa = t * s01;\n\tconst fb = t * s12;\n\treturn {\n\t\tprevious: {\n\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t},\n\t\tnext: {\n\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t}\n\t};\n}\nfunction splineCurveMonotone(points) {\n\tconst pointsWithTangents = (points || []).map((point) => ({\n\t\tmodel: point,\n\t\tdeltaK: 0,\n\t\tmK: 0\n\t}));\n\tconst pointsLen = pointsWithTangents.length;\n\tlet i, pointBefore, pointCurrent, pointAfter;\n\tfor (i = 0; i < pointsLen; ++i) {\n\t\tpointCurrent = pointsWithTangents[i];\n\t\tif (pointCurrent.model.skip) {\n\t\t\tcontinue;\n\t\t}\n\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\tconst slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t}\n\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t} else if (sign(pointBefore.deltaK) !== sign(pointCurrent.deltaK)) {\n\t\t\tpointCurrent.mK = 0;\n\t\t} else {\n\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t}\n\t}\n\tlet alphaK, betaK, tauK, squaredMagnitude;\n\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\tpointCurrent = pointsWithTangents[i];\n\t\tpointAfter = pointsWithTangents[i + 1];\n\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (almostEquals(pointCurrent.deltaK, 0, EPSILON)) {\n\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\tcontinue;\n\t\t}\n\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\tif (squaredMagnitude <= 9) {\n\t\t\tcontinue;\n\t\t}\n\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t}\n\tlet deltaX;\n\tfor (i = 0; i < pointsLen; ++i) {\n\t\tpointCurrent = pointsWithTangents[i];\n\t\tif (pointCurrent.model.skip) {\n\t\t\tcontinue;\n\t\t}\n\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t}\n\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t}\n\t}\n}\nfunction capControlPoint(pt, min, max) {\n\treturn Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n\tlet i, ilen, point;\n\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\tpoint = points[i];\n\t\tif (!_isPointInArea(point, area)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i > 0 && _isPointInArea(points[i - 1], area)) {\n\t\t\tpoint.controlPointPreviousX = capControlPoint(point.controlPointPreviousX, area.left, area.right);\n\t\t\tpoint.controlPointPreviousY = capControlPoint(point.controlPointPreviousY, area.top, area.bottom);\n\t\t}\n\t\tif (i < points.length - 1 && _isPointInArea(points[i + 1], area)) {\n\t\t\tpoint.controlPointNextX = capControlPoint(point.controlPointNextX, area.left, area.right);\n\t\t\tpoint.controlPointNextY = capControlPoint(point.controlPointNextY, area.top, area.bottom);\n\t\t}\n\t}\n}\nfunction _updateBezierControlPoints(points, options, area, loop) {\n\tlet i, ilen, point, controlPoints;\n\tif (options.spanGaps) {\n\t\tpoints = points.filter((pt) => !pt.skip);\n\t}\n\tif (options.cubicInterpolationMode === 'monotone') {\n\t\tsplineCurveMonotone(points);\n\t} else {\n\t\tlet prev = loop ? points[points.length - 1] : points[0];\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\tpoint = points[i];\n\t\t\tcontrolPoints = splineCurve(\n\t\t\t\tprev,\n\t\t\t\tpoint,\n\t\t\t\tpoints[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n\t\t\t\toptions.tension\n\t\t\t);\n\t\t\tpoint.controlPointPreviousX = controlPoints.previous.x;\n\t\t\tpoint.controlPointPreviousY = controlPoints.previous.y;\n\t\t\tpoint.controlPointNextX = controlPoints.next.x;\n\t\t\tpoint.controlPointNextY = controlPoints.next.y;\n\t\t\tprev = point;\n\t\t}\n\t}\n\tif (options.capBezierPoints) {\n\t\tcapBezierPoints(points, area);\n\t}\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n\treturn {\n\t\tx(x) {\n\t\t\treturn rectX + rectX + width - x;\n\t\t},\n\t\tsetWidth(w) {\n\t\t\twidth = w;\n\t\t},\n\t\ttextAlign(align) {\n\t\t\tif (align === 'center') {\n\t\t\t\treturn align;\n\t\t\t}\n\t\t\treturn align === 'right' ? 'left' : 'right';\n\t\t},\n\t\txPlus(x, value) {\n\t\t\treturn x - value;\n\t\t},\n\t\tleftForLtr(x, itemWidth) {\n\t\t\treturn x - itemWidth;\n\t\t},\n\t};\n};\nconst getLeftToRightAdapter = function() {\n\treturn {\n\t\tx(x) {\n\t\t\treturn x;\n\t\t},\n\t\tsetWidth(w) {\n\t\t},\n\t\ttextAlign(align) {\n\t\t\treturn align;\n\t\t},\n\t\txPlus(x, value) {\n\t\t\treturn x + value;\n\t\t},\n\t\tleftForLtr(x, _itemWidth) {\n\t\t\treturn x;\n\t\t},\n\t};\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n\treturn rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n\tlet style, original;\n\tif (direction === 'ltr' || direction === 'rtl') {\n\t\tstyle = ctx.canvas.style;\n\t\toriginal = [\n\t\t\tstyle.getPropertyValue('direction'),\n\t\t\tstyle.getPropertyPriority('direction'),\n\t\t];\n\t\tstyle.setProperty('direction', direction, 'important');\n\t\tctx.prevTextDirection = original;\n\t}\n}\nfunction restoreTextDirection(ctx, original) {\n\tif (original !== undefined) {\n\t\tdelete ctx.prevTextDirection;\n\t\tctx.canvas.style.setProperty('direction', original[0], original[1]);\n\t}\n}\n\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./node_modules/chart.js/dist/chunks/helpers.rtl.js?")},"./node_modules/chart.js/dist/helpers.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/chart.js/dist/helpers.esm.js ***!
  \***************************************************/
/*! exports provided: _alignPixel, _angleBetween, _angleDiff, _arrayUnique, _bezierCurveTo, _bezierInterpolation, _boundSegment, _boundSegments, _capitalize, _computeSegments, _decimalPlaces, _deprecated, _elementsEqual, _factorize, _filterBetween, _getParentNode, _int32Range, _isPointInArea, _limitValue, _longestText, _lookup, _lookupByKey, _measureText, _merger, _mergerIf, _normalizeAngle, _pointInLine, _rlookupByKey, _setMinAndMaxByKey, _steppedInterpolation, _steppedLineTo, _updateBezierControlPoints, almostEquals, almostWhole, callback, clear, clipArea, clone, color, distanceBetweenPoints, drawPoint, each, easingEffects, fontString, getAngleFromPoint, getHoverColor, getMaximumSize, getRelativePosition, getRtlAdapter, getStyle, isArray, isFinite, isNullOrUndef, isNumber, isObject, listenArrayEvents, log10, merge, mergeIf, noop, overrideTextDirection, readUsedSize, requestAnimFrame, resolve, resolveObjectKey, restoreTextDirection, retinaScale, sign, splineCurve, splineCurveMonotone, supportsEventListenerOptions, toDegrees, toFont, toFontString, toLineHeight, toPadding, toRadians, toTRBL, uid, unclipArea, unlistenArrayEvents, valueOrDefault */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.rtl.js */ "./node_modules/chart.js/dist/chunks/helpers.rtl.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_alignPixel", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["O"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_angleBetween", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["W"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_angleDiff", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["at"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_arrayUnique", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ai"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_bezierCurveTo", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a3"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_bezierInterpolation", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a0"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_boundSegment", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a7"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_boundSegments", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["Z"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_capitalize", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["_"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_computeSegments", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["Y"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_decimalPlaces", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ad"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_deprecated", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["an"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_elementsEqual", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["U"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_factorize", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["Q"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_filterBetween", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ah"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getParentNode", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["E"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_int32Range", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["N"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_isPointInArea", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["z"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_limitValue", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["k"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_longestText", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ag"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_lookup", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["aj"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_lookupByKey", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["w"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_measureText", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["M"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_merger", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["j"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_mergerIf", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["am"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_normalizeAngle", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a6"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_pointInLine", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a1"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_rlookupByKey", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["A"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_setMinAndMaxByKey", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ac"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_steppedInterpolation", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["$"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_steppedLineTo", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a2"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_updateBezierControlPoints", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["X"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "almostEquals", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ae"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "almostWhole", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["af"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callback", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["K"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["T"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipArea", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["o"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["al"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["c"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distanceBetweenPoints", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ab"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawPoint", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a4"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "each", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["C"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easingEffects", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["e"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fontString", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ak"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAngleFromPoint", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["V"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHoverColor", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["g"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMaximumSize", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["D"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRelativePosition", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["y"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRtlAdapter", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a8"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStyle", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ar"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["b"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["J"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNullOrUndef", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["q"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["t"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["i"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "listenArrayEvents", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["l"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log10", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["I"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["m"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeIf", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["h"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["n"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "overrideTextDirection", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a9"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readUsedSize", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["F"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimFrame", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["r"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveObjectKey", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["f"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restoreTextDirection", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["aa"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retinaScale", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["S"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["s"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splineCurve", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ap"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splineCurveMonotone", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["aq"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "supportsEventListenerOptions", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["H"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["L"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toFont", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["P"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toFontString", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["ao"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toLineHeight", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["as"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPadding", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["B"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["x"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toTRBL", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["a5"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["R"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unclipArea", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["p"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unlistenArrayEvents", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["u"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueOrDefault", function() { return _chunks_helpers_rtl_js__WEBPACK_IMPORTED_MODULE_0__["v"]; });\n\n/*!\n * Chart.js v3.0.0-beta.3\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./node_modules/chart.js/dist/helpers.esm.js?')},"./node_modules/chart.js/helpers/helpers.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/chart.js/helpers/helpers.esm.js ***!
  \******************************************************/
/*! exports provided: _alignPixel, _angleBetween, _angleDiff, _arrayUnique, _bezierCurveTo, _bezierInterpolation, _boundSegment, _boundSegments, _capitalize, _computeSegments, _decimalPlaces, _deprecated, _elementsEqual, _factorize, _filterBetween, _getParentNode, _int32Range, _isPointInArea, _limitValue, _longestText, _lookup, _lookupByKey, _measureText, _merger, _mergerIf, _normalizeAngle, _pointInLine, _rlookupByKey, _setMinAndMaxByKey, _steppedInterpolation, _steppedLineTo, _updateBezierControlPoints, almostEquals, almostWhole, callback, clear, clipArea, clone, color, distanceBetweenPoints, drawPoint, each, easingEffects, fontString, getAngleFromPoint, getHoverColor, getMaximumSize, getRelativePosition, getRtlAdapter, getStyle, isArray, isFinite, isNullOrUndef, isNumber, isObject, listenArrayEvents, log10, merge, mergeIf, noop, overrideTextDirection, readUsedSize, requestAnimFrame, resolve, resolveObjectKey, restoreTextDirection, retinaScale, sign, splineCurve, splineCurveMonotone, supportsEventListenerOptions, toDegrees, toFont, toFontString, toLineHeight, toPadding, toRadians, toTRBL, uid, unclipArea, unlistenArrayEvents, valueOrDefault */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/helpers.esm */ "./node_modules/chart.js/dist/helpers.esm.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_alignPixel", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_alignPixel"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_angleBetween", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_angleBetween"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_angleDiff", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_angleDiff"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_arrayUnique", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_arrayUnique"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_bezierCurveTo", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_bezierCurveTo"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_bezierInterpolation", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_bezierInterpolation"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_boundSegment", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_boundSegment"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_boundSegments", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_boundSegments"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_capitalize", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_capitalize"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_computeSegments", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_computeSegments"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_decimalPlaces", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_decimalPlaces"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_deprecated", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_deprecated"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_elementsEqual", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_elementsEqual"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_factorize", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_factorize"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_filterBetween", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_filterBetween"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getParentNode", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_getParentNode"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_int32Range", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_int32Range"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_isPointInArea", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_isPointInArea"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_limitValue", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_limitValue"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_longestText", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_longestText"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_lookup", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_lookup"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_lookupByKey", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_lookupByKey"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_measureText", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_measureText"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_merger", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_merger"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_mergerIf", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_mergerIf"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_normalizeAngle", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_normalizeAngle"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_pointInLine", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_pointInLine"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_rlookupByKey", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_rlookupByKey"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_setMinAndMaxByKey", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_setMinAndMaxByKey"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_steppedInterpolation", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_steppedInterpolation"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_steppedLineTo", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_steppedLineTo"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_updateBezierControlPoints", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["_updateBezierControlPoints"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "almostEquals", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["almostEquals"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "almostWhole", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["almostWhole"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callback", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["callback"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["clear"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipArea", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["clipArea"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["clone"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["color"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distanceBetweenPoints", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["distanceBetweenPoints"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawPoint", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["drawPoint"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "each", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["each"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easingEffects", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["easingEffects"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fontString", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["fontString"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAngleFromPoint", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["getAngleFromPoint"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHoverColor", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["getHoverColor"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMaximumSize", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["getMaximumSize"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRelativePosition", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["getRelativePosition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRtlAdapter", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["getRtlAdapter"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStyle", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["getStyle"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["isArray"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["isFinite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNullOrUndef", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["isNullOrUndef"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["isNumber"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["isObject"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "listenArrayEvents", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["listenArrayEvents"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log10", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["log10"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["merge"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeIf", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["mergeIf"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["noop"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "overrideTextDirection", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["overrideTextDirection"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readUsedSize", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["readUsedSize"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimFrame", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["requestAnimFrame"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["resolve"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveObjectKey", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["resolveObjectKey"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restoreTextDirection", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["restoreTextDirection"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retinaScale", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["retinaScale"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["sign"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splineCurve", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["splineCurve"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splineCurveMonotone", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["splineCurveMonotone"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "supportsEventListenerOptions", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["supportsEventListenerOptions"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toDegrees"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toFont", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toFont"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toFontString", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toFontString"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toLineHeight", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toLineHeight"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPadding", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toPadding"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toRadians"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toTRBL", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["toTRBL"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["uid"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unclipArea", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["unclipArea"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unlistenArrayEvents", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["unlistenArrayEvents"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueOrDefault", function() { return _dist_helpers_esm__WEBPACK_IMPORTED_MODULE_0__["valueOrDefault"]; });\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./node_modules/chart.js/helpers/helpers.esm.js?')},"./node_modules/chartjs-chart-matrix/dist/chartjs-chart-matrix.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chartjs-chart-matrix/dist/chartjs-chart-matrix.esm.js ***!
  \****************************************************************************/
/*! exports provided: Matrix, MatrixController */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix\", function() { return Matrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatrixController\", function() { return MatrixController; });\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js */ \"./node_modules/chart.js/dist/chart.esm.js\");\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js/helpers */ \"./node_modules/chart.js/helpers/helpers.esm.js\");\n/*!\n * chartjs-chart-matrix v1.0.0-beta\n * https://github.com/kurkle/chartjs-chart-matrix#readme\n * (c) 2020 Jukka Kurkela\n * Released under the MIT license\n */\n\n\n\nclass MatrixController extends chart_js__WEBPACK_IMPORTED_MODULE_0__[\"DatasetController\"] {\n\tinitialize() {\n\t\tthis.enableOptionSharing = true;\n\t\tsuper.initialize();\n\t}\n\n\tupdate(mode) {\n\t\tconst me = this;\n\t\tconst meta = me._cachedMeta;\n\n\t\tme.updateElements(meta.data, 0, meta.data.length, mode);\n\t}\n\n\tupdateElements(rects, start, count, mode) {\n\t\tconst me = this;\n\t\tconst reset = mode === 'reset';\n\t\tconst {xScale, yScale} = me._cachedMeta;\n\t\tconst firstOpts = me.resolveDataElementOptions(start, mode);\n\t\tconst sharedOptions = me.getSharedOptions(mode, rects[start], firstOpts);\n\n\t\tfor (let i = start; i < start + count; i++) {\n\t\t\tconst parsed = !reset && me.getParsed(i);\n\t\t\tconst x = reset ? xScale.getBasePixel() : xScale.getPixelForValue(parsed.x);\n\t\t\tconst y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(parsed.y);\n\t\t\tconst options = me.resolveDataElementOptions(i, mode);\n\t\t\tconst {width, height, anchorX, anchorY} = options;\n\t\t\tconst properties = {\n\t\t\t\tx: anchorX === 'left' ? x : x - width / (anchorX === 'right' ? 1 : 2),\n\t\t\t\ty: anchorY === 'top' ? y : y - height / (anchorY === 'bottom' ? 1 : 2),\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\toptions\n\t\t\t};\n\t\t\tme.updateElement(rects[i], i, properties, mode);\n\t\t}\n\n\t\tme.updateSharedOptions(sharedOptions, mode);\n\t}\n\n\tdraw() {\n\t\tconst me = this;\n\t\tconst data = me.getMeta().data || [];\n\t\tlet i, ilen;\n\n\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\tdata[i].draw(me._ctx);\n\t\t}\n\t}\n}\n\nMatrixController.id = 'matrix';\nMatrixController.defaults = {\n\tdataElementType: 'matrix',\n\tdataElementOptions: [\n\t\t'backgroundColor',\n\t\t'borderColor',\n\t\t'borderWidth',\n\t\t'anchorX',\n\t\t'anchorY',\n\t\t'width',\n\t\t'height'\n\t],\n\n\thover: {\n\t\tmode: 'nearest',\n\t\tintersect: true\n\t},\n\tdatasets: {\n\t\tanimation: {\n\t\t\tnumbers: {\n\t\t\t\ttype: 'number',\n\t\t\t\tproperties: ['x', 'y', 'width', 'height']\n\t\t\t}\n\t\t},\n\t\tanchorX: 'center',\n\t\tanchorY: 'center'\n\t},\n\ttooltips: {\n\t\tmode: 'nearest',\n\t\tintersect: true\n\t},\n\tscales: {\n\t\tx: {\n\t\t\ttype: 'linear',\n\t\t\toffset: true\n\t\t},\n\t\ty: {\n\t\t\ttype: 'linear',\n\t\t\treverse: true\n\t\t}\n\t},\n};\n\n/**\n * Helper function to get the bounds of the rect\n * @param {Matrix} rect the rect\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the rect\n * @private\n */\nfunction getBounds(rect, useFinalPosition) {\n\tconst {x, y, width, height} = rect.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n\treturn {left: x, top: y, right: x + width, bottom: y + height};\n}\n\nfunction limit(value, min, max) {\n\treturn Math.max(Math.min(value, max), min);\n}\n\nfunction parseBorderWidth(rect, maxW, maxH) {\n\tconst value = rect.options.borderWidth;\n\tlet t, r, b, l;\n\n\tif (Object(chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__[\"isObject\"])(value)) {\n\t\tt = +value.top || 0;\n\t\tr = +value.right || 0;\n\t\tb = +value.bottom || 0;\n\t\tl = +value.left || 0;\n\t} else {\n\t\tt = r = b = l = +value || 0;\n\t}\n\n\treturn {\n\t\tt: limit(t, 0, maxH),\n\t\tr: limit(r, 0, maxW),\n\t\tb: limit(b, 0, maxH),\n\t\tl: limit(l, 0, maxW)\n\t};\n}\n\nfunction boundingRects(rect) {\n\tconst bounds = getBounds(rect);\n\tconst width = bounds.right - bounds.left;\n\tconst height = bounds.bottom - bounds.top;\n\tconst border = parseBorderWidth(rect, width / 2, height / 2);\n\n\treturn {\n\t\touter: {\n\t\t\tx: bounds.left,\n\t\t\ty: bounds.top,\n\t\t\tw: width,\n\t\t\th: height\n\t\t},\n\t\tinner: {\n\t\t\tx: bounds.left + border.l,\n\t\t\ty: bounds.top + border.t,\n\t\t\tw: width - border.l - border.r,\n\t\t\th: height - border.t - border.b\n\t\t}\n\t};\n}\n\nfunction inRange(rect, x, y, useFinalPosition) {\n\tconst skipX = x === null;\n\tconst skipY = y === null;\n\tconst bounds = !rect || (skipX && skipY) ? false : getBounds(rect, useFinalPosition);\n\n\treturn bounds\n\t\t&& (skipX || x >= bounds.left && x <= bounds.right)\n\t\t&& (skipY || y >= bounds.top && y <= bounds.bottom);\n}\n\nclass Matrix extends chart_js__WEBPACK_IMPORTED_MODULE_0__[\"Element\"] {\n\tconstructor(cfg) {\n\t\tsuper();\n\n\t\tthis.options = undefined;\n\t\tthis.width = undefined;\n\t\tthis.height = undefined;\n\n\t\tif (cfg) {\n\t\t\tObject.assign(this, cfg);\n\t\t}\n\t}\n\n\tdraw(ctx) {\n\t\tconst options = this.options;\n\t\tconst {inner, outer} = boundingRects(this);\n\n\t\tctx.save();\n\n\t\tif (outer.w !== inner.w || outer.h !== inner.h) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(outer.x, outer.y, outer.w, outer.h);\n\t\t\tctx.clip();\n\t\t\tctx.rect(inner.x, inner.y, inner.w, inner.h);\n\t\t\tctx.fillStyle = options.backgroundColor;\n\t\t\tctx.fill();\n\t\t\tctx.fillStyle = options.borderColor;\n\t\t\tctx.fill('evenodd');\n\t\t} else {\n\t\t\tctx.fillStyle = options.backgroundColor;\n\t\t\tctx.fillRect(inner.x, inner.y, inner.w, inner.h);\n\t\t}\n\n\t\tctx.restore();\n\t}\n\n\tinRange(mouseX, mouseY, useFinalPosition) {\n\t\treturn inRange(this, mouseX, mouseY, useFinalPosition);\n\t}\n\n\tinXRange(mouseX, useFinalPosition) {\n\t\treturn inRange(this, mouseX, null, useFinalPosition);\n\t}\n\n\tinYRange(mouseY, useFinalPosition) {\n\t\treturn inRange(this, null, mouseY, useFinalPosition);\n\t}\n\n\tgetCenterPoint(useFinalPosition) {\n\t\tconst {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n\t\treturn {\n\t\t\tx: x + width / 2,\n\t\t\ty: y + height / 2\n\t\t};\n\t}\n\n\ttooltipPosition() {\n\t\treturn this.getCenterPoint();\n\t}\n\n\tgetRange(axis) {\n\t\treturn axis === 'x' ? this.width / 2 : this.height / 2;\n\t}\n}\n\nMatrix.id = 'matrix';\nMatrix.defaults = {\n\twidth: 20,\n\theight: 20\n};\n\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./node_modules/chartjs-chart-matrix/dist/chartjs-chart-matrix.esm.js?")},"./src/RootContainer.js":
/*!******************************!*\
  !*** ./src/RootContainer.js ***!
  \******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/loader */ "./src/common/loader.js");\n/* harmony import */ var _expressionHeatmap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expressionHeatmap */ "./src/expressionHeatmap/index.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar RootContainer = /*#__PURE__*/function (_React$Component) {\n  _inherits(RootContainer, _React$Component);\n\n  var _super = _createSuper(RootContainer);\n\n  function RootContainer(props) {\n    var _this;\n\n    _classCallCheck(this, RootContainer);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      expressionHeatmapData: [],\n      expressionSamples: [],\n      expressionFeatures: [],\n      expressionOptions: {\n        scale: \'log\' // log or linear\n\n      },\n      error: null\n    };\n    return _this;\n  }\n\n  _createClass(RootContainer, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      // when testing via jest, don\'t do all the calcs\n      if (this.props.testing) return;\n      if (!this.props.entity || !this.props.serviceUrl) throw new Error(\'No `entity` or `serviceUrl` passed as prop\');\n      var _this$props = this.props,\n          featureId = _this$props.entity.value,\n          serviceUrl = _this$props.serviceUrl; // don\'t show heatmap for single features (report pages)\n\n      if (!Array.isArray(featureId)) return; // fetch data for expression heatmap\n\n      for (var index = 0; index < featureId.length; index++) {\n        Object(_expressionHeatmap__WEBPACK_IMPORTED_MODULE_2__["queryData"])(featureId[index], serviceUrl).then(function (response) {\n          // samples should be the same for each feature\n          var sampleData = Object(_expressionHeatmap__WEBPACK_IMPORTED_MODULE_2__["getSampleData"])(response);\n\n          _this2.setState(function (state) {\n            return {\n              expressionSamples: sampleData\n            };\n          }); // concat this feature\n\n\n          var featureData = Object(_expressionHeatmap__WEBPACK_IMPORTED_MODULE_2__["getFeatureData"])(response);\n\n          _this2.setState(function (state) {\n            return {\n              expressionFeatures: _this2.state.expressionFeatures.concat(featureData)\n            };\n          }); // get the data for this feature\n\n\n          var chartData = Object(_expressionHeatmap__WEBPACK_IMPORTED_MODULE_2__["getChartData"])(response, _this2.state.expressionOptions); // concat the data\n\n          _this2.setState(function (state) {\n            return {\n              expressionHeatmapData: _this2.state.expressionHeatmapData.concat(chartData)\n            };\n          });\n        })["catch"](function () {\n          return _this2.setState({\n            error: \'No Expression Data Found!\'\n          });\n        });\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {}\n  }, {\n    key: "render",\n    value: function render() {\n      // if (this.state.error) {\n      //     return <div className="rootContainer error">{this.state.error}</div>;\n      // }\n      if (!Array.isArray(this.props.entity.value)) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null);\n      }\n\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {\n        className: "rootContainer"\n      }, this.state.expressionHeatmapData.length > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_expressionHeatmap__WEBPACK_IMPORTED_MODULE_2__["chart"], {\n        chartData: this.state.expressionHeatmapData,\n        samples: this.state.expressionSamples,\n        features: this.state.expressionFeatures,\n        dataOptions: this.state.expressionOptions\n      })) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_common_loader__WEBPACK_IMPORTED_MODULE_1__["default"], null));\n    }\n  }]);\n\n  return RootContainer;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\n/* harmony default export */ __webpack_exports__["default"] = (RootContainer);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/RootContainer.js?')},"./src/common/loader.js":
/*!******************************!*\
  !*** ./src/common/loader.js ***!
  \******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction Loader() {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {\n    className: "loading-container"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null)));\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (Loader);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/common/loader.js?')},"./src/expressionHeatmap/chart.js":
/*!****************************************!*\
  !*** ./src/expressionHeatmap/chart.js ***!
  \****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ "./node_modules/chart.js/dist/chart.esm.js");\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chart.js/helpers */ "./node_modules/chart.js/helpers/helpers.esm.js");\n/* harmony import */ var chartjs_chart_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chartjs-chart-matrix */ "./node_modules/chartjs-chart-matrix/dist/chartjs-chart-matrix.esm.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_1__["Chart"].register(chart_js__WEBPACK_IMPORTED_MODULE_1__["Tooltip"], chart_js__WEBPACK_IMPORTED_MODULE_1__["CategoryScale"], chart_js__WEBPACK_IMPORTED_MODULE_1__["LinearScale"], chart_js__WEBPACK_IMPORTED_MODULE_1__["Title"], chartjs_chart_matrix__WEBPACK_IMPORTED_MODULE_3__["Matrix"], chartjs_chart_matrix__WEBPACK_IMPORTED_MODULE_3__["MatrixController"]);\n\nvar ExpressionHeatmap = /*#__PURE__*/function (_React$Component) {\n  _inherits(ExpressionHeatmap, _React$Component);\n\n  var _super = _createSuper(ExpressionHeatmap);\n\n  function ExpressionHeatmap(props) {\n    _classCallCheck(this, ExpressionHeatmap);\n\n    return _super.call(this, props);\n  }\n\n  _createClass(ExpressionHeatmap, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          chartData = _this$props.chartData,\n          samples = _this$props.samples,\n          features = _this$props.features,\n          dataOptions = _this$props.dataOptions;\n      chart_js__WEBPACK_IMPORTED_MODULE_1__["Chart"].defaults.font.size = 16;\n      this.chart = new chart_js__WEBPACK_IMPORTED_MODULE_1__["Chart"](this.graph, {\n        type: \'matrix\',\n        data: {\n          datasets: [{\n            label: \'My Matrix\',\n            data: chartData,\n            backgroundColor: function backgroundColor(context) {\n              var value = context.dataset.data[context.dataIndex].v;\n              var alpha = Math.max(value / 1000, 1.0);\n\n              if (dataOptions.scale != \'linear\') {\n                alpha = alpha = Math.log10(value) / 4;\n              }\n\n              return Object(chart_js_helpers__WEBPACK_IMPORTED_MODULE_2__["color"])(\'green\').alpha(alpha).rgbString();\n            },\n            width: function width(context) {\n              var a = context.chart.chartArea;\n\n              if (!a) {\n                return 0;\n              }\n\n              return (a.right - a.left) / samples.length;\n            },\n            height: function height(context) {\n              var a = context.chart.chartArea;\n\n              if (!a) {\n                return 0;\n              }\n\n              return (a.bottom - a.top) / features.length;\n            }\n          }],\n          xLabels: samples,\n          yLabels: features\n        },\n        options: {\n          tooltips: {\n            callbacks: {\n              title: function title() {\n                return \'\';\n              },\n              label: function label(context) {\n                var v = context.dataset.data[context.dataIndex];\n                return [v.y, v.x, v.v + \' TPM\'];\n              }\n            }\n          },\n          scales: {\n            x: {\n              type: \'category\',\n              display: true,\n              scaleLabel: {\n                display: false\n              },\n              offset: true,\n              autoSkip: false,\n              ticks: {\n                display: true,\n                font: {\n                  size: 16\n                }\n              },\n              gridLines: {\n                display: false\n              }\n            },\n            y: {\n              type: \'category\',\n              offset: true,\n              autoSkip: false,\n              ticks: {\n                display: true,\n                font: {\n                  size: 8\n                }\n              },\n              gridLines: {\n                display: false\n              }\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate() {\n      var _this$props2 = this.props,\n          chartData = _this$props2.chartData,\n          samples = _this$props2.samples,\n          features = _this$props2.features,\n          dataOptions = _this$props2.dataOptions;\n      if (chartData.length == 0) return;\n      this.chart.data.datasets[0].data = chartData;\n      this.chart.data.xLabels = samples;\n      this.chart.data.yLabels = features;\n      this.chart.options.scales.y.ticks.font.size = Math.min(Math.max(400 / features.length, 8), 16);\n\n      this.chart.data.datasets[0].height = function (context) {\n        var a = context.chart.chartArea;\n\n        if (!a) {\n          return 0;\n        }\n\n        return (a.bottom - a.top) / features.length;\n      };\n\n      this.chart.update();\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this = this;\n\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("canvas", {\n        // height={\n        //     (this.props.features.length > 30)\n        // \t? \'260px\'\n        // \t: \'\'\n        // }\n        className: "graph",\n        ref: function ref(r) {\n          _this.graph = r;\n        }\n      });\n    }\n  }]);\n\n  return ExpressionHeatmap;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\n/* harmony default export */ __webpack_exports__["default"] = (ExpressionHeatmap);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/chart.js?')},"./src/expressionHeatmap/chartData.js":
/*!********************************************!*\
  !*** ./src/expressionHeatmap/chartData.js ***!
  \********************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n// getExpressionHeatmapData in RootContainer.js\nfunction getChartData(results, dataOptions) {\n  var scale = dataOptions.scale; // // sort according to sample number\n  // results.sort((r1, r2) => {\n  // \tlet valA, valB;\n  //     valA = r1.sample.num;\n  //     valB = r2.sample.num;\n  //     return valA < valB ? -1 : valA > valB ? 1 : 0;\n  // });\n\n  var chartData = [];\n  results.forEach(function (result) {\n    // scale value acc to dataOptions - log / linear\n    // const scaleVal = n => (scale === \'log\' ? Math.log2(n) : n);\n    var item = {\n      "x": result.sample.name,\n      "y": result.feature.secondaryIdentifier,\n      "v": Number(result.value)\n    };\n    chartData.push(item);\n  });\n  return chartData;\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (getChartData);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/chartData.js?')},"./src/expressionHeatmap/controls.js":
/*!*******************************************!*\
  !*** ./src/expressionHeatmap/controls.js ***!
  \*******************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar Cell = function Cell(_ref) {\n  var id = _ref.id,\n      name = _ref.name,\n      text = _ref.text,\n      value = _ref.value,\n      checked = _ref.checked,\n      onChange = _ref.onChange;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", {\n    htmlFor: id\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {\n    type: "radio",\n    id: id,\n    name: name,\n    value: value,\n    onChange: onChange,\n    checked: checked\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, text));\n};\n\nfunction ExpressionControls(_ref2) {\n  var controlOptions = _ref2.controlOptions,\n      changeOptions = _ref2.changeOptions;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {\n    className: "controls"\n  });\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (ExpressionControls);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/controls.js?')},"./src/expressionHeatmap/featureData.js":
/*!**********************************************!*\
  !*** ./src/expressionHeatmap/featureData.js ***!
  \**********************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n// getExpressionFeatures in RootContainer.js\nfunction getFeatureData(results) {\n  var featureData = [];\n  results.forEach(function (result) {\n    var featureId = result.feature.secondaryIdentifier;\n\n    if (!featureData.includes(featureId)) {\n      featureData.push(featureId);\n    }\n  });\n  return featureData;\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (getFeatureData);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/featureData.js?')},"./src/expressionHeatmap/index.js":
/*!****************************************!*\
  !*** ./src/expressionHeatmap/index.js ***!
  \****************************************/
/*! exports provided: queryData, chart, controls, getChartData, getSampleData, getFeatureData */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./src/expressionHeatmap/chart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return _chart__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controls */ "./src/expressionHeatmap/controls.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "controls", function() { return _controls__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _queryData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queryData */ "./src/expressionHeatmap/queryData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queryData", function() { return _queryData__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _chartData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chartData */ "./src/expressionHeatmap/chartData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getChartData", function() { return _chartData__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _sampleData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sampleData */ "./src/expressionHeatmap/sampleData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSampleData", function() { return _sampleData__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n/* harmony import */ var _featureData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./featureData */ "./src/expressionHeatmap/featureData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFeatureData", function() { return _featureData__WEBPACK_IMPORTED_MODULE_5__["default"]; });\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/index.js?')},"./src/expressionHeatmap/queryData.js":
/*!********************************************!*\
  !*** ./src/expressionHeatmap/queryData.js ***!
  \********************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\nvar featureToExpressionQuery = function featureToExpressionQuery(_ref) {\n  var featureId = _ref.featureId;\n  return {\n    from: 'ExpressionValue',\n    select: ['value', 'feature.id', 'feature.secondaryIdentifier', 'sample.name', 'sample.num'],\n    orderBy: [{\n      path: 'sample.num',\n      direction: 'ASC'\n    }, {\n      path: 'feature.secondaryIdentifier',\n      direction: 'ASC'\n    }],\n    where: [{\n      path: 'feature.id',\n      op: '=',\n      value: featureId\n    }]\n  };\n}; // queryExpressionData in RootContainer.js\n\n\nfunction queryData(featureId, serviceUrl) {\n  var imjsClient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : imjs;\n  return new Promise(function (resolve, reject) {\n    // eslint-disable-next-line\n    var service = new imjsClient.Service({\n      root: serviceUrl\n    });\n    service.records(featureToExpressionQuery({\n      featureId: featureId\n    })).then(function (data) {\n      if (data && data.length) {\n        resolve(data);\n      } else {\n        reject('No data found!');\n      }\n    })[\"catch\"](reject);\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (queryData);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/queryData.js?")},"./src/expressionHeatmap/sampleData.js":
/*!*********************************************!*\
  !*** ./src/expressionHeatmap/sampleData.js ***!
  \*********************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n// getExpressionSamples in RootContainer.js\nfunction getSampleData(results) {\n  var sampleData = [];\n  results.forEach(function (result) {\n    var sampleName = result.sample.name;\n\n    if (!sampleData.includes(sampleName)) {\n      sampleData.push(sampleName);\n    }\n  });\n  return sampleData;\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (getSampleData);\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/expressionHeatmap/sampleData.js?')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: main */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "main", function() { return main; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _RootContainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RootContainer */ "./src/RootContainer.js");\n\n\n // make sure to export main, with the signature\n\nfunction main(el, service, imEntity, state, config) {\n  state = state || {};\n\n  if (!el || !service || !imEntity || !state || !config) {\n    throw new Error(\'Call main with correct signature\');\n  }\n\n  react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_RootContainer__WEBPACK_IMPORTED_MODULE_2__["default"], {\n    serviceUrl: service.root,\n    entity: imEntity.SequenceFeature,\n    config: config\n  }), el);\n}\n\n\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/./src/index.js?')},react:
/*!*******************************!*\
  !*** external "window.React" ***!
  \*******************************/
/*! no static exports found */function(module,exports){eval("module.exports = window.React;\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/external_%22window.React%22?")},"react-dom":
/*!**********************************!*\
  !*** external "window.ReactDOM" ***!
  \**********************************/
/*! no static exports found */function(module,exports){eval("module.exports = window.ReactDOM;\n\n//# sourceURL=webpack://bluegenesExpressionHeatmap/external_%22window.ReactDOM%22?")}});